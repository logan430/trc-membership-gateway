---
phase: 02-discord-integration
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/auth/discord-oauth.ts
  - src/routes/auth.ts
  - src/config/env.ts
autonomous: true

must_haves:
  truths:
    - "User can click a link to start Discord OAuth flow"
    - "OAuth state parameter prevents CSRF attacks"
    - "User is redirected back after Discord authorization"
    - "Discord account is linked to member record"
    - "Duplicate Discord linking is blocked"
    - "User receives session tokens after successful OAuth"
  artifacts:
    - path: "src/auth/discord-oauth.ts"
      provides: "OAuth helper functions"
      exports: ["generateAuthUrl", "exchangeCode", "fetchDiscordUser"]
    - path: "src/routes/auth.ts"
      provides: "OAuth routes /auth/discord and /auth/callback"
      contains: "router.get('/discord'"
  key_links:
    - from: "src/routes/auth.ts"
      to: "src/auth/discord-oauth.ts"
      via: "generateAuthUrl, exchangeCode, fetchDiscordUser calls"
      pattern: "generateAuthUrl|exchangeCode|fetchDiscordUser"
    - from: "src/routes/auth.ts"
      to: "src/auth/session.ts"
      via: "createAccessToken, createRefreshToken after OAuth success"
      pattern: "createAccessToken|createRefreshToken"
    - from: "src/routes/auth.ts"
      to: "prisma.member"
      via: "findUnique by discordId, update to link Discord"
      pattern: "prisma\\.member"
---

<objective>
Implement Discord OAuth2 authorization code flow for linking Discord accounts.

Purpose: Users must link their Discord account to receive roles and access the community. This flow uses the authorization code grant (not implicit) per security best practices.

Output: /auth/discord initiates OAuth, /auth/callback completes it and creates a session.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-discord-integration/02-CONTEXT.md
@.planning/phases/02-discord-integration/02-RESEARCH.md
@.planning/phases/02-discord-integration/02-01-SUMMARY.md
@src/auth/session.ts
@src/routes/auth.ts
@src/config/env.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Discord OAuth helpers</name>
  <files>
    src/auth/discord-oauth.ts
    src/config/env.ts
  </files>
  <action>
    Update src/config/env.ts:
    - Add DISCORD_REDIRECT_URI as required string (e.g., http://localhost:3000/auth/callback)

    Create src/auth/discord-oauth.ts:

    1. Define types:
       ```typescript
       interface DiscordTokenResponse {
         access_token: string;
         token_type: string;
         expires_in: number;
         refresh_token: string;
         scope: string;
       }

       interface DiscordUser {
         id: string;
         username: string;
         global_name: string | null;
         avatar: string | null;
         discriminator: string;  // "0" for new usernames
       }
       ```

    2. generateAuthUrl(state: string): string
       - Build URLSearchParams with:
         - client_id: env.DISCORD_CLIENT_ID
         - redirect_uri: env.DISCORD_REDIRECT_URI
         - response_type: 'code'
         - scope: 'identify' (NO email per CONTEXT.md)
         - state: the provided state
       - Return full Discord authorize URL

    3. exchangeCode(code: string): Promise<DiscordTokenResponse>
       - POST to https://discord.com/api/oauth2/token
       - Content-Type: application/x-www-form-urlencoded (CRITICAL per RESEARCH.md pitfall)
       - Body: URLSearchParams with client_id, client_secret, grant_type='authorization_code', code, redirect_uri
       - Parse and return JSON response
       - Throw on non-OK response with error details

    4. fetchDiscordUser(accessToken: string): Promise<DiscordUser>
       - GET https://discord.com/api/users/@me
       - Authorization: Bearer {accessToken}
       - Parse and return JSON
       - Throw on non-OK response
  </action>
  <verify>
    TypeScript compiles: npx tsc --noEmit
    File exists with exports: grep for generateAuthUrl, exchangeCode, fetchDiscordUser
  </verify>
  <done>
    Discord OAuth helpers exist with proper URL building and token exchange using x-www-form-urlencoded.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add OAuth routes to auth router</name>
  <files>
    src/routes/auth.ts
  </files>
  <action>
    Update src/routes/auth.ts to add OAuth routes:

    1. Import:
       - randomUUID from 'crypto'
       - generateAuthUrl, exchangeCode, fetchDiscordUser from discord-oauth
       - prisma from lib/prisma
       - REFRESH_COOKIE_OPTIONS, REFRESH_COOKIE_NAME from session.ts
       - cookie.serialize from 'cookie'

    2. GET /discord endpoint:
       - Generate state with randomUUID()
       - Set state cookie: oauth_state, httpOnly, secure in prod, sameSite 'lax', maxAge 10 min
       - Redirect to generateAuthUrl(state)

    3. GET /callback endpoint:
       - Extract code and state from query params
       - Get stored state from oauth_state cookie
       - Validate state (if missing or mismatch, redirect to /auth/error?reason=invalid_state)
       - Clear oauth_state cookie
       - If no code, redirect to /auth/error?reason=no_code

       - Try/catch the following:
         - Exchange code for tokens
         - Fetch Discord user
         - Check if Discord ID already linked: prisma.member.findUnique({ where: { discordId } })
         - If linked to different member, redirect to /auth/error?reason=discord_already_linked (per CONTEXT.md)
         - If not linked, create or update member:
           - If no member exists, create one with discordId, discordUsername, discordAvatar
           - If member exists but no Discord, update to add Discord info
           - Note: In Phase 3, members will be created at payment time - this creates a stub member
         - Create access and refresh tokens (rememberMe = true for OAuth flow)
         - Set refresh cookie using cookie.serialize with REFRESH_COOKIE_OPTIONS
         - Redirect to dashboard with access token: /dashboard#token={accessToken}

       - On error:
         - Log with context
         - Redirect to /auth/error?reason=oauth_failed

    4. GET /error endpoint:
       - Return JSON { error: req.query.reason || 'unknown_error' }
       - (In production, this would render an error page)
  </action>
  <verify>
    TypeScript compiles: npx tsc --noEmit
    Server starts: npm run dev
    GET /auth/discord redirects to Discord (status 302)
    GET /auth/callback without state returns error
  </verify>
  <done>
    OAuth flow complete: /auth/discord initiates, /auth/callback completes, session tokens are issued, Discord is linked to member.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` compiles without errors
2. `npm run dev` starts successfully
3. `curl -v http://localhost:3000/auth/discord` returns 302 redirect to discord.com
4. `curl http://localhost:3000/auth/callback` returns error (no state)
5. Full flow test (manual): Click /auth/discord, authorize in Discord, callback links account
</verification>

<success_criteria>
- /auth/discord redirects to Discord OAuth with state parameter
- /auth/callback validates state, exchanges code, links Discord
- Duplicate Discord account is rejected
- Session tokens are created on success
- User is redirected to dashboard with access token
</success_criteria>

<output>
After completion, create `.planning/phases/02-discord-integration/02-03-SUMMARY.md`
</output>
