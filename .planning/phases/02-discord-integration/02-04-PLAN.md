---
phase: 02-discord-integration
plan: 04
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/auth/magic-link.ts
  - src/routes/auth.ts
autonomous: true

must_haves:
  truths:
    - "User can request a magic link by providing their email"
    - "Magic link token expires after 5 minutes"
    - "User can complete login by clicking the magic link"
    - "Invalid or expired magic links are rejected"
    - "User receives session tokens after successful verification"
  artifacts:
    - path: "src/auth/magic-link.ts"
      provides: "Magic link token generation and verification"
      exports: ["createMagicLinkToken", "verifyMagicLink"]
    - path: "src/routes/auth.ts"
      provides: "Magic link routes"
      contains: "router.post('/magic-link/request'"
  key_links:
    - from: "src/routes/auth.ts"
      to: "src/auth/magic-link.ts"
      via: "createMagicLinkToken, verifyMagicLink calls"
      pattern: "createMagicLinkToken|verifyMagicLink"
    - from: "src/routes/auth.ts"
      to: "src/auth/session.ts"
      via: "createAccessToken, createRefreshToken after magic link verify"
      pattern: "createAccessToken|createRefreshToken"
    - from: "src/routes/auth.ts"
      to: "prisma.member"
      via: "findUnique by email to lookup member"
      pattern: "prisma\\.member\\.findUnique.*email"
---

<objective>
Implement magic link (passwordless) authentication for returning users.

Purpose: Users who already have an account can log in via email link without needing Discord OAuth again. This provides an alternative login path per AUTH-03/AUTH-04.

Output: /auth/magic-link/request sends a magic link (logged for now, email in Phase 7), /auth/magic-link/verify completes login.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-discord-integration/02-CONTEXT.md
@.planning/phases/02-discord-integration/02-RESEARCH.md
@.planning/phases/02-discord-integration/02-01-SUMMARY.md
@src/auth/session.ts
@src/routes/auth.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create magic link token utilities</name>
  <files>
    src/auth/magic-link.ts
  </files>
  <action>
    Create src/auth/magic-link.ts:

    1. Import SignJWT, jwtVerify from 'jose'
    2. Import env and create secret using TextEncoder (same as session.ts)

    3. createMagicLinkToken(email: string): Promise<string>
       - Create JWT with:
         - Payload: { email, purpose: 'magic-link' }
         - Algorithm: HS256
         - Expiration: 5 minutes (short-lived per RESEARCH.md)
       - Return the signed token

    4. verifyMagicLink(token: string): Promise<{ email: string } | null>
       - Try to verify token with jwtVerify
       - Check that payload.purpose === 'magic-link'
       - Return { email: payload.email as string } on success
       - Return null on any error (expired, invalid, wrong purpose)

    5. buildMagicLinkUrl(token: string): string
       - Return `${env.APP_URL}/auth/magic-link/verify?token=${token}`
       - (APP_URL should be added to env.ts in Task 2)
  </action>
  <verify>
    TypeScript compiles: npx tsc --noEmit
    File exists with exports
  </verify>
  <done>
    Magic link utilities exist with 5-minute token expiration and purpose validation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add magic link routes</name>
  <files>
    src/routes/auth.ts
    src/config/env.ts
  </files>
  <action>
    Update src/config/env.ts:
    - Add APP_URL as required string (e.g., http://localhost:3000)

    Update src/routes/auth.ts:

    1. Import createMagicLinkToken, verifyMagicLink, buildMagicLinkUrl from magic-link.ts

    2. POST /magic-link/request endpoint:
       - Parse body for { email } (validate email is string)
       - If no email, return 400 { error: 'Email is required' }
       - Look up member by email: prisma.member.findFirst({ where: { email } })
       - If no member found, return 200 { success: true, message: 'If an account exists, a magic link has been sent' }
         (Don't reveal whether email exists - security best practice)
       - Create magic link token
       - Build magic link URL
       - LOG the magic link URL (Phase 7 will add email sending):
         logger.info({ email, url: magicLinkUrl }, 'Magic link generated')
       - Return 200 { success: true, message: 'If an account exists, a magic link has been sent' }

    3. GET /magic-link/verify endpoint:
       - Extract token from query params
       - If no token, return 400 { error: 'Token is required' }
       - Verify magic link token
       - If invalid/expired, return 401 { error: 'Invalid or expired magic link' }
       - Look up member by email from token payload
       - If no member, return 401 { error: 'Member not found' } (shouldn't happen but handle it)
       - Create access and refresh tokens (rememberMe = true)
       - Set refresh cookie
       - Redirect to dashboard with token: /dashboard#token={accessToken}
  </action>
  <verify>
    TypeScript compiles: npx tsc --noEmit
    Server starts: npm run dev
    POST /auth/magic-link/request with email returns 200
    GET /auth/magic-link/verify without token returns 400
    Check logs for magic link URL when requesting
  </verify>
  <done>
    Magic link flow complete: request generates logged URL, verify exchanges for session tokens.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` compiles without errors
2. `npm run dev` starts successfully
3. `curl -X POST http://localhost:3000/auth/magic-link/request -H "Content-Type: application/json" -d '{"email":"test@example.com"}'` returns 200
4. Check server logs for magic link URL
5. If member exists with that email, verify the link works to create a session
</verification>

<success_criteria>
- /auth/magic-link/request accepts email and generates token (logged)
- /auth/magic-link/verify validates token and creates session
- Invalid/expired tokens are rejected
- Response doesn't reveal whether email exists
- User is redirected to dashboard on success
</success_criteria>

<output>
After completion, create `.planning/phases/02-discord-integration/02-04-SUMMARY.md`
</output>
