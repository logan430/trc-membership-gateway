---
phase: 03-individual-subscription
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/config/env.ts
  - src/lib/password.ts
  - src/routes/auth.ts
  - src/routes/checkout.ts
  - src/webhooks/stripe.ts
  - src/index.ts
autonomous: true
user_setup:
  - service: stripe
    why: "Individual Monthly subscription price"
    env_vars:
      - name: STRIPE_INDIVIDUAL_PRICE_ID
        source: "Stripe Dashboard -> Products -> Create Product -> Add Monthly Price -> Copy Price ID (starts with price_)"

must_haves:
  truths:
    - "User can register with email and password"
    - "User can register with magic link (existing)"
    - "Registered user can initiate Stripe Checkout"
    - "Successful checkout updates member subscription status to ACTIVE"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "passwordHash field on Member model"
      contains: "passwordHash"
    - path: "src/lib/password.ts"
      provides: "Argon2id hashing utilities"
      exports: ["hashPassword", "verifyPassword"]
    - path: "src/routes/auth.ts"
      provides: "POST /signup endpoint"
      contains: "router.post.*signup"
    - path: "src/routes/checkout.ts"
      provides: "POST /checkout endpoint"
      exports: ["checkoutRouter"]
    - path: "src/webhooks/stripe.ts"
      provides: "checkout.session.completed handler"
      contains: "checkout.session.completed"
  key_links:
    - from: "src/routes/auth.ts"
      to: "src/lib/password.ts"
      via: "import hashPassword"
      pattern: "import.*password"
    - from: "src/routes/checkout.ts"
      to: "stripe.checkout.sessions.create"
      via: "Stripe SDK call"
      pattern: "checkout\\.sessions\\.create"
    - from: "src/webhooks/stripe.ts"
      to: "prisma.member.update"
      via: "Update subscription status"
      pattern: "subscriptionStatus.*ACTIVE"
---

<objective>
Implement user registration (email+password) and Stripe Checkout flow for Individual Monthly subscription.

Purpose: Enable new users to create accounts and pay for membership via Stripe Checkout. This is the foundation for the claim flow in Plan 02.

Output:
- Password hashing with Argon2id (OWASP 2025 recommendation)
- POST /auth/signup endpoint (email + password registration)
- POST /checkout endpoint (creates Stripe Checkout session)
- Webhook handler for checkout.session.completed (activates subscription)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-individual-subscription/03-CONTEXT.md
@.planning/phases/03-individual-subscription/03-RESEARCH.md
@prisma/schema.prisma
@src/config/env.ts
@src/routes/auth.ts
@src/webhooks/stripe.ts
@src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Schema and Password Infrastructure</name>
  <files>
    prisma/schema.prisma
    src/lib/password.ts
    src/config/env.ts
  </files>
  <action>
1. Add `passwordHash String?` field to Member model in schema.prisma (null for magic-link-only users)

2. Add environment variables to src/config/env.ts:
   - `STRIPE_INDIVIDUAL_PRICE_ID: z.string().startsWith('price_')`
   - `DISCORD_INVITE_URL: z.string().url()`

3. Create src/lib/password.ts with Argon2id utilities:
   ```typescript
   import argon2 from 'argon2';

   // OWASP 2025 recommended parameters
   const ARGON2_OPTIONS = {
     type: argon2.argon2id,
     memoryCost: 19456,  // 19 MiB
     timeCost: 2,
     parallelism: 1,
   };

   export async function hashPassword(password: string): Promise<string> {
     return argon2.hash(password, ARGON2_OPTIONS);
   }

   export async function verifyPassword(hash: string, password: string): Promise<boolean> {
     try {
       return await argon2.verify(hash, password);
     } catch {
       return false;
     }
   }
   ```

4. Install argon2: `npm install argon2`

5. Run `npx prisma db push` to apply schema changes
  </action>
  <verify>
- `npm run build` compiles without errors
- `npx prisma db push` succeeds
- password.ts exports hashPassword and verifyPassword
  </verify>
  <done>
- Member model has passwordHash field
- Argon2id password hashing available via password.ts
- New env vars validated by Zod schema
  </done>
</task>

<task type="auto">
  <name>Task 2: Signup and Checkout Routes</name>
  <files>
    src/routes/auth.ts
    src/routes/checkout.ts
    src/index.ts
  </files>
  <action>
1. Add POST /auth/signup to src/routes/auth.ts:
   - Validate email (valid format) and password (8-128 chars) with Zod
   - Check if email already exists - return same success response (anti-enumeration)
   - Hash password with hashPassword()
   - Create Stripe customer with email
   - Create Member with email, passwordHash, stripeCustomerId, seatTier: 'INDIVIDUAL'
   - Create access token and refresh token
   - Set refresh cookie, return access token
   - Log signup success

2. Add POST /auth/login to src/routes/auth.ts:
   - Validate email and password
   - Find member by email
   - Use timing-safe verification (always verify even if no member)
   - Return 401 with generic "Invalid credentials" on failure
   - Create tokens and set cookies on success

3. Create src/routes/checkout.ts:
   ```typescript
   import { Router, Response } from 'express';
   import Stripe from 'stripe';
   import { requireAuth, AuthenticatedRequest } from '../middleware/session.js';
   import { prisma } from '../lib/prisma.js';
   import { env } from '../config/env.js';
   import { logger } from '../index.js';

   const stripe = new Stripe(env.STRIPE_SECRET_KEY);
   export const checkoutRouter = Router();

   checkoutRouter.post('/', requireAuth, async (req: AuthenticatedRequest, res: Response) => {
     const member = await prisma.member.findUnique({
       where: { id: req.memberId },
     });

     if (!member?.stripeCustomerId) {
       return res.status(400).json({ error: 'Account not configured for payment' });
     }

     if (member.subscriptionStatus === 'ACTIVE') {
       return res.status(400).json({ error: 'Already subscribed' });
     }

     const session = await stripe.checkout.sessions.create({
       mode: 'subscription',
       customer: member.stripeCustomerId,
       client_reference_id: member.id,
       line_items: [{
         price: env.STRIPE_INDIVIDUAL_PRICE_ID,
         quantity: 1,
       }],
       success_url: `${env.APP_URL}/dashboard?checkout=success`,
       cancel_url: `${env.APP_URL}/dashboard?checkout=cancel`,
     });

     logger.info({ memberId: member.id, sessionId: session.id }, 'Checkout session created');
     res.json({ checkoutUrl: session.url });
   });
   ```

4. Mount checkout router in src/index.ts:
   - Import checkoutRouter
   - Add `app.use('/checkout', checkoutRouter);` after auth routes
  </action>
  <verify>
- `npm run build` compiles without errors
- POST /auth/signup returns 200 with accessToken for valid input
- POST /auth/login returns 200 with accessToken for valid credentials
- POST /checkout requires auth (returns 401 without token)
  </verify>
  <done>
- Users can register with email + password
- Users can login with email + password
- Authenticated users can create Stripe Checkout sessions
  </done>
</task>

<task type="auto">
  <name>Task 3: Checkout Completed Webhook Handler</name>
  <files>
    src/webhooks/stripe.ts
  </files>
  <action>
Update the processStripeEvent function in src/webhooks/stripe.ts to handle checkout.session.completed:

```typescript
case 'checkout.session.completed': {
  const session = event.data.object as Stripe.Checkout.Session;

  // Only handle subscription mode (not one-time payments)
  if (session.mode !== 'subscription') {
    logger.debug({ sessionId: session.id }, 'Ignoring non-subscription checkout');
    break;
  }

  // Retrieve session with expanded subscription data
  const expandedSession = await stripe.checkout.sessions.retrieve(
    session.id,
    { expand: ['subscription'] }
  );

  const memberId = expandedSession.client_reference_id;
  if (!memberId) {
    logger.error({ sessionId: session.id }, 'Missing client_reference_id on checkout session');
    break;
  }

  const subscription = expandedSession.subscription as Stripe.Subscription;
  if (!subscription) {
    logger.error({ sessionId: session.id }, 'No subscription on checkout session');
    break;
  }

  // Update member subscription status
  await prisma.member.update({
    where: { id: memberId },
    data: {
      subscriptionStatus: 'ACTIVE',
      currentPeriodEnd: new Date(subscription.current_period_end * 1000),
    },
  });

  logger.info(
    { memberId, subscriptionId: subscription.id, currentPeriodEnd: subscription.current_period_end },
    'Checkout completed, subscription activated'
  );
  break;
}
```

Note: Add Stripe import at the top if not already present for the Stripe type import. The stripe client instance is already available.
  </action>
  <verify>
- `npm run build` compiles without errors
- Webhook handler logs show proper case handling for checkout.session.completed
- (Manual test with Stripe CLI: `stripe trigger checkout.session.completed`)
  </verify>
  <done>
- Webhook handler updates member subscriptionStatus to ACTIVE
- Webhook handler stores currentPeriodEnd from subscription
- Non-subscription checkouts are ignored
  </done>
</task>

</tasks>

<verification>
1. Build passes: `npm run build`
2. Schema applied: `npx prisma db push` shows no pending changes
3. Routes exist:
   - POST /auth/signup responds to requests
   - POST /auth/login responds to requests
   - POST /checkout responds (with 401 if no auth)
4. Webhook handler has checkout.session.completed case
</verification>

<success_criteria>
- User can register with email + password and receive JWT tokens
- User can login with email + password
- Authenticated user can create Stripe Checkout session
- Webhook processes checkout.session.completed and activates subscription
- All builds pass, no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-individual-subscription/03-01-SUMMARY.md`
</output>
