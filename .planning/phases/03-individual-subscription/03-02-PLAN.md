---
phase: 03-individual-subscription
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/routes/dashboard.ts
  - src/routes/claim.ts
  - src/lib/role-assignment.ts
  - src/routes/auth.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Authenticated user can view their subscription status"
    - "Paid user can link their Discord account via OAuth"
    - "After claiming, user receives Squire role on Discord"
    - "After claiming, user is redirected to Discord invite"
    - "Discord already linked to another account is blocked"
  artifacts:
    - path: "src/routes/dashboard.ts"
      provides: "GET /dashboard endpoint"
      exports: ["dashboardRouter"]
    - path: "src/routes/claim.ts"
      provides: "Discord claim flow endpoints"
      exports: ["claimRouter"]
    - path: "src/lib/role-assignment.ts"
      provides: "Async role assignment with retry"
      exports: ["assignRoleAsync"]
  key_links:
    - from: "src/routes/claim.ts"
      to: "src/lib/role-assignment.ts"
      via: "import assignRoleAsync"
      pattern: "assignRoleAsync"
    - from: "src/lib/role-assignment.ts"
      to: "src/bot/roles.ts"
      via: "import addRoleToMember"
      pattern: "addRoleToMember"
    - from: "src/routes/claim.ts"
      to: "env.DISCORD_INVITE_URL"
      via: "redirect after claim"
      pattern: "DISCORD_INVITE_URL"
---

<objective>
Implement protected dashboard endpoints and Discord claim flow with role assignment.

Purpose: After paying via Stripe Checkout, users need to see their subscription status and claim their Discord access. This plan enables the full onboarding path from payment to Discord role.

Output:
- GET /dashboard endpoint showing subscription status and claim availability
- GET /claim/discord to initiate Discord OAuth for claim (paid users only)
- GET /claim/callback to complete claim and assign Squire role
- Async role assignment with p-retry for resilience
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-individual-subscription/03-CONTEXT.md
@.planning/phases/03-individual-subscription/03-RESEARCH.md
@src/routes/auth.ts
@src/auth/discord-oauth.ts
@src/bot/roles.ts
@src/config/discord.ts
@src/middleware/session.ts
@src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Dashboard Endpoint</name>
  <files>
    src/routes/dashboard.ts
    src/index.ts
  </files>
  <action>
1. Install p-retry: `npm install p-retry`

2. Create src/routes/dashboard.ts:
   ```typescript
   import { Router, Response } from 'express';
   import { requireAuth, AuthenticatedRequest } from '../middleware/session.js';
   import { prisma } from '../lib/prisma.js';
   import { env } from '../config/env.js';

   export const dashboardRouter = Router();

   /**
    * GET /dashboard
    * Returns current user's subscription status and claim availability
    */
   dashboardRouter.get('/', requireAuth, async (req: AuthenticatedRequest, res: Response): Promise<void> => {
     const member = await prisma.member.findUnique({
       where: { id: req.memberId },
       select: {
         id: true,
         email: true,
         subscriptionStatus: true,
         seatTier: true,
         currentPeriodEnd: true,
         discordId: true,
         discordUsername: true,
         introCompleted: true,
       },
     });

     if (!member) {
       res.status(404).json({ error: 'Member not found' });
       return;
     }

     // Determine claim state
     const canClaim = member.subscriptionStatus === 'ACTIVE' && !member.discordId;
     const hasClaimed = !!member.discordId;

     res.json({
       member: {
         id: member.id,
         email: member.email,
         subscriptionStatus: member.subscriptionStatus,
         seatTier: member.seatTier,
         currentPeriodEnd: member.currentPeriodEnd,
         discordUsername: member.discordUsername,
         introCompleted: member.introCompleted,
       },
       claim: {
         canClaim,
         hasClaimed,
         discordInviteUrl: hasClaimed ? env.DISCORD_INVITE_URL : null,
       },
     });
   });
   ```

3. Mount dashboard router in src/index.ts:
   - Import dashboardRouter from './routes/dashboard.js'
   - Add `app.use('/dashboard', dashboardRouter);` after checkout routes
  </action>
  <verify>
- `npm run build` compiles without errors
- GET /dashboard without auth returns 401
- GET /dashboard with valid token returns member data
  </verify>
  <done>
- Authenticated users can view their subscription status
- Dashboard shows claim availability based on subscription and Discord link status
  </done>
</task>

<task type="auto">
  <name>Task 2: Claim Flow with Role Assignment</name>
  <files>
    src/lib/role-assignment.ts
    src/routes/claim.ts
    src/index.ts
  </files>
  <action>
1. Create src/lib/role-assignment.ts:
   ```typescript
   import pRetry from 'p-retry';
   import { addRoleToMember } from '../bot/roles.js';
   import { logger } from '../index.js';

   /**
    * Assign role asynchronously with exponential backoff retry
    * Fire-and-forget: returns immediately, role assignment happens in background
    */
   export function assignRoleAsync(discordId: string, roleName: string): void {
     pRetry(
       () => addRoleToMember(discordId, roleName),
       {
         retries: 5,
         minTimeout: 1000,
         maxTimeout: 30000,
         onFailedAttempt: (error) => {
           logger.warn(
             { discordId, roleName, attempt: error.attemptNumber, retriesLeft: error.retriesLeft },
             'Role assignment retry'
           );
         },
       }
     ).then((success) => {
       if (success) {
         logger.info({ discordId, roleName }, 'Role assigned successfully (async)');
       }
     }).catch((error) => {
       // After all retries exhausted - admin already alerted by addRoleToMember
       logger.error({ discordId, roleName, error: error.message }, 'Role assignment failed after all retries');
     });
   }
   ```

2. Create src/routes/claim.ts:
   ```typescript
   import { Router, Request, Response } from 'express';
   import { randomUUID } from 'crypto';
   import { parse as parseCookie, serialize as serializeCookie } from 'cookie';
   import { requireAuth, AuthenticatedRequest } from '../middleware/session.js';
   import { generateAuthUrl, exchangeCode, fetchDiscordUser } from '../auth/discord-oauth.js';
   import { prisma } from '../lib/prisma.js';
   import { env } from '../config/env.js';
   import { logger } from '../index.js';
   import { assignRoleAsync } from '../lib/role-assignment.js';
   import { ROLE_CONFIG } from '../config/discord.js';

   export const claimRouter = Router();

   // OAuth state cookie config (same as auth routes)
   const CLAIM_STATE_COOKIE = 'claim_state';
   const CLAIM_STATE_OPTIONS = {
     httpOnly: true,
     secure: env.NODE_ENV === 'production',
     sameSite: 'lax' as const,
     maxAge: 10 * 60, // 10 minutes
   };

   // Store member ID with state for callback
   const CLAIM_MEMBER_COOKIE = 'claim_member';

   /**
    * GET /claim/discord
    * Initiate Discord OAuth for claim flow (requires auth + active subscription)
    */
   claimRouter.get('/discord', requireAuth, async (req: AuthenticatedRequest, res: Response): Promise<void> => {
     const member = await prisma.member.findUnique({
       where: { id: req.memberId },
     });

     // Verify subscription is active
     if (!member || member.subscriptionStatus !== 'ACTIVE') {
       res.status(403).json({ error: 'Active subscription required to claim Discord access' });
       return;
     }

     // Verify not already claimed
     if (member.discordId) {
       res.status(400).json({ error: 'Discord already linked', discordInviteUrl: env.DISCORD_INVITE_URL });
       return;
     }

     // Generate state for CSRF protection
     const state = randomUUID();

     // Set cookies: state and member ID
     res.setHeader('Set-Cookie', [
       serializeCookie(CLAIM_STATE_COOKIE, state, CLAIM_STATE_OPTIONS),
       serializeCookie(CLAIM_MEMBER_COOKIE, req.memberId!, { ...CLAIM_STATE_OPTIONS, httpOnly: true }),
     ]);

     // Redirect to Discord OAuth
     const authUrl = generateAuthUrl(state);
     res.redirect(authUrl);
   });

   /**
    * GET /claim/callback
    * Handle Discord OAuth callback for claim flow
    */
   claimRouter.get('/callback', async (req: Request, res: Response): Promise<void> => {
     const { code, state } = req.query;

     // Parse cookies
     const cookieHeader = req.headers.cookie ?? '';
     const cookies = parseCookie(cookieHeader);
     const storedState = cookies[CLAIM_STATE_COOKIE];
     const memberId = cookies[CLAIM_MEMBER_COOKIE];

     // Clear claim cookies
     res.setHeader('Set-Cookie', [
       serializeCookie(CLAIM_STATE_COOKIE, '', { ...CLAIM_STATE_OPTIONS, maxAge: 0 }),
       serializeCookie(CLAIM_MEMBER_COOKIE, '', { ...CLAIM_STATE_OPTIONS, maxAge: 0 }),
     ]);

     // Validate state (CSRF protection)
     if (!state || state !== storedState) {
       res.redirect('/dashboard?claim=error&reason=invalid_state');
       return;
     }

     // Validate member ID from cookie
     if (!memberId) {
       res.redirect('/dashboard?claim=error&reason=session_expired');
       return;
     }

     // Validate code
     if (!code || typeof code !== 'string') {
       res.redirect('/dashboard?claim=error&reason=no_code');
       return;
     }

     try {
       // Exchange code for tokens
       const tokens = await exchangeCode(code);

       // Fetch Discord user info
       const discordUser = await fetchDiscordUser(tokens.access_token);

       // Check if Discord ID already linked to ANOTHER member
       const existingMember = await prisma.member.findFirst({
         where: {
           discordId: discordUser.id,
           id: { not: memberId },
         },
       });

       if (existingMember) {
         logger.warn(
           { memberId, discordId: discordUser.id, existingMemberId: existingMember.id },
           'Discord already linked to another account'
         );
         res.redirect('/dashboard?claim=error&reason=discord_already_linked');
         return;
       }

       // Link Discord to member
       await prisma.member.update({
         where: { id: memberId },
         data: {
           discordId: discordUser.id,
           discordUsername: discordUser.global_name ?? discordUser.username,
           discordAvatar: discordUser.avatar,
         },
       });

       // Assign Squire role asynchronously (fire-and-forget)
       assignRoleAsync(discordUser.id, ROLE_CONFIG.SQUIRE.name);

       logger.info(
         { memberId, discordId: discordUser.id, discordUsername: discordUser.username },
         'Discord claim successful, redirecting to invite'
       );

       // Redirect to Discord invite
       res.redirect(env.DISCORD_INVITE_URL);
     } catch (error) {
       logger.error({ error, memberId }, 'Discord claim callback failed');
       res.redirect('/dashboard?claim=error&reason=oauth_failed');
     }
   });
   ```

3. Mount claim router in src/index.ts:
   - Import claimRouter from './routes/claim.js'
   - Add `app.use('/claim', claimRouter);` after dashboard routes
  </action>
  <verify>
- `npm run build` compiles without errors
- GET /claim/discord without auth returns 401
- GET /claim/discord with auth but no subscription returns 403
- Claim flow uses Discord OAuth and assigns Squire role
  </verify>
  <done>
- Paid users can initiate Discord OAuth claim
- Discord is linked to member on successful callback
- Squire role is assigned asynchronously with retry
- User is redirected to Discord invite URL after claim
  </done>
</task>

</tasks>

<verification>
1. Build passes: `npm run build`
2. Dashboard endpoint works:
   - GET /dashboard returns member data with claim status
3. Claim flow exists:
   - GET /claim/discord redirects to Discord OAuth
   - GET /claim/callback handles callback
4. Role assignment uses async retry pattern
</verification>

<success_criteria>
- Authenticated users can view subscription status via GET /dashboard
- Paid users (ACTIVE subscription) can access claim flow
- Discord linking works via OAuth callback
- Squire role is assigned with retry resilience
- User redirected to Discord invite after successful claim
- Duplicate Discord linking is blocked
</success_criteria>

<output>
After completion, create `.planning/phases/03-individual-subscription/03-02-SUMMARY.md`
</output>
