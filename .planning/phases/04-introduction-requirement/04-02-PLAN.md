---
phase: 04-introduction-requirement
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/bot/events/introduction.ts
  - src/lib/role-assignment.ts
autonomous: true

must_haves:
  truths:
    - "User posting valid intro (100+ chars) is promoted from Squire to Member or Owner"
    - "User receives party emoji reaction on valid intro"
    - "User receives medieval-themed welcome DM after promotion"
    - "User posting short intro receives guidance DM (max once per 24h)"
    - "Individual members get Knight role, company owners get Lord role"
  artifacts:
    - path: "src/bot/events/introduction.ts"
      provides: "Complete introduction processing with validation and promotion"
      contains: "promoteAfterIntro"
    - path: "src/lib/role-assignment.ts"
      provides: "Role swap function for promotion"
      exports: ["swapRoleAsync"]
  key_links:
    - from: "src/bot/events/introduction.ts"
      to: "prisma.member"
      via: "database lookup and update"
      pattern: "prisma\\.member\\.(findUnique|update)"
    - from: "src/bot/events/introduction.ts"
      to: "src/lib/role-assignment.ts"
      via: "swapRoleAsync call"
      pattern: "swapRoleAsync"
    - from: "src/lib/role-assignment.ts"
      to: "src/bot/roles.ts"
      via: "addRoleToMember and removeRoleFromMember"
      pattern: "(addRoleToMember|removeRoleFromMember)"
---

<objective>
Implement introduction validation and role promotion logic.

Purpose: Complete the introduction workflow by promoting users from Squire to Member/Owner after they post a valid introduction, with appropriate feedback (reactions, DMs).

Output:
- Full processIntroduction implementation with validation
- Role swap function with retry logic
- Welcome DM with medieval theme
- Rate-limited guidance DM for short intros
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-introduction-requirement/04-CONTEXT.md
@.planning/phases/04-introduction-requirement/04-RESEARCH.md
@src/bot/events/introduction.ts
@src/lib/role-assignment.ts
@src/bot/roles.ts
@src/config/discord.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Role Swap Function</name>
  <files>src/lib/role-assignment.ts</files>
  <action>
Update src/lib/role-assignment.ts to add swapRoleAsync function:

1. Import removeRoleFromMember from '../bot/roles.js' (add to existing import)

2. Add new exported function swapRoleAsync(discordId: string, removeRole: string, addRole: string): void that:
   - Uses pRetry with same config as assignRoleAsync (retries: 5, minTimeout: 1000, maxTimeout: 30000)
   - Inside the retry: first call removeRoleFromMember, then addRoleToMember
   - If removeRoleFromMember returns false, throw new Error to trigger retry
   - If addRoleToMember returns false, throw new Error to trigger retry
   - Log on success: "Role swapped successfully (async)" with discordId, removeRole, addRole
   - Catch block: Log error with "Role swap failed after all retries"

This provides atomic role swap with retry - remove old role, add new role.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>swapRoleAsync function added to role-assignment.ts, handles remove + add with retry</done>
</task>

<task type="auto">
  <name>Task 2: Implement Introduction Processing</name>
  <files>src/bot/events/introduction.ts</files>
  <action>
Complete the processIntroduction function in src/bot/events/introduction.ts:

1. Add imports:
   - Import { User, GuildMember } from 'discord.js' (add to existing)
   - Import { ROLE_CONFIG } from '../../config/discord.js'
   - Import { swapRoleAsync } from '../../lib/role-assignment.js'
   - Import { SeatTier } from '@prisma/client'

2. Implement processIntroduction(message: Message): Promise<void>:
   ```
   // Get text length (images don't count per CONTEXT.md)
   const textLength = message.content.length;

   // Lookup member by Discord ID
   const member = await prisma.member.findUnique({
     where: { discordId: message.author.id },
   });

   // Not in our system or already introduced - ignore
   if (!member || member.introCompleted) return;

   // Check if user has Squire role (paid but unintroduced)
   const guildMember = message.member;
   if (!guildMember) return;

   const hasSquireRole = guildMember.roles.cache.some(
     r => r.name === ROLE_CONFIG.SQUIRE.name
   );
   if (!hasSquireRole) return;

   // Validate length
   if (textLength < MIN_INTRO_LENGTH) {
     await sendGuidanceDM(member, message.author);
     return;
   }

   // Valid intro - react and promote
   try {
     await message.react('ðŸŽ‰');
   } catch (err) {
     logger.debug({ error: err }, 'Could not add reaction');
   }

   await promoteAfterIntro(member, guildMember, message.id);
   ```

3. Add sendGuidanceDM(member: Member, user: User): Promise<void>:
   - Check rate limit: if member.lastGuidanceDmAt and it's within 24 hours, return early with debug log
   - Send DM with medieval-themed guidance text:
     ```
     Greetings, traveler!

     The Revenue Council requires a proper introduction before you may enter our halls.

     We wish to know what draws you to our guild - your background, your interests, and what you hope to find here.

     Your introduction must be at least 100 characters. Take your time to craft something meaningful!
     ```
   - Update member.lastGuidanceDmAt to new Date()
   - Wrap in try/catch - user may have DMs disabled, log debug and don't throw

4. Add promoteAfterIntro(member: Member, guildMember: GuildMember, messageId: string): Promise<void>:
   - Determine target role based on seatTier:
     - If member.seatTier === 'OWNER' -> ROLE_CONFIG.LORD.name
     - Otherwise -> ROLE_CONFIG.KNIGHT.name (handles INDIVIDUAL and TEAM_MEMBER)
   - Call swapRoleAsync(guildMember.id, ROLE_CONFIG.SQUIRE.name, targetRole)
   - Update database:
     ```
     await prisma.member.update({
       where: { id: member.id },
       data: {
         introCompleted: true,
         introCompletedAt: new Date(),
         introMessageId: messageId,
       },
     });
     ```
   - Call sendWelcomeDM(guildMember.user, targetRole)
   - Log info: "Member promoted after introduction" with memberId, discordId, targetRole

5. Add sendWelcomeDM(user: User, roleName: string): Promise<void>:
   - Determine title: 'Lord' if roleName === ROLE_CONFIG.LORD.name, else 'Knight'
   - Send DM with medieval-themed welcome:
     ```
     Hail, {title} {user.displayName}!

     You have been formally admitted to The Revenue Council guild. The halls of knowledge and fellowship now open before you.

     Please review our community guidelines: {env.APP_URL}/guidelines

     Welcome to the Council!
     ```
   - Wrap in try/catch - user may have DMs disabled, log debug and don't throw

Note: Import Member type with `import type { Member } from '@prisma/client'`
  </action>
  <verify>
- TypeScript compiles: `npx tsc --noEmit`
- Manual test: Post 100+ char message in #introductions as Squire, verify promotion to Knight/Lord
  </verify>
  <done>
- processIntroduction validates length and promotes user
- Party emoji reaction added on valid intro
- Welcome DM sent with medieval theme
- Guidance DM sent for short intros (rate-limited to once per 24h)
- Squire swapped to Knight (individual/team) or Lord (owner)
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. TypeScript compiles: `npx tsc --noEmit`
2. Manual test flow:
   a. As a Squire (paid, unintroduced member), post short message (<100 chars) in #introductions
   b. Verify you receive guidance DM (only once per 24h)
   c. Post valid intro (100+ chars)
   d. Verify party emoji reaction appears
   e. Verify Squire role removed, Knight role added (or Lord if seatTier is OWNER)
   f. Verify welcome DM received
   g. Verify database updated: introCompleted=true, introCompletedAt set, introMessageId set
</verification>

<success_criteria>
- Valid intro (100+ chars) triggers promotion from Squire to Knight/Lord
- Party emoji reaction added to valid intro message
- Welcome DM sent after promotion with medieval theme
- Short intro triggers guidance DM (rate-limited once per 24h)
- Database tracks intro completion state
- Role swap uses p-retry for reliability
</success_criteria>

<output>
After completion, create `.planning/phases/04-introduction-requirement/04-02-SUMMARY.md`
</output>
