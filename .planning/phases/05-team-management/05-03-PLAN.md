---
phase: 05-team-management
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/lib/invite-tokens.ts
  - src/routes/team-invites.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Company admin can generate invite tokens for owner or team tier"
    - "Generated tokens are cryptographically secure (32 bytes)"
    - "Invite tokens are multi-use and never expire"
    - "Available seat count is checked before generating invite"
  artifacts:
    - path: "src/lib/invite-tokens.ts"
      provides: "Secure token generation and validation utilities"
      exports: ["generateInviteToken", "validateToken"]
    - path: "src/routes/team-invites.ts"
      provides: "Invite management API routes"
      exports: ["teamInvitesRouter"]
  key_links:
    - from: "src/routes/team-invites.ts"
      to: "src/lib/invite-tokens.ts"
      via: "import generateInviteToken"
      pattern: "import.*generateInviteToken"
    - from: "src/routes/team-invites.ts"
      to: "prisma.pendingInvite.create"
      via: "Creating invite record in database"
      pattern: "prisma\\.pendingInvite\\.create"
---

<objective>
Implement invite token generation for team seat allocation.

Purpose: Enable company owners to create secure, shareable invite links that teammates can use to claim available seats.

Output: Token generation utility using crypto.randomBytes, API endpoint for creating invites, endpoint for listing pending invites.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-team-management/05-CONTEXT.md
@.planning/phases/05-team-management/05-RESEARCH.md
@.planning/phases/05-team-management/05-01-SUMMARY.md
@prisma/schema.prisma
@src/routes/claim.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Invite token utilities</name>
  <files>src/lib/invite-tokens.ts</files>
  <action>
Create src/lib/invite-tokens.ts:

1. Import crypto from Node.js built-in:
   ```typescript
   import { randomBytes, timingSafeEqual } from 'crypto';
   ```

2. generateInviteToken function:
   ```typescript
   /**
    * Generate a cryptographically secure, URL-safe invite token
    * Uses 32 bytes (256 bits) of entropy, encoded as base64url
    * Results in 43-character token
    */
   export function generateInviteToken(): string {
     return randomBytes(32).toString('base64url');
   }
   ```

3. validateToken function (timing-safe comparison):
   ```typescript
   /**
    * Timing-safe comparison of invite tokens
    * Prevents timing attacks that could leak token information
    */
   export function validateToken(provided: string, stored: string): boolean {
     const a = Buffer.from(provided, 'utf8');
     const b = Buffer.from(stored, 'utf8');
     if (a.length !== b.length) return false;
     return timingSafeEqual(a, b);
   }
   ```

4. Export both functions.

Why crypto.randomBytes over uuid/nanoid:
- Built-in, no external dependency
- CSPRNG (cryptographically secure pseudo-random number generator)
- Full control over entropy size
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit` passes.
Token generation works: Can import and call generateInviteToken().
  </verify>
  <done>
Secure token generation utility exists with timing-safe validation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Invite management API routes</name>
  <files>
    src/routes/team-invites.ts
    src/index.ts
  </files>
  <action>
Create src/routes/team-invites.ts:

1. Create new Router (teamInvitesRouter)

2. POST /team/invites endpoint (create invite):
   - Requires authentication (requireAuth middleware)
   - Request body: `{ seatTier: 'OWNER' | 'TEAM_MEMBER' }`
   - Validate with zod: seatTier must be one of the enum values
   - Look up member, verify teamId exists
   - Verify member.seatTier === 'OWNER' (only owners can create invites)

3. Check seat availability before creating invite:
   ```typescript
   const team = await prisma.team.findUnique({
     where: { id: member.teamId },
     include: {
       members: { where: { seatTier: seatTier } },
     },
   });

   const maxSeats = seatTier === 'OWNER' ? team.ownerSeatCount : team.teamSeatCount;
   const claimedSeats = team.members.length;

   if (claimedSeats >= maxSeats) {
     return res.status(400).json({
       error: `No ${seatTier.toLowerCase()} seats available`,
       claimed: claimedSeats,
       total: maxSeats,
     });
   }
   ```

4. Create invite with generated token:
   ```typescript
   const token = generateInviteToken();

   const invite = await prisma.pendingInvite.create({
     data: {
       teamId: member.teamId,
       seatTier: seatTier,
       token: token,
       createdBy: member.id,
     },
   });
   ```

5. Return invite with full URL:
   ```typescript
   res.status(201).json({
     invite: {
       id: invite.id,
       seatTier: invite.seatTier,
       token: invite.token,
       inviteUrl: `${env.APP_URL}/team/claim?token=${invite.token}`,
       createdAt: invite.createdAt,
     },
   });
   ```

6. GET /team/invites endpoint (list invites):
   - Requires authentication
   - Verify member is team owner
   - Return all pending invites for the team:
   ```typescript
   const invites = await prisma.pendingInvite.findMany({
     where: { teamId: member.teamId },
     orderBy: { createdAt: 'desc' },
   });

   res.json({
     invites: invites.map(i => ({
       id: i.id,
       seatTier: i.seatTier,
       inviteUrl: `${env.APP_URL}/team/claim?token=${i.token}`,
       createdAt: i.createdAt,
       acceptedAt: i.acceptedAt,
       acceptedBy: i.acceptedBy,
     })),
   });
   ```

7. DELETE /team/invites/:inviteId endpoint (revoke invite):
   - Requires authentication
   - Verify member is team owner
   - Verify invite belongs to member's team
   - Delete the invite:
   ```typescript
   await prisma.pendingInvite.delete({
     where: { id: inviteId },
   });
   res.status(204).send();
   ```

Register in src/index.ts:
- Import teamInvitesRouter
- Mount routes (if not already mounted under /team from Plan 02, add these to that router or mount separately)
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit` passes.
Routes are registered: `grep -r "teamInvitesRouter" src/index.ts` or routes available via team router.
  </verify>
  <done>
POST /team/invites creates invite with secure token.
GET /team/invites lists all team invites.
DELETE /team/invites/:id revokes an invite.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit` passes
2. Server starts: `npm run dev` starts without errors
3. Token generation: generateInviteToken() returns 43-char base64url string
4. Create invite: POST /team/invites with { seatTier: 'TEAM_MEMBER' } returns invite URL
5. List invites: GET /team/invites returns array of invites
6. Authorization: Non-owners get 403 on all endpoints
</verification>

<success_criteria>
- Invite tokens are 32 bytes of cryptographically secure randomness
- Tokens are URL-safe (base64url encoding)
- Only team owners can create invites
- Seat availability is checked before creating invite
- Invites include full claim URL
- Invites can be listed and revoked
- Timing-safe token validation utility exists for claim flow
</success_criteria>

<output>
After completion, create `.planning/phases/05-team-management/05-03-SUMMARY.md`
</output>
