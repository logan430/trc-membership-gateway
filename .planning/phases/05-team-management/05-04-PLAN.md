---
phase: 05-team-management
plan: 04
type: execute
wave: 3
depends_on: ["05-03"]
files_modified:
  - src/routes/team-claim.ts
  - src/index.ts
  - public/team-claim.html
autonomous: true

must_haves:
  truths:
    - "Teammate can claim seat via invite token link"
    - "Claim flow uses Discord OAuth only (no email/password)"
    - "Claimed seat triggers Squire role assignment"
    - "Teammate with owner seat gets Lord role after introduction"
    - "Teammate with team seat gets Knight role after introduction"
    - "Individual subscribers blocked from claiming with clear message"
  artifacts:
    - path: "src/routes/team-claim.ts"
      provides: "Team invite claim flow with Discord OAuth"
      exports: ["teamClaimRouter"]
    - path: "public/team-claim.html"
      provides: "Team claim landing page"
      contains: "Claim Your Seat"
  key_links:
    - from: "src/routes/team-claim.ts"
      to: "src/auth/discord-oauth.ts"
      via: "OAuth flow for identity verification"
      pattern: "import.*generateAuthUrl.*exchangeCode"
    - from: "src/routes/team-claim.ts"
      to: "prisma.member.create"
      via: "Creating new member on claim"
      pattern: "prisma\\.member\\.(create|upsert)"
    - from: "src/routes/team-claim.ts"
      to: "src/lib/role-assignment.ts"
      via: "Assigning Squire role on successful claim"
      pattern: "assignRoleAsync"
---

<objective>
Implement the invite claim flow for teammates to join a company team via Discord OAuth.

Purpose: Enable teammates to claim their seat using only Discord authentication, linking them to the team with the appropriate seat tier.

Output: Claim landing page showing invite details, Discord OAuth flow for identity verification, member creation with team linkage and Squire role assignment.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-team-management/05-CONTEXT.md
@.planning/phases/05-team-management/05-RESEARCH.md
@.planning/phases/05-team-management/05-03-SUMMARY.md
@src/routes/claim.ts
@src/auth/discord-oauth.ts
@src/lib/role-assignment.ts
@src/bot/events/introduction.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Team claim routes</name>
  <files>
    src/routes/team-claim.ts
    src/index.ts
  </files>
  <action>
Create src/routes/team-claim.ts:

1. Create new Router (teamClaimRouter)

2. GET /team/claim endpoint (initiate claim):
   - Extract token from query params: `req.query.token`
   - If no token, redirect to /?error=missing_token

3. Validate invite token:
   ```typescript
   const invite = await prisma.pendingInvite.findUnique({
     where: { token: token as string },
     include: {
       team: {
         include: {
           members: { where: { seatTier: invite.seatTier } },
         },
       },
     },
   });

   if (!invite) {
     return res.redirect('/?error=invalid_token');
   }
   ```

4. Check seat availability (atomic transaction in callback for race condition safety):
   ```typescript
   const maxSeats = invite.seatTier === 'OWNER'
     ? invite.team.ownerSeatCount
     : invite.team.teamSeatCount;
   const claimedSeats = invite.team.members.length;

   if (claimedSeats >= maxSeats) {
     return res.redirect('/?error=no_seats_available');
   }
   ```

5. Store token and seatTier in cookies, generate OAuth state:
   ```typescript
   const state = randomUUID();
   res.setHeader('Set-Cookie', [
     serializeCookie('team_claim_state', state, COOKIE_OPTIONS),
     serializeCookie('team_claim_token', token as string, COOKIE_OPTIONS),
   ]);
   ```

6. Redirect to Discord OAuth:
   ```typescript
   const authUrl = generateAuthUrl(state);
   res.redirect(authUrl);
   ```

7. GET /team/claim/callback endpoint (OAuth callback):
   - Parse cookies to get stored state and token
   - Clear claim cookies immediately
   - Validate OAuth state matches
   - Exchange code for Discord access token
   - Fetch Discord user info

8. Check for existing individual subscription (block with clear message):
   ```typescript
   const existingMember = await prisma.member.findUnique({
     where: { discordId: discordUser.id },
   });

   if (existingMember?.subscriptionStatus === 'ACTIVE' && !existingMember.teamId) {
     // Individual subscriber trying to claim team seat
     return res.redirect('/?error=already_subscribed&message=You already have owner access through your individual subscription');
   }
   ```

9. Check if Discord ID already linked to another team member:
   ```typescript
   if (existingMember?.teamId && existingMember.teamId !== invite.teamId) {
     return res.redirect('/?error=already_in_team');
   }
   ```

10. Atomic seat claim with transaction (prevents race condition):
    ```typescript
    const result = await prisma.$transaction(async (tx) => {
      // Re-fetch team with lock to prevent race condition
      const team = await tx.team.findUnique({
        where: { id: invite.teamId },
        include: { members: { where: { seatTier: invite.seatTier } } },
      });

      const maxSeats = invite.seatTier === 'OWNER'
        ? team.ownerSeatCount
        : team.teamSeatCount;

      if (team.members.length >= maxSeats) {
        throw new Error('NO_SEATS_AVAILABLE');
      }

      // Create or update member
      const member = await tx.member.upsert({
        where: { discordId: discordUser.id },
        create: {
          discordId: discordUser.id,
          discordUsername: discordUser.global_name ?? discordUser.username,
          discordAvatar: discordUser.avatar,
          teamId: invite.teamId,
          seatTier: invite.seatTier,
          subscriptionStatus: 'ACTIVE',
        },
        update: {
          discordUsername: discordUser.global_name ?? discordUser.username,
          discordAvatar: discordUser.avatar,
          teamId: invite.teamId,
          seatTier: invite.seatTier,
          subscriptionStatus: 'ACTIVE',
        },
      });

      // Mark invite as used (but keep for tracking)
      await tx.pendingInvite.update({
        where: { id: invite.id },
        data: {
          acceptedAt: new Date(),
          acceptedBy: member.id,
        },
      });

      return member;
    });
    ```

11. On successful claim, assign Squire role and redirect to Discord invite:
    ```typescript
    assignRoleAsync(discordUser.id, ROLE_CONFIG.SQUIRE.name);

    logger.info(
      { memberId: result.id, teamId: invite.teamId, seatTier: invite.seatTier },
      'Team seat claimed successfully'
    );

    res.redirect(env.DISCORD_INVITE_URL);
    ```

12. Handle transaction errors:
    ```typescript
    } catch (error) {
      if (error.message === 'NO_SEATS_AVAILABLE') {
        return res.redirect('/?error=no_seats_available');
      }
      logger.error({ error }, 'Team claim failed');
      return res.redirect('/?error=claim_failed');
    }
    ```

Register in src/index.ts:
- Import teamClaimRouter
- Mount at appropriate path (may combine with other team routes)
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit` passes.
Routes registered: Team claim routes accessible.
  </verify>
  <done>
Team claim flow validates token, checks seat availability, uses Discord OAuth, creates member with team linkage.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify introduction handler supports team seat tiers</name>
  <files>src/bot/events/introduction.ts</files>
  <action>
Review and update src/bot/events/introduction.ts to ensure it correctly promotes team members:

1. Verify promoteAfterIntro function checks seatTier:
   - If seatTier === 'OWNER', swap Squire to Lord (existing logic)
   - If seatTier === 'TEAM_MEMBER', swap Squire to Knight

2. The existing logic should already handle this from Phase 4, but verify:
   ```typescript
   // Expected logic in promoteAfterIntro:
   const targetRole = member.seatTier === 'OWNER' || member.seatTier === 'INDIVIDUAL'
     ? ROLE_CONFIG.LORD.name
     : ROLE_CONFIG.KNIGHT.name;

   swapRoleAsync(discordId, ROLE_CONFIG.SQUIRE.name, targetRole);
   ```

3. If INDIVIDUAL and OWNER both get Lord role, and TEAM_MEMBER gets Knight role, verify this mapping is correct per CONTEXT.md:
   - "Individual subscriptions are owner-level with higher permissions"
   - Hierarchy: Individual = Owner > Team

4. Update if needed to ensure TEAM_MEMBER specifically maps to Knight (Member role in Discord terms).

5. Log the seatTier in promotion logs for debugging.

Note: This task may require minimal changes if Phase 4 already handles this correctly. Read the file first and only modify if the TEAM_MEMBER -> Knight mapping is missing.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit` passes.
Introduction handler has explicit TEAM_MEMBER handling.
  </verify>
  <done>
Introduction detection correctly promotes:
- INDIVIDUAL -> Lord (full access)
- OWNER -> Lord (full access)
- TEAM_MEMBER -> Knight (member access)
  </done>
</task>

<task type="auto">
  <name>Task 3: Team claim landing page</name>
  <files>public/team-claim.html</files>
  <action>
Create public/team-claim.html with medieval theme:

1. Page structure:
   - Title: "Claim Your Seat - The Revenue Council"
   - Welcome message explaining the claim process
   - Team name and seat type display
   - "Claim with Discord" button

2. On page load:
   - Extract token from URL query params
   - Fetch invite details: GET /team/claim/info?token=xxx (add this endpoint to team-claim.ts)
   - Display team name and seat tier (Owner Seat or Team Seat)
   - If invalid token, show error and link to Gatekeeper

3. Add GET /team/claim/info endpoint to team-claim.ts:
   ```typescript
   teamClaimRouter.get('/team/claim/info', async (req, res) => {
     const { token } = req.query;
     if (!token) {
       return res.status(400).json({ error: 'Missing token' });
     }

     const invite = await prisma.pendingInvite.findUnique({
       where: { token: token as string },
       include: { team: true },
     });

     if (!invite) {
       return res.status(404).json({ error: 'Invalid invite' });
     }

     // Check seat availability
     const claimedCount = await prisma.member.count({
       where: { teamId: invite.teamId, seatTier: invite.seatTier },
     });
     const maxSeats = invite.seatTier === 'OWNER'
       ? invite.team.ownerSeatCount
       : invite.team.teamSeatCount;

     res.json({
       teamName: invite.team.name,
       seatTier: invite.seatTier,
       seatsAvailable: maxSeats - claimedCount > 0,
     });
   });
   ```

4. Page content when valid:
   ```html
   <h1>Join The Revenue Council</h1>
   <p>You've been invited to join <strong>{teamName}</strong></p>
   <p>Seat type: <strong>{Owner Seat | Team Seat}</strong></p>
   <a href="/team/claim?token={token}" class="btn-discord">
     Claim with Discord
   </a>
   ```

5. Error states:
   - Invalid token: "This invite link is invalid or has been revoked."
   - No seats available: "Sorry, all seats of this type have been claimed."
   - Link to Gatekeeper in error states

6. Styling consistent with medieval theme from other pages.
  </action>
  <verify>
File exists: `ls public/team-claim.html`
Page displays invite info when given valid token.
  </verify>
  <done>
Team claim landing page shows invite details and provides Discord OAuth claim button.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit` passes
2. Server starts: `npm run dev` starts without errors
3. Claim info endpoint works: GET /team/claim/info?token=xxx returns team name and seat tier
4. Claim flow redirects to Discord OAuth
5. Successful claim creates member with teamId and seatTier
6. Squire role assigned on successful claim
7. Individual subscriber blocked with clear message
8. Race condition protected via transaction
</verification>

<success_criteria>
- Invite token validated and seat availability checked
- Discord OAuth used for identity (no email/password required)
- Atomic transaction prevents seat over-claiming
- Member created with correct teamId and seatTier
- Squire role assigned immediately after claim
- Introduction handler promotes TEAM_MEMBER to Knight, OWNER to Lord
- Individual subscribers blocked with helpful message
- Claim landing page shows invite details before OAuth redirect
</success_criteria>

<output>
After completion, create `.planning/phases/05-team-management/05-04-SUMMARY.md`
</output>
