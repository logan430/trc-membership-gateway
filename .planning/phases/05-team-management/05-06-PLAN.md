---
phase: 05-team-management
plan: 06
type: execute
wave: 4
depends_on: ["05-04"]
files_modified:
  - src/routes/team-dashboard.ts
  - src/webhooks/stripe.ts
  - public/team-dashboard.html
autonomous: true

must_haves:
  truths:
    - "Company admin can add more owner seats mid-subscription"
    - "Company admin can add more team seats mid-subscription"
    - "Seat additions are immediately charged (prorated)"
    - "Database seat counts sync with Stripe subscription"
  artifacts:
    - path: "src/routes/team-dashboard.ts"
      provides: "Seat addition endpoint"
      contains: "POST /team/seats"
    - path: "src/webhooks/stripe.ts"
      provides: "Subscription updated handler for seat count sync"
      contains: "customer.subscription.updated"
  key_links:
    - from: "src/routes/team-dashboard.ts"
      to: "stripe.subscriptionItems.update"
      via: "Updating subscription item quantity"
      pattern: "stripe\\.subscriptionItems\\.update"
    - from: "src/webhooks/stripe.ts"
      to: "prisma.team.update"
      via: "Syncing seat counts from Stripe"
      pattern: "prisma\\.team\\.update.*ownerSeatCount"
---

<objective>
Implement mid-subscription seat additions allowing company admins to purchase additional seats.

Purpose: Enable companies to grow their team without waiting for the next billing cycle, with immediate prorated charges.

Output: Seat addition API endpoint, Stripe subscription item quantity update, webhook handler to sync seat counts.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-team-management/05-CONTEXT.md
@.planning/phases/05-team-management/05-RESEARCH.md
@.planning/phases/05-team-management/05-02-SUMMARY.md
@src/routes/team-dashboard.ts
@src/webhooks/stripe.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Seat addition API endpoint</name>
  <files>src/routes/team-dashboard.ts</files>
  <action>
Add POST /team/seats endpoint to src/routes/team-dashboard.ts:

1. Request body schema:
   ```typescript
   const addSeatsSchema = z.object({
     seatType: z.enum(['owner', 'team']),
     quantity: z.number().int().min(1).max(50),
   });
   ```

2. POST /team/seats endpoint:
   ```typescript
   teamDashboardRouter.post('/team/seats', requireAuth, async (req: AuthenticatedRequest, res: Response): Promise<void> => {
     const validation = addSeatsSchema.safeParse(req.body);
     if (!validation.success) {
       res.status(400).json({ error: 'Invalid request', details: validation.error.issues });
       return;
     }

     const { seatType, quantity } = validation.data;

     // Get requester and verify ownership
     const requester = await prisma.member.findUnique({
       where: { id: req.memberId },
       include: { team: true },
     });

     if (!requester?.team) {
       res.status(404).json({ error: 'Not part of a team' });
       return;
     }

     if (requester.seatTier !== 'OWNER') {
       res.status(403).json({ error: 'Only team owners can add seats' });
       return;
     }

     if (!requester.team.stripeSubscriptionId) {
       res.status(400).json({ error: 'No active subscription' });
       return;
     }

     // Determine which price ID to update
     const priceId = seatType === 'owner'
       ? env.STRIPE_OWNER_SEAT_PRICE_ID
       : env.STRIPE_TEAM_SEAT_PRICE_ID;

     if (!priceId) {
       res.status(500).json({ error: 'Seat pricing not configured' });
       return;
     }

     try {
       // Retrieve subscription to find the subscription item
       const subscription = await stripe.subscriptions.retrieve(
         requester.team.stripeSubscriptionId
       );

       const item = subscription.items.data.find(i => i.price.id === priceId);

       if (!item) {
         res.status(400).json({ error: `No ${seatType} seat item on subscription` });
         return;
       }

       // Update quantity with immediate proration
       // Per RESEARCH.md: proration_behavior: 'always_invoice' charges immediately
       const updatedItem = await stripe.subscriptionItems.update(item.id, {
         quantity: item.quantity + quantity,
         proration_behavior: 'always_invoice',
       });

       // Note: Database update happens via webhook (customer.subscription.updated)
       // This ensures Stripe is source of truth

       logger.info(
         {
           teamId: requester.team.id,
           seatType,
           previousQuantity: item.quantity,
           newQuantity: updatedItem.quantity,
           addedQuantity: quantity,
         },
         'Seats added mid-subscription'
       );

       res.json({
         success: true,
         seatType,
         previousQuantity: item.quantity,
         newQuantity: updatedItem.quantity,
         addedQuantity: quantity,
       });
     } catch (error) {
       logger.error({ error, teamId: requester.team.id }, 'Failed to add seats');
       res.status(500).json({ error: 'Failed to add seats. Please try again.' });
     }
   });
   ```

3. Import Stripe and zod at top if not already:
   ```typescript
   import Stripe from 'stripe';
   import { z } from 'zod';

   const stripe = new Stripe(env.STRIPE_SECRET_KEY);
   ```
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit` passes.
Endpoint exists: `grep "POST.*team/seats" src/routes/team-dashboard.ts` finds match.
  </verify>
  <done>
POST /team/seats updates Stripe subscription item quantity with immediate proration.
  </done>
</task>

<task type="auto">
  <name>Task 2: Webhook handler for subscription updates</name>
  <files>src/webhooks/stripe.ts</files>
  <action>
Update customer.subscription.updated handler in src/webhooks/stripe.ts:

1. Replace the placeholder handler with actual logic:
   ```typescript
   case 'customer.subscription.updated': {
     const subscription = event.data.object as Stripe.Subscription;

     // Find team by subscription ID
     const team = await prisma.team.findUnique({
       where: { stripeSubscriptionId: subscription.id },
     });

     if (!team) {
       // Might be an individual subscription, check member
       const member = await prisma.member.findFirst({
         where: { stripeCustomerId: subscription.customer as string },
       });

       if (member && !member.teamId) {
         // Individual subscription update - handle period end sync
         const firstItem = subscription.items?.data?.[0];
         const currentPeriodEnd = firstItem?.current_period_end
           ? new Date(firstItem.current_period_end * 1000)
           : null;

         await prisma.member.update({
           where: { id: member.id },
           data: {
             subscriptionStatus: mapStripeStatus(subscription.status),
             currentPeriodEnd,
           },
         });

         logger.info({ memberId: member.id }, 'Individual subscription updated');
       }
       break;
     }

     // Team subscription - sync seat counts from Stripe
     const ownerItem = subscription.items.data.find(
       i => i.price.id === env.STRIPE_OWNER_SEAT_PRICE_ID
     );
     const teamItem = subscription.items.data.find(
       i => i.price.id === env.STRIPE_TEAM_SEAT_PRICE_ID
     );

     await prisma.team.update({
       where: { id: team.id },
       data: {
         subscriptionStatus: mapStripeStatus(subscription.status),
         ownerSeatCount: ownerItem?.quantity ?? team.ownerSeatCount,
         teamSeatCount: teamItem?.quantity ?? team.teamSeatCount,
       },
     });

     logger.info(
       {
         teamId: team.id,
         ownerSeats: ownerItem?.quantity,
         teamSeats: teamItem?.quantity,
         status: subscription.status,
       },
       'Team subscription updated'
     );
     break;
   }
   ```

2. Add helper function to map Stripe status to our enum:
   ```typescript
   function mapStripeStatus(stripeStatus: string): 'NONE' | 'TRIALING' | 'ACTIVE' | 'PAST_DUE' | 'CANCELLED' {
     switch (stripeStatus) {
       case 'active':
         return 'ACTIVE';
       case 'trialing':
         return 'TRIALING';
       case 'past_due':
         return 'PAST_DUE';
       case 'canceled':
       case 'unpaid':
       case 'incomplete_expired':
         return 'CANCELLED';
       default:
         return 'NONE';
     }
   }
   ```

3. Also handle subscription deletion for teams:
   Update the existing customer.subscription.deleted handler to check for team:
   ```typescript
   case 'customer.subscription.deleted': {
     const subscription = event.data.object as Stripe.Subscription;

     // Check if this is a team subscription
     const team = await prisma.team.findUnique({
       where: { stripeSubscriptionId: subscription.id },
       include: { members: true },
     });

     if (team) {
       // Team subscription ended - remove all team members from Discord
       for (const member of team.members) {
         if (member.discordId) {
           removeAndKickAsync(member.discordId, member.id);
         } else {
           // Member without Discord - just update status
           await prisma.member.update({
             where: { id: member.id },
             data: {
               subscriptionStatus: 'CANCELLED',
               introCompleted: false,
             },
           });
         }
       }

       // Update team status
       await prisma.team.update({
         where: { id: team.id },
         data: { subscriptionStatus: 'CANCELLED' },
       });

       logger.info(
         { teamId: team.id, memberCount: team.members.length },
         'Team subscription ended, all members removed'
       );
       break;
     }

     // Existing individual subscription handling...
     const member = await prisma.member.findFirst({
       where: { stripeCustomerId: subscription.customer as string },
     });

     // ... rest of existing logic
   }
   ```
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit` passes.
Handler updated: `grep "customer.subscription.updated" src/webhooks/stripe.ts` shows implementation.
  </verify>
  <done>
Webhook syncs seat counts from Stripe on subscription updates, handles team subscription deletion.
  </done>
</task>

<task type="auto">
  <name>Task 3: Dashboard UI for adding seats</name>
  <files>public/team-dashboard.html</files>
  <action>
Update public/team-dashboard.html to add seat purchase functionality:

1. Add "Add Seats" section below seat summary:
   ```html
   <div class="add-seats-section">
     <h3>Add More Seats</h3>
     <div class="add-seats-form">
       <div class="seat-input-group">
         <label>Owner Seats</label>
         <div class="quantity-control">
           <button onclick="decrementQuantity('owner')">-</button>
           <input type="number" id="owner-quantity" value="0" min="0" max="50">
           <button onclick="incrementQuantity('owner')">+</button>
         </div>
       </div>
       <div class="seat-input-group">
         <label>Team Seats</label>
         <div class="quantity-control">
           <button onclick="decrementQuantity('team')">-</button>
           <input type="number" id="team-quantity" value="0" min="0" max="50">
           <button onclick="incrementQuantity('team')">+</button>
         </div>
       </div>
       <button class="btn-purchase" onclick="purchaseSeats()">
         Purchase Additional Seats
       </button>
       <p class="proration-note">Seats will be prorated and charged immediately.</p>
     </div>
   </div>
   ```

2. Add JavaScript for quantity controls:
   ```javascript
   function incrementQuantity(type) {
     const input = document.getElementById(`${type}-quantity`);
     input.value = Math.min(50, parseInt(input.value) + 1);
   }

   function decrementQuantity(type) {
     const input = document.getElementById(`${type}-quantity`);
     input.value = Math.max(0, parseInt(input.value) - 1);
   }
   ```

3. Add purchase function:
   ```javascript
   async function purchaseSeats() {
     const ownerQty = parseInt(document.getElementById('owner-quantity').value);
     const teamQty = parseInt(document.getElementById('team-quantity').value);

     if (ownerQty === 0 && teamQty === 0) {
       alert('Please select at least one seat to add.');
       return;
     }

     const confirmed = confirm(
       `Add ${ownerQty} owner seat(s) and ${teamQty} team seat(s)?\n\n` +
       `You will be charged the prorated amount immediately.`
     );

     if (!confirmed) return;

     try {
       // Add owner seats if any
       if (ownerQty > 0) {
         const response = await fetch('/team/seats', {
           method: 'POST',
           headers: {
             'Content-Type': 'application/json',
             'Authorization': `Bearer ${getAccessToken()}`,
           },
           body: JSON.stringify({ seatType: 'owner', quantity: ownerQty }),
         });

         if (!response.ok) {
           const error = await response.json();
           throw new Error(error.error);
         }
       }

       // Add team seats if any
       if (teamQty > 0) {
         const response = await fetch('/team/seats', {
           method: 'POST',
           headers: {
             'Content-Type': 'application/json',
             'Authorization': `Bearer ${getAccessToken()}`,
           },
           body: JSON.stringify({ seatType: 'team', quantity: teamQty }),
         });

         if (!response.ok) {
           const error = await response.json();
           throw new Error(error.error);
         }
       }

       // Reset inputs
       document.getElementById('owner-quantity').value = 0;
       document.getElementById('team-quantity').value = 0;

       // Refresh dashboard (seat counts will update via webhook)
       showNotification('Seats purchased successfully!');

       // Wait a moment for webhook to process, then refresh
       setTimeout(loadDashboard, 2000);
     } catch (error) {
       alert(`Failed to purchase seats: ${error.message}`);
     }
   }
   ```

4. Style the add seats section:
   ```css
   .add-seats-section {
     margin-top: 2rem;
     padding: 1.5rem;
     background: rgba(212, 175, 55, 0.1);
     border: 1px solid #d4af37;
   }

   .add-seats-form {
     display: flex;
     flex-wrap: wrap;
     gap: 1rem;
     align-items: flex-end;
   }

   .seat-input-group label {
     display: block;
     margin-bottom: 0.5rem;
     color: #d4af37;
   }

   .quantity-control {
     display: flex;
     align-items: center;
   }

   .quantity-control button {
     background: #333;
     color: #d4af37;
     border: 1px solid #d4af37;
     width: 30px;
     height: 30px;
     cursor: pointer;
   }

   .quantity-control input {
     width: 50px;
     text-align: center;
     background: #1a1a2e;
     color: #fff;
     border: 1px solid #d4af37;
     height: 30px;
   }

   .btn-purchase {
     background: #d4af37;
     color: #1a1a2e;
     border: none;
     padding: 10px 20px;
     font-family: 'Cinzel', serif;
     cursor: pointer;
   }

   .proration-note {
     font-size: 0.85rem;
     color: #888;
     width: 100%;
   }
   ```
  </action>
  <verify>
File updated: Add seats section visible in dashboard HTML.
Quantity controls work.
Purchase button triggers API calls.
  </verify>
  <done>
Dashboard has seat addition UI with quantity controls and purchase button.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit` passes
2. Server starts: `npm run dev` starts without errors
3. Add seats endpoint works: POST /team/seats updates Stripe subscription
4. Webhook syncs: customer.subscription.updated updates Team seat counts
5. Team subscription deletion: All team members kicked when subscription ends
6. Dashboard UI: Add seats section displays with quantity controls
7. Proration: Stripe charges prorated amount immediately
</verification>

<success_criteria>
- POST /team/seats accepts seatType and quantity
- Stripe subscription item quantity updated with always_invoice proration
- customer.subscription.updated webhook syncs seat counts to database
- Team subscription deletion kicks all team members
- Dashboard shows add seats form with owner/team quantity inputs
- Confirmation dialog warns about immediate charge
- Seat summary updates after purchase (via webhook + refresh)
</success_criteria>

<output>
After completion, create `.planning/phases/05-team-management/05-06-SUMMARY.md`
</output>
