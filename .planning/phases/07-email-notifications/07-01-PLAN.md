---
phase: 07-email-notifications
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/config/env.ts
  - src/email/provider.ts
  - src/email/providers/resend.ts
  - src/email/providers/console.ts
  - src/email/send.ts
autonomous: true
user_setup:
  - service: resend
    why: "Transactional email delivery"
    env_vars:
      - name: RESEND_API_KEY
        source: "https://resend.com/api-keys - Create API key"
      - name: EMAIL_FROM_ADDRESS
        source: "Your verified domain email (e.g., noreply@yourdomain.com)"
      - name: EMAIL_REPLY_TO
        source: "Support email address that gets monitored"
    dashboard_config:
      - task: "Verify sending domain (or use sandbox for testing)"
        location: "https://resend.com/domains"

must_haves:
  truths:
    - "Email provider can be configured via environment variable"
    - "Console provider logs emails instead of sending (development mode)"
    - "Resend provider sends emails via API (production mode)"
    - "Send functions return success/failure status"
  artifacts:
    - path: "src/email/provider.ts"
      provides: "EmailProvider interface and factory"
      exports: ["EmailProvider", "EmailMessage", "EmailResult", "createEmailProvider"]
    - path: "src/email/providers/resend.ts"
      provides: "Resend implementation"
      exports: ["ResendProvider"]
    - path: "src/email/providers/console.ts"
      provides: "Console stub for development"
      exports: ["ConsoleProvider"]
    - path: "src/email/send.ts"
      provides: "High-level send functions"
      exports: ["emailProvider"]
  key_links:
    - from: "src/email/send.ts"
      to: "src/email/provider.ts"
      via: "createEmailProvider factory"
      pattern: "createEmailProvider\\(\\)"
    - from: "src/email/provider.ts"
      to: "src/config/env.ts"
      via: "env.EMAIL_PROVIDER switch"
      pattern: "env\\.EMAIL_PROVIDER"
---

<objective>
Set up email infrastructure with provider abstraction layer.

Purpose: Enable transactional email sending through a swappable provider interface. The console provider allows development without external dependencies; the Resend provider handles production delivery.

Output: Email provider infrastructure ready for template integration in subsequent plans.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-email-notifications/07-RESEARCH.md

@src/config/env.ts
@src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Resend SDK and extend environment config</name>
  <files>
    package.json
    src/config/env.ts
  </files>
  <action>
    1. Install Resend SDK:
       ```bash
       npm install resend
       ```

    2. Extend `src/config/env.ts` to add email configuration:
       - EMAIL_PROVIDER: z.enum(['resend', 'console']).default('console')
       - RESEND_API_KEY: z.string().startsWith('re_').optional()
       - EMAIL_FROM_ADDRESS: z.string().default('The Revenue Council <noreply@revenuecouncil.com>')
       - EMAIL_REPLY_TO: z.string().email().default('support@revenuecouncil.com')

    Make RESEND_API_KEY optional so the app can start with console provider in development.
    Use .refine() to require RESEND_API_KEY when EMAIL_PROVIDER is 'resend'.
  </action>
  <verify>
    Run `npm run build` - should compile without errors.
    Check that app starts with EMAIL_PROVIDER=console (no API key needed).
  </verify>
  <done>
    Resend SDK installed. Environment validates email config with sensible defaults.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create email provider interface and implementations</name>
  <files>
    src/email/provider.ts
    src/email/providers/resend.ts
    src/email/providers/console.ts
  </files>
  <action>
    1. Create `src/email/provider.ts` with:
       - EmailMessage interface: { to: string, subject: string, text: string, replyTo?: string }
       - EmailResult interface: { success: boolean, messageId?: string, error?: string }
       - EmailProvider interface: { send(message: EmailMessage): Promise<EmailResult> }
       - createEmailProvider() factory that reads env.EMAIL_PROVIDER and returns appropriate implementation

    2. Create `src/email/providers/console.ts` with ConsoleProvider class:
       - Implements EmailProvider interface
       - Logs email details via logger.info (to, subject, text length)
       - Logs full text content via logger.debug
       - Returns { success: true, messageId: `console-${Date.now()}` }

    3. Create `src/email/providers/resend.ts` with ResendProvider class:
       - Implements EmailProvider interface
       - Constructor takes apiKey and fromAddress parameters
       - Creates Resend client instance
       - send() method calls client.emails.send() with from, to, subject, text, replyTo
       - Returns { success: true, messageId: data.id } on success
       - Returns { success: false, error: error.message } on failure
       - Wraps in try/catch for network errors

    Import logger from '../index.js' for console provider.
    Use proper .js extensions in all imports for ESM.
  </action>
  <verify>
    Run `npm run build` - should compile without errors.
    TypeScript should recognize all exports from provider.ts.
  </verify>
  <done>
    Provider abstraction layer complete. ConsoleProvider for dev, ResendProvider for prod.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create email send module with provider instantiation</name>
  <files>
    src/email/send.ts
  </files>
  <action>
    1. Create `src/email/send.ts`:
       - Import createEmailProvider from './provider.js'
       - Create singleton emailProvider at module level: const emailProvider = createEmailProvider()
       - Export emailProvider for use by other modules

    2. This file will be extended in subsequent plans to add specific send functions (sendWelcomeEmail, etc.).
       For now, just establish the module structure and singleton pattern.

    3. Add a simple health check function for testing:
       ```typescript
       export async function testEmailConnection(): Promise<EmailResult> {
         return emailProvider.send({
           to: 'test@example.com',
           subject: 'Email System Test',
           text: 'If you receive this, the email system is working.',
         });
       }
       ```
       This function is for manual testing only - not wired to any route.
  </action>
  <verify>
    Run `npm run build` - should compile without errors.
    App should start successfully with EMAIL_PROVIDER=console.
  </verify>
  <done>
    Email module scaffolded with provider singleton. Ready for template integration.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run build` passes without errors
2. App starts with EMAIL_PROVIDER=console (default)
3. All new files exist:
   - src/email/provider.ts
   - src/email/providers/resend.ts
   - src/email/providers/console.ts
   - src/email/send.ts
4. TypeScript exports are properly typed
</verification>

<success_criteria>
- EMAIL_PROVIDER env var switches between 'console' and 'resend'
- ConsoleProvider logs emails to console (for development)
- ResendProvider sends via Resend API (requires RESEND_API_KEY)
- Provider factory creates correct implementation based on env
- Module structure ready for template functions in Plan 02+
</success_criteria>

<output>
After completion, create `.planning/phases/07-email-notifications/07-01-SUMMARY.md`
</output>
