---
phase: 08-operations
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/reconciliation/drift-detector.ts
  - src/reconciliation/auto-fixer.ts
  - src/reconciliation/notifications.ts
  - src/reconciliation/reconcile.ts
  - src/reconciliation/index.ts
  - src/email/templates.ts
  - src/email/send.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Reconciliation job runs daily at configured hour"
    - "Reconciliation detects drift between Stripe subscription status and Discord roles"
    - "Reconciliation automatically fixes role mismatches when RECONCILIATION_AUTO_FIX=true"
    - "Admin is notified via Discord channel and email when issues are found"
    - "Reconciliation run results are persisted to ReconciliationRun table"
  artifacts:
    - path: "src/reconciliation/drift-detector.ts"
      provides: "Drift detection logic"
      exports: ["detectMemberDrift", "detectTeamDrift"]
    - path: "src/reconciliation/auto-fixer.ts"
      provides: "Auto-fix logic with rate limiting"
      exports: ["applyFixes"]
    - path: "src/reconciliation/notifications.ts"
      provides: "Admin notification functions"
      exports: ["notifyAdmins"]
    - path: "src/reconciliation/reconcile.ts"
      provides: "Main reconciliation orchestration"
      exports: ["runReconciliation"]
    - path: "src/email/templates.ts"
      provides: "Reconciliation report email template"
      contains: "reconciliationReportEmailTemplate"
  key_links:
    - from: "src/reconciliation/reconcile.ts"
      to: "src/reconciliation/drift-detector.ts"
      via: "imports detection functions"
      pattern: "import.*detectMemberDrift.*from.*drift-detector"
    - from: "src/reconciliation/reconcile.ts"
      to: "src/reconciliation/auto-fixer.ts"
      via: "imports fix function"
      pattern: "import.*applyFixes.*from.*auto-fixer"
    - from: "src/reconciliation/index.ts"
      to: "src/reconciliation/reconcile.ts"
      via: "calls runReconciliation in cron job"
      pattern: "runReconciliation"
    - from: "src/index.ts"
      to: "src/reconciliation/index.ts"
      via: "starts scheduler on boot"
      pattern: "startReconciliationScheduler"
---

<objective>
Implement drift detection, auto-fix logic, and admin notifications for the reconciliation system.

Purpose: Fulfills OPS-02 (daily drift detection) and OPS-03 (automatic role mismatch fixes). Compares Stripe subscription state (source of truth) against Discord roles and database records, then optionally corrects drift with rate-limited role operations.

Output: Fully functional reconciliation system that runs daily, detects mismatches, applies fixes when enabled, and alerts admins.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-operations/08-RESEARCH.md
@.planning/phases/08-operations/08-01-SUMMARY.md
@src/reconciliation/types.ts
@src/reconciliation/index.ts
@src/bot/roles.ts
@src/config/discord.ts
@src/email/send.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement drift detection functions</name>
  <files>
    - src/reconciliation/drift-detector.ts
  </files>
  <action>
Create src/reconciliation/drift-detector.ts with three-way comparison logic:

```typescript
import Stripe from 'stripe';
import { Member, Team, SeatTier } from '@prisma/client';
import { DriftIssue, DriftSeverity } from './types.js';
import { MANAGED_ROLES } from '../config/discord.js';

// Active statuses that should have Discord access
const ACTIVE_STATUSES = ['active', 'trialing', 'past_due'];

/**
 * Check if a Stripe subscription status grants access
 */
function isActiveSubscription(status: string | null): boolean {
  return status !== null && ACTIVE_STATUSES.includes(status);
}

/**
 * Get expected Discord role for a member based on their state
 */
function getExpectedRole(member: Member): string | null {
  if (member.isInDebtorState) return 'Debtor';
  if (!member.introCompleted) return 'Squire';
  if (member.seatTier === 'OWNER' || member.seatTier === 'INDIVIDUAL') return 'Lord';
  return 'Knight';
}

/**
 * Check if Discord roles include any membership role
 */
function hasAnyMemberRole(roles: string[]): boolean {
  return roles.some(r => ['Knight', 'Lord', 'Squire'].includes(r));
}

/**
 * Detect drift for an individual member
 * Compares Stripe subscription status against Discord roles
 *
 * @param member - Member with optional team relation
 * @param stripeCustomerMap - Map of Stripe customer ID to subscription
 * @param discordMemberMap - Map of Discord ID to role names
 */
export function detectMemberDrift(
  member: Member & { team: Team | null },
  stripeCustomerMap: Map<string, Stripe.Subscription>,
  discordMemberMap: Map<string, string[]>
): DriftIssue[] {
  const issues: DriftIssue[] = [];

  // Skip members without Discord linked (unclaimed is valid per CONTEXT.md)
  if (!member.discordId) return issues;

  // Determine Stripe status
  let stripeActive = false;
  let stripeStatus: string | null = null;

  if (member.teamId && member.team?.stripeCustomerId) {
    // Team member - check team subscription
    const sub = stripeCustomerMap.get(member.team.stripeCustomerId);
    stripeStatus = sub?.status ?? null;
    stripeActive = isActiveSubscription(stripeStatus);
  } else if (member.stripeCustomerId) {
    // Individual - check member subscription
    const sub = stripeCustomerMap.get(member.stripeCustomerId);
    stripeStatus = sub?.status ?? null;
    stripeActive = isActiveSubscription(stripeStatus);
  }

  // Get actual Discord roles
  const discordRoles = discordMemberMap.get(member.discordId) ?? [];
  const hasRole = hasAnyMemberRole(discordRoles);
  const hasDebtorRole = discordRoles.includes('Debtor');

  // Scenario 1: Stripe active but Discord has no role (MISSING_ACCESS)
  if (stripeActive && !hasRole && !hasDebtorRole) {
    issues.push({
      type: 'MISSING_ACCESS',
      memberId: member.id,
      discordId: member.discordId,
      description: `Stripe ${stripeStatus} but Discord has no member role`,
      stripeStatus,
      databaseStatus: member.subscriptionStatus,
      discordRoles,
      severity: 'HIGH',
    });
  }

  // Scenario 2: Discord has role but Stripe inactive (UNAUTHORIZED_ACCESS)
  if (!stripeActive && hasRole && !member.isInDebtorState) {
    issues.push({
      type: 'UNAUTHORIZED_ACCESS',
      memberId: member.id,
      discordId: member.discordId,
      description: `Discord has ${discordRoles.join(', ')} but Stripe ${stripeStatus ?? 'no subscription'}`,
      stripeStatus,
      databaseStatus: member.subscriptionStatus,
      discordRoles,
      severity: 'HIGH',
    });
  }

  // Scenario 3: Role mismatch (wrong tier)
  if (stripeActive && hasRole) {
    const expectedRole = getExpectedRole(member);
    const hasManagedRole = discordRoles.find(r => (MANAGED_ROLES as readonly string[]).includes(r));

    if (expectedRole && hasManagedRole && hasManagedRole !== expectedRole) {
      issues.push({
        type: 'ROLE_MISMATCH',
        memberId: member.id,
        discordId: member.discordId,
        description: `Expected ${expectedRole} but has ${hasManagedRole}`,
        stripeStatus,
        databaseStatus: member.subscriptionStatus,
        discordRoles,
        severity: 'MEDIUM',
      });
    }
  }

  // Scenario 4: Debtor state mismatch
  if (member.isInDebtorState && !hasDebtorRole) {
    issues.push({
      type: 'DEBTOR_MISMATCH',
      memberId: member.id,
      discordId: member.discordId,
      description: `Member in Debtor state but Discord missing Debtor role`,
      stripeStatus,
      databaseStatus: member.subscriptionStatus,
      discordRoles,
      severity: 'MEDIUM',
    });
  }

  return issues;
}

/**
 * Detect drift for a team (checks all team members against team subscription)
 * Team-level issues are aggregated into member issues since roles are per-member
 */
export function detectTeamDrift(
  team: Team & { members: Member[] },
  stripeCustomerMap: Map<string, Stripe.Subscription>,
  discordMemberMap: Map<string, string[]>
): DriftIssue[] {
  const issues: DriftIssue[] = [];

  // Get team subscription status
  const teamSub = stripeCustomerMap.get(team.stripeCustomerId);
  const teamStripeActive = isActiveSubscription(teamSub?.status ?? null);

  // Check each team member
  for (const member of team.members) {
    if (!member.discordId) continue;

    const discordRoles = discordMemberMap.get(member.discordId) ?? [];
    const hasRole = hasAnyMemberRole(discordRoles);

    // Team subscription active but member has no role
    if (teamStripeActive && !hasRole && !member.isInDebtorState) {
      issues.push({
        type: 'MISSING_ACCESS',
        memberId: member.id,
        discordId: member.discordId,
        description: `Team ${team.name} Stripe active but member has no Discord role`,
        stripeStatus: teamSub?.status ?? null,
        databaseStatus: team.subscriptionStatus,
        discordRoles,
        severity: 'HIGH',
      });
    }

    // Team subscription inactive but member has role
    if (!teamStripeActive && hasRole && !member.isInDebtorState) {
      issues.push({
        type: 'UNAUTHORIZED_ACCESS',
        memberId: member.id,
        discordId: member.discordId,
        description: `Team ${team.name} Stripe inactive but member has Discord role`,
        stripeStatus: teamSub?.status ?? null,
        databaseStatus: team.subscriptionStatus,
        discordRoles,
        severity: 'HIGH',
      });
    }
  }

  return issues;
}
```

Key points:
- Unclaimed subscriptions (no discordId) are skipped per CONTEXT.md
- Three-way comparison: Stripe, database, Discord
- Team members check team subscription, not their own stripeCustomerId
- Expected role considers seatTier, introCompleted, and isInDebtorState
  </action>
  <verify>
    - `npm run build` succeeds
    - File exists at src/reconciliation/drift-detector.ts
    - Exports detectMemberDrift and detectTeamDrift
  </verify>
  <done>detectMemberDrift and detectTeamDrift functions detect all drift scenarios</done>
</task>

<task type="auto">
  <name>Task 2: Implement auto-fix and notifications</name>
  <files>
    - src/reconciliation/auto-fixer.ts
    - src/reconciliation/notifications.ts
    - src/email/templates.ts
    - src/email/send.ts
  </files>
  <action>
1. Create src/reconciliation/auto-fixer.ts:
```typescript
import pRetry from 'p-retry';
import { DriftIssue } from './types.js';
import { prisma } from '../lib/prisma.js';
import { addRoleToMember, removeRoleFromMember, removeAllManagedRoles } from '../bot/roles.js';
import { logger } from '../index.js';

// Rate limit protection: process in batches with delays
const BATCH_SIZE = 5;
const BATCH_DELAY_MS = 2000; // 2 seconds between batches (Discord: 10 role ops per 10s)

/**
 * Apply a single fix based on drift type
 * Returns true if fix was applied successfully
 */
async function applyFix(issue: DriftIssue): Promise<boolean> {
  if (!issue.discordId) return false;

  try {
    switch (issue.type) {
      case 'MISSING_ACCESS': {
        // Member should have a role but doesn't
        // Get expected role from database
        const member = await prisma.member.findUnique({
          where: { id: issue.memberId },
        });
        if (!member) return false;

        // Determine correct role
        let role = 'Squire'; // Default for unintroduced
        if (member.introCompleted) {
          role = member.seatTier === 'OWNER' || member.seatTier === 'INDIVIDUAL' ? 'Lord' : 'Knight';
        }
        if (member.isInDebtorState) {
          role = 'Debtor';
        }

        return await pRetry(() => addRoleToMember(issue.discordId!, role), {
          retries: 2,
          minTimeout: 1000,
        });
      }

      case 'UNAUTHORIZED_ACCESS': {
        // Member has role but shouldn't
        return await pRetry(() => removeAllManagedRoles(issue.discordId!), {
          retries: 2,
          minTimeout: 1000,
        });
      }

      case 'ROLE_MISMATCH': {
        // Member has wrong role - get correct one
        const member = await prisma.member.findUnique({
          where: { id: issue.memberId },
        });
        if (!member) return false;

        // Remove current managed roles, add correct one
        await pRetry(() => removeAllManagedRoles(issue.discordId!), {
          retries: 2,
          minTimeout: 1000,
        });

        let role = 'Knight';
        if (member.seatTier === 'OWNER' || member.seatTier === 'INDIVIDUAL') {
          role = 'Lord';
        }
        if (!member.introCompleted) {
          role = 'Squire';
        }
        if (member.isInDebtorState) {
          role = 'Debtor';
        }

        return await pRetry(() => addRoleToMember(issue.discordId!, role), {
          retries: 2,
          minTimeout: 1000,
        });
      }

      case 'DEBTOR_MISMATCH': {
        // Member in debtor state but missing Debtor role
        // Remove other roles, add Debtor
        await pRetry(() => removeAllManagedRoles(issue.discordId!), {
          retries: 2,
          minTimeout: 1000,
        });
        return await pRetry(() => addRoleToMember(issue.discordId!, 'Debtor'), {
          retries: 2,
          minTimeout: 1000,
        });
      }

      default:
        return false;
    }
  } catch (error) {
    logger.error({ issue, error }, 'Failed to apply fix');
    return false;
  }
}

/**
 * Apply fixes for all issues with rate limiting
 * Processes in batches to avoid Discord rate limits
 *
 * @param issues - Array of drift issues to fix
 * @returns Number of issues successfully fixed
 */
export async function applyFixes(issues: DriftIssue[]): Promise<number> {
  let fixed = 0;

  for (let i = 0; i < issues.length; i += BATCH_SIZE) {
    const batch = issues.slice(i, i + BATCH_SIZE);

    for (const issue of batch) {
      const success = await applyFix(issue);
      if (success) {
        fixed++;
        logger.info(
          { type: issue.type, memberId: issue.memberId, discordId: issue.discordId },
          'Applied reconciliation fix'
        );
      }
    }

    // Delay between batches (except after last batch)
    if (i + BATCH_SIZE < issues.length) {
      await new Promise(r => setTimeout(r, BATCH_DELAY_MS));
    }
  }

  return fixed;
}
```

2. Create src/reconciliation/notifications.ts:
```typescript
import { TextChannel } from 'discord.js';
import { discordClient } from '../bot/client.js';
import { env } from '../config/env.js';
import { logger } from '../index.js';
import { ReconciliationResult, DriftIssue } from './types.js';
import { sendReconciliationReportEmail } from '../email/send.js';

/**
 * Group issues by type for summary
 */
function groupByType(issues: DriftIssue[]): Record<string, DriftIssue[]> {
  return issues.reduce((acc, issue) => {
    if (!acc[issue.type]) acc[issue.type] = [];
    acc[issue.type].push(issue);
    return acc;
  }, {} as Record<string, DriftIssue[]>);
}

/**
 * Format reconciliation summary for Discord/email
 */
function formatSummary(result: ReconciliationResult): string {
  const lines: string[] = [
    `**Issues Found:** ${result.issuesFound}`,
    `**Auto-Fix:** ${result.autoFixEnabled ? 'Enabled' : 'Disabled (report only)'}`,
  ];

  if (result.autoFixEnabled && result.issuesFixed > 0) {
    lines.push(`**Issues Fixed:** ${result.issuesFixed}`);
  }

  // Group by type
  const byType = groupByType(result.issues);
  for (const [type, typeIssues] of Object.entries(byType)) {
    lines.push(`\n**${type}:** ${typeIssues.length}`);
    // Show first 5 examples
    for (const issue of typeIssues.slice(0, 5)) {
      lines.push(`- ${issue.description}`);
    }
    if (typeIssues.length > 5) {
      lines.push(`- ... and ${typeIssues.length - 5} more`);
    }
  }

  lines.push(`\nRun ID: ${result.runId}`);

  return lines.join('\n');
}

/**
 * Notify admins via Discord channel and email when issues found
 * Per CONTEXT.md: Only notify when issues found, not "all clear"
 */
export async function notifyAdmins(result: ReconciliationResult): Promise<void> {
  // Skip if no issues
  if (result.issuesFound === 0) {
    logger.info('Reconciliation complete: no issues found');
    return;
  }

  const summary = formatSummary(result);

  // 1. Discord admin channel notification
  if (env.DISCORD_ADMIN_CHANNEL_ID) {
    try {
      const channel = await discordClient.channels.fetch(env.DISCORD_ADMIN_CHANNEL_ID);
      if (channel?.isTextBased()) {
        await (channel as TextChannel).send({
          content: `**[Reconciliation Alert]**\n\n${summary}`,
        });
        logger.info('Reconciliation alert sent to Discord admin channel');
      }
    } catch (error) {
      logger.error({ error }, 'Failed to send reconciliation alert to Discord');
    }
  }

  // 2. Email notification to admin
  if (env.ADMIN_EMAIL) {
    try {
      await sendReconciliationReportEmail(env.ADMIN_EMAIL, result);
      logger.info({ email: env.ADMIN_EMAIL }, 'Reconciliation report email sent');
    } catch (error) {
      logger.error({ error }, 'Failed to send reconciliation report email');
    }
  }
}
```

3. Add reconciliation email template to src/email/templates.ts (add before the closing exports):
```typescript
/**
 * Reconciliation report email template
 * Sent to admin when drift issues are detected
 */
export function reconciliationReportEmailTemplate(params: {
  runId: string;
  issuesFound: number;
  issuesFixed: number;
  autoFixEnabled: boolean;
  summaryText: string;
}): { subject: string; text: string } {
  const { runId, issuesFound, issuesFixed, autoFixEnabled, summaryText } = params;

  const subject = `[TRC Reconciliation] ${issuesFound} drift issue${issuesFound === 1 ? '' : 's'} detected`;

  const fixStatus = autoFixEnabled
    ? `Auto-fix is ENABLED. ${issuesFixed} issue${issuesFixed === 1 ? '' : 's'} were automatically corrected.`
    : `Auto-fix is DISABLED. Manual review required.`;

  const text = `
The Revenue Council - Reconciliation Report
============================================

${issuesFound} drift issue${issuesFound === 1 ? '' : 's'} detected between Stripe and Discord.

${fixStatus}

Summary:
${summaryText}

Run ID: ${runId}

---
This is an automated report from The Revenue Council membership system.
To enable automatic fixes, set RECONCILIATION_AUTO_FIX=true.
`.trim();

  return { subject, text };
}
```

4. Add sendReconciliationReportEmail to src/email/send.ts (add after sendSeatInviteEmail):
```typescript
import { reconciliationReportEmailTemplate } from './templates.js';
import type { ReconciliationResult } from '../reconciliation/types.js';

/**
 * Send reconciliation report email to admin
 * Only sent when issues are found
 */
export async function sendReconciliationReportEmail(
  email: string,
  result: ReconciliationResult
): Promise<EmailResult> {
  // Build summary text for email
  const groupByType = (issues: typeof result.issues) =>
    issues.reduce((acc, issue) => {
      if (!acc[issue.type]) acc[issue.type] = [];
      acc[issue.type].push(issue);
      return acc;
    }, {} as Record<string, typeof result.issues>);

  const byType = groupByType(result.issues);
  const summaryLines: string[] = [];
  for (const [type, typeIssues] of Object.entries(byType)) {
    summaryLines.push(`${type}: ${typeIssues.length}`);
    for (const issue of typeIssues.slice(0, 3)) {
      summaryLines.push(`  - ${issue.description}`);
    }
    if (typeIssues.length > 3) {
      summaryLines.push(`  - ... and ${typeIssues.length - 3} more`);
    }
  }

  const { subject, text } = reconciliationReportEmailTemplate({
    runId: result.runId,
    issuesFound: result.issuesFound,
    issuesFixed: result.issuesFixed,
    autoFixEnabled: result.autoFixEnabled,
    summaryText: summaryLines.join('\n'),
  });

  const sendResult = await emailProvider.send({
    to: email,
    subject,
    text,
  });

  logger.info({ email, success: sendResult.success }, 'Reconciliation report email sent');
  return sendResult;
}
```

Note: Import ReconciliationResult type at the top of send.ts and add reconciliationReportEmailTemplate to the imports from templates.js.
  </action>
  <verify>
    - `npm run build` succeeds
    - Files exist: auto-fixer.ts, notifications.ts
    - Email template and send function added
    - applyFixes, notifyAdmins exported
  </verify>
  <done>Auto-fix applies corrections with rate limiting; admin notifications via Discord and email</done>
</task>

<task type="auto">
  <name>Task 3: Implement main reconciliation flow and wire to startup</name>
  <files>
    - src/reconciliation/reconcile.ts
    - src/reconciliation/index.ts
    - src/index.ts
  </files>
  <action>
1. Create src/reconciliation/reconcile.ts:
```typescript
import Stripe from 'stripe';
import cron from 'node-cron';
import { prisma } from '../lib/prisma.js';
import { env } from '../config/env.js';
import { logger } from '../index.js';
import { discordClient } from '../bot/client.js';
import { MANAGED_ROLES } from '../config/discord.js';
import { ReconciliationResult, ReconciliationOptions, DriftIssue } from './types.js';
import { detectMemberDrift, detectTeamDrift } from './drift-detector.js';
import { applyFixes } from './auto-fixer.js';
import { notifyAdmins } from './notifications.js';

const stripe = new Stripe(env.STRIPE_SECRET_KEY);

/**
 * Build map of Stripe customer ID to subscription
 * Iterates all subscriptions with pagination
 */
async function buildStripeSubscriptionMap(): Promise<Map<string, Stripe.Subscription>> {
  const map = new Map<string, Stripe.Subscription>();

  // Use Stripe auto-pagination
  for await (const subscription of stripe.subscriptions.list({
    limit: 100,
    status: 'all', // Include active, past_due, canceled, etc.
  })) {
    const customerId = subscription.customer as string;
    // Keep most recent subscription per customer
    const existing = map.get(customerId);
    if (!existing || subscription.created > existing.created) {
      map.set(customerId, subscription);
    }
  }

  logger.info({ count: map.size }, 'Built Stripe subscription map');
  return map;
}

/**
 * Build map of Discord user ID to managed role names
 * Fetches all guild members and filters to managed roles
 */
async function buildDiscordMemberMap(): Promise<Map<string, string[]>> {
  const map = new Map<string, string[]>();

  const guild = discordClient.guilds.cache.get(env.DISCORD_GUILD_ID);
  if (!guild) {
    logger.error('Guild not found for reconciliation');
    return map;
  }

  // Fetch all members (fresh, not cached)
  const members = await guild.members.fetch();

  for (const [discordId, member] of members) {
    const managedRoles = member.roles.cache
      .filter(r => (MANAGED_ROLES as readonly string[]).includes(r.name))
      .map(r => r.name);

    map.set(discordId, managedRoles);
  }

  logger.info({ count: map.size }, 'Built Discord member map');
  return map;
}

/**
 * Schedule verification re-run 1 hour after fixes applied
 */
function scheduleVerificationRerun(): void {
  const oneHourLater = new Date(Date.now() + 60 * 60 * 1000);
  const minute = oneHourLater.getMinutes();
  const hour = oneHourLater.getHours();

  logger.info({ scheduledFor: oneHourLater.toISOString() }, 'Scheduling verification re-run');

  const job = cron.schedule(
    `${minute} ${hour} * * *`,
    async () => {
      await runReconciliation({ isVerificationRerun: true, triggeredBy: 'verification' });
      job.stop(); // One-time execution
    },
    { timezone: env.RECONCILIATION_TIMEZONE }
  );
}

/**
 * Run full reconciliation: detect drift, optionally fix, notify admins
 */
export async function runReconciliation(
  options: ReconciliationOptions = {}
): Promise<ReconciliationResult> {
  const startedAt = new Date();
  const triggeredBy = options.triggeredBy ?? 'scheduled';
  const autoFixEnabled = env.RECONCILIATION_AUTO_FIX === 'true';
  const isVerificationRerun = options.isVerificationRerun ?? false;

  logger.info({ triggeredBy, autoFixEnabled, isVerificationRerun }, 'Starting reconciliation');

  // Create run record
  const run = await prisma.reconciliationRun.create({
    data: {
      triggeredBy,
      autoFixEnabled,
      isVerificationRun: isVerificationRerun,
    },
  });

  try {
    // Build data maps (parallel)
    const [stripeMap, discordMap] = await Promise.all([
      buildStripeSubscriptionMap(),
      buildDiscordMemberMap(),
    ]);

    // Get all members with Discord linked (include team for team-based checks)
    const members = await prisma.member.findMany({
      where: { discordId: { not: null } },
      include: { team: true },
    });

    // Detect drift for each member
    const allIssues: DriftIssue[] = [];
    for (const member of members) {
      const issues = detectMemberDrift(member, stripeMap, discordMap);
      allIssues.push(...issues);
    }

    // Get teams with subscription (for team-level drift detection)
    const teams = await prisma.team.findMany({
      where: { stripeSubscriptionId: { not: null } },
      include: { members: true },
    });

    for (const team of teams) {
      const issues = detectTeamDrift(team, stripeMap, discordMap);
      allIssues.push(...issues);
    }

    // Deduplicate issues (same member may appear in both member and team checks)
    const uniqueIssues = Array.from(
      new Map(allIssues.map(i => [`${i.memberId}-${i.type}`, i])).values()
    );

    // Apply fixes if enabled
    let issuesFixed = 0;
    if (autoFixEnabled && uniqueIssues.length > 0) {
      issuesFixed = await applyFixes(uniqueIssues);

      // Schedule verification re-run if fixes were applied (and this isn't already a re-run)
      if (issuesFixed > 0 && !isVerificationRerun) {
        scheduleVerificationRerun();
      }
    }

    // Update run record
    const completedAt = new Date();
    await prisma.reconciliationRun.update({
      where: { id: run.id },
      data: {
        completedAt,
        membersChecked: members.length,
        teamsChecked: teams.length,
        issuesFound: uniqueIssues.length,
        issuesFixed,
        issues: uniqueIssues as unknown as Prisma.InputJsonValue,
      },
    });

    const result: ReconciliationResult = {
      runId: run.id,
      issuesFound: uniqueIssues.length,
      issuesFixed,
      issues: uniqueIssues,
      autoFixEnabled,
    };

    // Notify admins (only if issues found)
    await notifyAdmins(result);

    const durationMs = completedAt.getTime() - startedAt.getTime();
    logger.info(
      {
        runId: run.id,
        durationMs,
        membersChecked: members.length,
        teamsChecked: teams.length,
        issuesFound: uniqueIssues.length,
        issuesFixed,
      },
      'Reconciliation complete'
    );

    return result;
  } catch (error) {
    logger.error({ runId: run.id, error }, 'Reconciliation failed');

    // Mark run as completed (with error state implied by missing completedAt? or we complete it)
    await prisma.reconciliationRun.update({
      where: { id: run.id },
      data: { completedAt: new Date() },
    });

    throw error;
  }
}
```

Note: Add `import { Prisma } from '@prisma/client';` at the top for the InputJsonValue type.

2. Update src/reconciliation/index.ts to call runReconciliation:
```typescript
import cron from 'node-cron';
import { env } from '../config/env.js';
import { logger } from '../index.js';
import { runReconciliation } from './reconcile.js';

/**
 * Start the reconciliation scheduler
 * Runs daily at configured hour in configured timezone
 * Can be paused via RECONCILIATION_PAUSED env var
 */
export function startReconciliationScheduler(): void {
  const hour = env.RECONCILIATION_HOUR;
  const timezone = env.RECONCILIATION_TIMEZONE;
  const cronExpression = `0 ${hour} * * *`; // Daily at specified hour

  logger.info(
    { hour, timezone, cronExpression },
    'Starting reconciliation scheduler'
  );

  cron.schedule(
    cronExpression,
    async () => {
      // Check pause flag
      if (env.RECONCILIATION_PAUSED === 'true') {
        logger.info('Reconciliation paused via RECONCILIATION_PAUSED env var');
        return;
      }

      logger.info('Reconciliation job starting (scheduled)');

      try {
        const result = await runReconciliation({ triggeredBy: 'scheduled' });
        logger.info(
          { issuesFound: result.issuesFound, issuesFixed: result.issuesFixed },
          'Reconciliation job completed'
        );
      } catch (error) {
        logger.error({ error }, 'Reconciliation job failed');
      }
    },
    { timezone }
  );

  logger.info('Reconciliation scheduler started');
}

// Re-export for consumers
export { runReconciliation } from './reconcile.js';
export type { DriftIssue, ReconciliationResult, ReconciliationOptions } from './types.js';
```

3. Update src/index.ts to start reconciliation scheduler after Discord bot is ready:
- Find the existing Discord ready event handler (after discordClient.login)
- Add startReconciliationScheduler() call after the bot logs in

Look for the pattern:
```typescript
discordClient.once('ready', async () => {
  // ... existing code ...
});
```

Inside that handler (or after discordClient.login succeeds), add:
```typescript
import { startReconciliationScheduler } from './reconciliation/index.js';

// In the ready handler or after login:
startReconciliationScheduler();
```

This ensures the bot is ready and guild is available before scheduling reconciliation.
  </action>
  <verify>
    - `npm run build` succeeds
    - App starts without error
    - Log shows "Starting reconciliation scheduler" on startup
    - reconcile.ts exports runReconciliation
  </verify>
  <done>Reconciliation runs daily at configured hour; results persisted to ReconciliationRun; admins notified when issues found</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Build verification:
   - `npm run build` passes
   - No TypeScript errors

2. Module structure:
   - src/reconciliation/drift-detector.ts exports detectMemberDrift, detectTeamDrift
   - src/reconciliation/auto-fixer.ts exports applyFixes
   - src/reconciliation/notifications.ts exports notifyAdmins
   - src/reconciliation/reconcile.ts exports runReconciliation
   - src/reconciliation/index.ts exports startReconciliationScheduler

3. Integration:
   - App starts and logs "Starting reconciliation scheduler"
   - Scheduler configured for daily execution at RECONCILIATION_HOUR

4. Requirements met:
   - OPS-02: Reconciliation runs daily to detect drift
   - OPS-03: Reconciliation fixes mismatches when RECONCILIATION_AUTO_FIX=true
</verification>

<success_criteria>
- Reconciliation job runs daily at configured hour (OPS-02)
- Drift detection covers: MISSING_ACCESS, UNAUTHORIZED_ACCESS, ROLE_MISMATCH, DEBTOR_MISMATCH
- Auto-fix applies corrections with rate limiting when enabled (OPS-03)
- Admin notified via Discord channel AND email when issues found
- ReconciliationRun records persist full audit trail
- Verification re-run scheduled 1 hour after fixes applied
</success_criteria>

<output>
After completion, create `.planning/phases/08-operations/08-02-SUMMARY.md`
</output>
