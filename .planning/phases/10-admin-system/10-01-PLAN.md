---
phase: 10-admin-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - prisma/seed.ts
  - src/admin/auth.ts
  - src/admin/middleware.ts
  - src/routes/admin/auth.ts
  - src/config/env.ts
autonomous: true
user_setup:
  - service: first-admin
    why: "First admin account credentials"
    env_vars:
      - name: ADMIN_SEED_EMAIL
        source: "Choose an email for the first super admin"
      - name: ADMIN_SEED_PASSWORD
        source: "Choose a secure password for the first super admin"

must_haves:
  truths:
    - "Admin model exists in database schema with email, passwordHash, role, timestamps"
    - "Seed script creates first super admin from environment variables"
    - "Admin can login at POST /admin/auth/login with email and password"
    - "Admin receives JWT tokens with 30-day refresh expiry"
    - "Admin tokens are stored in separate cookie path from member tokens"
    - "requireAdmin middleware blocks non-admin requests"
    - "requireSuperAdmin middleware blocks regular admin requests"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "Admin model and AdminRole enum"
      contains: "model Admin"
    - path: "prisma/seed.ts"
      provides: "First super admin creation script"
      contains: "ADMIN_SEED_EMAIL"
    - path: "src/admin/auth.ts"
      provides: "Admin JWT token creation and verification"
      exports: ["createAdminAccessToken", "createAdminRefreshToken", "verifyAdminToken"]
    - path: "src/admin/middleware.ts"
      provides: "Admin authentication middleware"
      exports: ["requireAdmin", "requireSuperAdmin"]
    - path: "src/routes/admin/auth.ts"
      provides: "Admin login/logout/refresh endpoints"
      exports: ["adminAuthRouter"]
  key_links:
    - from: "src/routes/admin/auth.ts"
      to: "src/admin/auth.ts"
      via: "token creation on login"
      pattern: "createAdminAccessToken|createAdminRefreshToken"
    - from: "src/admin/middleware.ts"
      to: "src/admin/auth.ts"
      via: "token verification"
      pattern: "verifyAdminToken"
---

<objective>
Establish admin authentication infrastructure separate from member authentication.

Purpose: Admins need their own login flow with separate tokens and longer sessions (30 days) to manage the system without affecting member sessions.

Output: Admin model in database, seed script for first admin, login/logout/refresh endpoints, and middleware for route protection.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-admin-system/10-CONTEXT.md
@.planning/phases/10-admin-system/10-RESEARCH.md

# Existing auth patterns to extend
@src/auth/session.ts
@src/lib/password.ts
@src/config/env.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Schema updates for Admin model</name>
  <files>prisma/schema.prisma, prisma/seed.ts, src/config/env.ts</files>
  <action>
1. Add AdminRole enum to prisma/schema.prisma:
   - ADMIN (member management only)
   - SUPER_ADMIN (full access including admin management + system config)

2. Add Admin model to prisma/schema.prisma:
   - id: String @id @default(cuid())
   - email: String @unique
   - passwordHash: String
   - role: AdminRole @default(ADMIN)
   - lastLoginAt: DateTime?
   - createdAt: DateTime @default(now())
   - updatedAt: DateTime @updatedAt
   - createdBy: String? (Admin ID who created this admin, null for seed admin)
   - Add index on email

3. Add FeatureFlag model to prisma/schema.prisma (needed for Phase 10):
   - id: String @id @default(cuid())
   - key: String @unique
   - enabled: Boolean @default(false)
   - description: String?
   - category: String @default("general")
   - updatedAt: DateTime @updatedAt
   - updatedBy: String? (Admin ID)
   - Add index on key

4. Add EmailTemplate model to prisma/schema.prisma:
   - id: String @id @default(cuid())
   - name: String @unique (e.g., "welcome", "claim_reminder", "payment_failure")
   - subject: String
   - body: String (plain text with {{variable}} placeholders)
   - updatedAt: DateTime @updatedAt
   - updatedBy: String? (Admin ID)

5. Add env vars to src/config/env.ts:
   - ADMIN_SEED_EMAIL: z.string().email().optional()
   - ADMIN_SEED_PASSWORD: z.string().min(8).optional()

6. Create prisma/seed.ts:
   - Import PrismaClient and hashPassword from lib/password.js
   - Check if any admin exists, skip if so
   - Require ADMIN_SEED_EMAIL and ADMIN_SEED_PASSWORD env vars
   - Hash password with existing hashPassword function
   - Create first admin with role: 'SUPER_ADMIN'
   - Log success message

7. Add seed script to package.json:
   - "prisma": { "seed": "tsx prisma/seed.ts" }

8. Run `npx prisma db push` to apply schema changes
  </action>
  <verify>
    - `npx prisma db push` succeeds without errors
    - Admin model visible in Prisma Studio: `npx prisma studio`
    - FeatureFlag and EmailTemplate models also visible
  </verify>
  <done>
    - Admin, FeatureFlag, EmailTemplate models exist in schema
    - Seed script ready to create first super admin
    - Env vars documented in env.ts
  </done>
</task>

<task type="auto">
  <name>Task 2: Admin auth module and middleware</name>
  <files>src/admin/auth.ts, src/admin/middleware.ts</files>
  <action>
1. Create src/admin/auth.ts (following patterns from src/auth/session.ts):
   - Import SignJWT, jwtVerify from 'jose'
   - Import env from config/env.js
   - Define AdminTokenPayload interface:
     - sub: string (admin ID)
     - type?: 'refresh'
     - isAdmin: true (literal type to distinguish from member tokens)
     - role: 'ADMIN' | 'SUPER_ADMIN'

   - Create secret same as member tokens (reuse env.JWT_SECRET)

   - createAdminAccessToken(adminId: string, role: AdminRole): Promise<string>
     - 15 minute expiry (same as member)
     - Include isAdmin: true and role in payload

   - createAdminRefreshToken(adminId: string, role: AdminRole): Promise<string>
     - 30 days expiry (per CONTEXT.md)
     - Include isAdmin: true, role, type: 'refresh'

   - verifyAdminToken(token: string): Promise<AdminTokenPayload | null>
     - Verify token with jose
     - Return null if invalid, expired, or missing isAdmin: true

   - Export ADMIN_REFRESH_COOKIE_NAME = 'trc_admin_refresh'
   - Export ADMIN_REFRESH_COOKIE_OPTIONS:
     - httpOnly: true
     - secure: env.NODE_ENV === 'production'
     - sameSite: 'strict'
     - path: '/admin/auth/refresh' (separate from member path!)
     - maxAge: 30 * 24 * 60 * 60 (30 days)

2. Create src/admin/middleware.ts:
   - Import verifyAdminToken from './auth.js'
   - Import prisma from lib/prisma.js
   - Import Request, Response, NextFunction from 'express'

   - Extend Express Request type to include admin property (or use res.locals)

   - requireAdmin middleware:
     - Extract token from Authorization header (Bearer token)
     - Call verifyAdminToken
     - If invalid: return 401 { error: 'Unauthorized' }
     - Fetch admin from database by ID
     - If not found: return 401 { error: 'Unauthorized' }
     - Attach admin to res.locals.admin
     - Call next()

   - requireSuperAdmin middleware:
     - Must be used after requireAdmin
     - Check res.locals.admin.role === 'SUPER_ADMIN'
     - If not: return 403 { error: 'Super admin access required' }
     - Call next()
  </action>
  <verify>
    - `npx tsc --noEmit` passes without type errors
    - Auth module exports all expected functions
    - Middleware exports requireAdmin and requireSuperAdmin
  </verify>
  <done>
    - Admin tokens use 30-day refresh expiry per CONTEXT.md
    - Separate cookie path prevents conflicts with member sessions
    - Middleware distinguishes ADMIN from SUPER_ADMIN
  </done>
</task>

<task type="auto">
  <name>Task 3: Admin auth routes</name>
  <files>src/routes/admin/auth.ts, src/index.ts</files>
  <action>
1. Create src/routes/admin/auth.ts:
   - Import Router from 'express'
   - Import z from 'zod'
   - Import prisma
   - Import verifyPassword from lib/password.js
   - Import admin auth functions and cookie constants
   - Import cookie from 'cookie'

   - Define loginSchema with Zod:
     - email: z.string().email()
     - password: z.string().min(1)

   - POST /login:
     - Parse body with loginSchema
     - Find admin by email (case insensitive with { mode: 'insensitive' })
     - If not found: return 401 { error: 'Invalid credentials' } (anti-enumeration)
     - Verify password with verifyPassword
     - If invalid: return 401 { error: 'Invalid credentials' }
     - Update lastLoginAt timestamp
     - Create access and refresh tokens
     - Set refresh token in httpOnly cookie with ADMIN_REFRESH_COOKIE_OPTIONS
     - Return { accessToken, admin: { id, email, role } }

   - POST /refresh:
     - Parse refresh token from cookies
     - Verify with verifyAdminToken
     - If invalid or type !== 'refresh': return 401
     - Fetch admin by ID (may have been deleted)
     - If not found: return 401
     - Create new access and refresh tokens (rotation)
     - Set new refresh cookie
     - Return { accessToken, admin: { id, email, role } }

   - POST /logout:
     - Clear admin refresh cookie by setting maxAge: 0
     - Return { success: true }

   - Export adminAuthRouter

2. Update src/index.ts:
   - Import adminAuthRouter from './routes/admin/auth.js'
   - Mount at /admin/auth (before other routes, no auth required for login)
   - Use express.json() middleware for admin routes
  </action>
  <verify>
    - Run seed: `npx prisma db seed` (requires ADMIN_SEED_EMAIL and ADMIN_SEED_PASSWORD)
    - Test login: `curl -X POST http://localhost:3000/admin/auth/login -H "Content-Type: application/json" -d '{"email":"admin@example.com","password":"password"}'`
    - Verify response includes accessToken and admin object
  </verify>
  <done>
    - Admin can login and receive tokens
    - Refresh endpoint rotates tokens
    - Logout clears cookie
    - Routes mounted at /admin/auth/*
  </done>
</task>

</tasks>

<verification>
1. Schema: `npx prisma db push` succeeds, Admin/FeatureFlag/EmailTemplate models exist
2. Seed: `npx prisma db seed` creates first super admin (requires env vars)
3. Auth module: TypeScript compiles without errors
4. Login flow: POST /admin/auth/login returns tokens with admin info
5. Cookie: Refresh cookie set on /admin/auth/refresh path (not conflicting with member)
6. Middleware: requireAdmin blocks requests without valid admin token
</verification>

<success_criteria>
- Admin model exists with email, passwordHash, role fields
- First super admin created via seed script
- POST /admin/auth/login accepts email+password, returns JWT tokens
- Admin refresh token has 30-day expiry in separate cookie path
- requireAdmin and requireSuperAdmin middleware work correctly
- No conflicts with existing member authentication
</success_criteria>

<output>
After completion, create `.planning/phases/10-admin-system/10-01-SUMMARY.md`
</output>
