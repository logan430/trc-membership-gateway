---
phase: 10-admin-system
plan: 03
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - src/routes/admin/config.ts
  - src/routes/admin/audit.ts
  - src/routes/admin/templates.ts
  - src/lib/feature-flags.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Admin can list all feature flags with their current state"
    - "Admin can toggle feature flags on/off"
    - "Feature flags are cached in memory with 1-minute TTL"
    - "Admin can search and filter audit logs"
    - "Admin can view audit logs for specific entity"
    - "Admin can list and edit email templates"
    - "Email template changes are logged to audit"
  artifacts:
    - path: "src/lib/feature-flags.ts"
      provides: "Feature flag service with caching"
      exports: ["isFeatureEnabled", "getAllFlags", "setFlag", "invalidateFlagCache"]
    - path: "src/routes/admin/config.ts"
      provides: "Feature flag management endpoints"
      exports: ["adminConfigRouter"]
    - path: "src/routes/admin/audit.ts"
      provides: "Audit log query endpoints"
      exports: ["adminAuditRouter"]
    - path: "src/routes/admin/templates.ts"
      provides: "Email template management endpoints"
      exports: ["adminTemplatesRouter"]
  key_links:
    - from: "src/routes/admin/config.ts"
      to: "src/lib/feature-flags.ts"
      via: "flag operations"
      pattern: "setFlag|getAllFlags"
    - from: "src/routes/admin/templates.ts"
      to: "src/lib/audit.ts"
      via: "change logging"
      pattern: "logAuditEvent"
---

<objective>
Build configuration, feature flag, audit log, and email template management APIs.

Purpose: Admins need to toggle system behaviors via feature flags, review audit history for investigations, and customize email templates without code changes.

Output: Feature flag service with caching, audit log query API with filters, email template CRUD API.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-admin-system/10-CONTEXT.md
@.planning/phases/10-admin-system/10-RESEARCH.md
@.planning/phases/10-admin-system/10-01-SUMMARY.md

# Existing email templates for seeding
@src/email/templates.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Feature flag service with caching</name>
  <files>src/lib/feature-flags.ts</files>
  <action>
1. Create src/lib/feature-flags.ts:
   - Import prisma from './prisma.js'

   - Define FeatureFlagKey type (union of known flags):
     ```typescript
     export type FeatureFlagKey =
       | 'require_introduction'        // Whether intro is required for full access
       | 'send_claim_reminders'        // Whether claim reminder emails are sent
       | 'send_billing_emails'         // Whether billing failure/recovery emails sent
       | 'send_invite_emails'          // Whether team invite emails sent
       | 'auto_fix_reconciliation'     // Whether reconciliation auto-fixes drift
       | 'enable_magic_links'          // Whether magic link login is available
       | 'enable_team_signups'         // Whether company plan signups are enabled
       | 'maintenance_mode';           // Blocks all non-admin operations
     ```

   - Define cache variables:
     ```typescript
     let flagCache: Map<string, boolean> | null = null;
     let cacheExpiry = 0;
     const CACHE_TTL = 60_000; // 1 minute per RESEARCH.md
     ```

   - isFeatureEnabled(key: FeatureFlagKey): Promise<boolean>
     - Check if cache is valid (flagCache exists AND Date.now() < cacheExpiry)
     - If not, fetch all flags from database and rebuild cache
     - Return cached value OR false if key not found (default to disabled)

   - getAllFlags(): Promise<Array<{ key, enabled, description, category, updatedAt }>>
     - Fetch all flags from database (no cache, always fresh for admin)
     - Return full flag objects

   - setFlag(key: string, enabled: boolean, adminId: string): Promise<void>
     - Upsert flag in database
     - Update updatedBy with adminId
     - Call invalidateFlagCache() immediately

   - invalidateFlagCache(): void
     - Set flagCache = null
     - Set cacheExpiry = 0

   - seedDefaultFlags(): Promise<void>
     - Create default flags if they don't exist:
       - require_introduction: true, category: 'onboarding'
       - send_claim_reminders: true, category: 'email'
       - send_billing_emails: true, category: 'email'
       - send_invite_emails: true, category: 'email'
       - auto_fix_reconciliation: false, category: 'operations'
       - enable_magic_links: true, category: 'auth'
       - enable_team_signups: true, category: 'billing'
       - maintenance_mode: false, category: 'general'
     - Use createMany with skipDuplicates
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - isFeatureEnabled returns cached values
    - setFlag updates database and invalidates cache
    - getAllFlags returns fresh data from database
  </verify>
  <done>
    - Feature flag service with 1-minute cache TTL
    - Default flags defined with sensible defaults
    - Cache invalidation on flag updates
  </done>
</task>

<task type="auto">
  <name>Task 2: Config and audit log APIs</name>
  <files>src/routes/admin/config.ts, src/routes/admin/audit.ts, src/index.ts</files>
  <action>
1. Create src/routes/admin/config.ts:
   - Import Router, z, prisma, requireAdmin, requireSuperAdmin
   - Import feature flag functions
   - Import logAuditEvent

   - GET /feature-flags:
     - Middleware: requireAdmin
     - Call getAllFlags()
     - Return { flags: [...] }

   - PATCH /feature-flags/:key:
     - Middleware: requireSuperAdmin (only super admins can change flags)
     - Define schema: { enabled: z.boolean() }
     - Get current flag state for comparison
     - Call setFlag(key, enabled, adminId)
     - Log audit event: FEATURE_FLAG_TOGGLED with old/new values
     - Return { success: true, flag: { key, enabled } }

   - POST /feature-flags/seed:
     - Middleware: requireSuperAdmin
     - Call seedDefaultFlags()
     - Return { success: true, message: 'Default flags seeded' }

   - GET /discord-channels (view only per CONTEXT.md):
     - Middleware: requireAdmin
     - Return current channel IDs from env vars (read-only info):
       - DISCORD_INTRODUCTIONS_CHANNEL_ID
       - DISCORD_BILLING_SUPPORT_CHANNEL_ID
       - DISCORD_ADMIN_ALERTS_CHANNEL_ID
     - Note in response: "Channel IDs are configured via environment variables"

2. Create src/routes/admin/audit.ts:
   - Import Router, z, prisma, requireAdmin

   - Define querySchema:
     - cursor: z.string().optional()
     - limit: z.coerce.number().min(1).max(100).default(50)
     - action: z.string().optional()
     - entityType: z.string().optional()
     - entityId: z.string().optional()
     - performedBy: z.string().optional()
     - startDate: z.coerce.date().optional()
     - endDate: z.coerce.date().optional()
     - search: z.string().optional() (searches in details JSON)

   - GET /:
     - Middleware: requireAdmin
     - Parse query with querySchema
     - Build Prisma where clause with filters
     - Use cursor-based pagination
     - orderBy: { createdAt: 'desc' }
     - Return { logs, nextCursor, hasMore }

   - GET /actions:
     - Middleware: requireAdmin
     - Return distinct action types for filter dropdown
     - Use prisma.auditLog.findMany with distinct: ['action']

   - GET /entity-types:
     - Middleware: requireAdmin
     - Return distinct entity types for filter dropdown

3. Update src/index.ts:
   - Import adminConfigRouter and adminAuditRouter
   - Mount adminConfigRouter at /admin/config
   - Mount adminAuditRouter at /admin/audit
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - GET /admin/config/feature-flags returns flag list
    - PATCH /admin/config/feature-flags/:key toggles flag and logs audit
    - GET /admin/audit returns paginated, filterable logs
  </verify>
  <done>
    - Feature flags manageable via API (super admin only for changes)
    - Audit logs searchable with multiple filter options
    - Discord channel IDs visible but read-only
  </done>
</task>

<task type="auto">
  <name>Task 3: Email template management API</name>
  <files>src/routes/admin/templates.ts, src/index.ts</files>
  <action>
1. Create src/routes/admin/templates.ts:
   - Import Router, z, prisma, requireAdmin, requireSuperAdmin
   - Import logAuditEvent

   - GET /:
     - Middleware: requireAdmin
     - Fetch all EmailTemplate records
     - Return { templates: [...] }

   - GET /:name:
     - Middleware: requireAdmin
     - Find template by name
     - If not found: 404
     - Return { template }

   - PUT /:name:
     - Middleware: requireSuperAdmin
     - Define schema:
       - subject: z.string().min(1).max(200)
       - body: z.string().min(1).max(10000)
     - Upsert template (create if doesn't exist)
     - Set updatedBy to admin ID
     - Log audit event: EMAIL_TEMPLATE_UPDATED with old/new preview
     - Return { success: true, template }

   - POST /seed:
     - Middleware: requireSuperAdmin
     - Create default templates from current hardcoded templates:
       - welcome: Welcome email
       - claim_reminder: Claim reminder
       - claim_reminder_cheeky: Cheeky 30+ day reminder
       - payment_failure: Payment failure
       - payment_recovered: Payment recovered
       - payment_recovered_debtor: Recovery from debtor state
       - seat_invite: Team seat invitation
       - reconciliation_report: Reconciliation notification
     - Use createMany with skipDuplicates
     - Return { success: true, created: N }

   - GET /:name/preview:
     - Middleware: requireAdmin
     - Find template
     - Define sample data for each template type
     - Replace {{variables}} with sample values
     - Return { preview: { subject, body } }

2. Update src/index.ts:
   - Import adminTemplatesRouter
   - Mount at /admin/templates

3. Consider: Update src/email/send.ts to check database templates first:
   - Helper function getTemplate(name: string) that:
     - Checks database for custom template
     - Falls back to hardcoded template if not found
   - This allows gradual migration without breaking existing code
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - GET /admin/templates returns template list
    - PUT /admin/templates/:name updates template and logs audit
    - GET /admin/templates/:name/preview shows variable substitution
  </verify>
  <done>
    - Email templates stored in database
    - Templates editable by super admins
    - Preview endpoint for testing variable substitution
    - Seed endpoint populates default templates
    - Changes logged to audit
  </done>
</task>

</tasks>

<verification>
1. Feature flags: GET /admin/config/feature-flags returns all flags
2. Toggle: PATCH /admin/config/feature-flags/:key updates flag (super admin only)
3. Audit list: GET /admin/audit returns paginated logs
4. Audit filter: Filters by action, entityType, date range work correctly
5. Templates list: GET /admin/templates returns all templates
6. Template edit: PUT /admin/templates/:name updates and logs change
7. Template preview: GET /admin/templates/:name/preview shows sample output
</verification>

<success_criteria>
- Feature flag service caches flags with 1-minute TTL
- Flag changes invalidate cache immediately
- Only super admins can modify feature flags
- Audit logs queryable with cursor pagination and multiple filters
- Email templates stored in database and editable
- Template changes logged to audit
- Preview endpoint shows variable substitution with sample data
</success_criteria>

<output>
After completion, create `.planning/phases/10-admin-system/10-03-SUMMARY.md`
</output>
