---
phase: 22-operational-readiness
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/instrument.ts
  - src/index.ts
  - src/config/env.ts
  - package.json
autonomous: true
user_setup:
  - service: sentry
    why: "Error monitoring and alerting for production"
    env_vars:
      - name: SENTRY_DSN
        source: "Sentry Dashboard -> Settings -> Client Keys (DSN)"
    dashboard_config:
      - task: "Create Sentry project for Node.js/Express"
        location: "Sentry -> Projects -> Create Project -> Node.js"

must_haves:
  truths:
    - "Sentry captures unhandled errors in production"
    - "Sentry is disabled in development/test"
    - "Express errors are captured with stack traces"
    - "SENTRY_DSN is optional (app runs without it)"
  artifacts:
    - path: "src/instrument.ts"
      provides: "Sentry initialization"
      contains: "Sentry.init"
    - path: "src/config/env.ts"
      provides: "SENTRY_DSN optional env var"
      contains: "SENTRY_DSN"
  key_links:
    - from: "src/instrument.ts"
      to: "Sentry SDK"
      via: "import * as Sentry"
      pattern: "@sentry/node"
    - from: "src/index.ts"
      to: "Sentry error handler"
      via: "Sentry.setupExpressErrorHandler"
      pattern: "setupExpressErrorHandler"
---

<objective>
Integrate Sentry error monitoring for production error tracking

Purpose: Capture and aggregate runtime errors in production. Sentry provides error deduplication, stack traces, release tracking, and alerting - critical for identifying issues users encounter. Without it, errors are only visible in logs which requires active monitoring.

Output: Sentry integration that captures Express errors and unhandled exceptions, disabled in dev/test, with optional SENTRY_DSN configuration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/22-operational-readiness/22-RESEARCH.md
@src/index.ts
@src/config/env.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Sentry SDK and add env var</name>
  <files>package.json, src/config/env.ts</files>
  <action>
1. Install Sentry Node.js SDK:
   ```bash
   npm install @sentry/node
   ```

2. Add SENTRY_DSN to src/config/env.ts as OPTIONAL string:
   ```typescript
   // In the Zod schema, add:
   SENTRY_DSN: z.string().optional(),
   ```

   Place it near other optional config or at the end of the schema.

3. Update .env.example (if it exists) with:
   ```env
   # Error Monitoring (optional - Sentry)
   # Get DSN from: Sentry Dashboard -> Settings -> Client Keys (DSN)
   SENTRY_DSN=
   ```

Key points:
- SENTRY_DSN is OPTIONAL - app must work without it
- No default value - empty means disabled
- Sentry free tier: 5K errors/month, sufficient for MVP
  </action>
  <verify>
Run `npm install` to verify package installed.
Check package.json includes @sentry/node.
Check src/config/env.ts has SENTRY_DSN in schema.
  </verify>
  <done>
- @sentry/node installed in package.json
- SENTRY_DSN added to env.ts as optional string
- .env.example updated with SENTRY_DSN placeholder
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Sentry instrument file</name>
  <files>src/instrument.ts</files>
  <action>
Create src/instrument.ts for Sentry initialization.

Per Sentry ESM/TypeScript docs, this file will be imported first via --import flag.

```typescript
// src/instrument.ts
// This file initializes Sentry and MUST be imported before other modules.
// Use: node --import ./dist/instrument.js dist/index.js

import * as Sentry from '@sentry/node';

// Only initialize if DSN is provided and we're in production
const dsn = process.env.SENTRY_DSN;
const isProduction = process.env.NODE_ENV === 'production';

if (dsn && isProduction) {
  Sentry.init({
    dsn,
    environment: process.env.NODE_ENV,
    tracesSampleRate: 0.1, // 10% of transactions for performance monitoring
    // Optionally filter out expected errors
    beforeSend(event) {
      // Don't send if it's a known expected error
      // Example: if (event.exception?.values?.[0]?.type === 'SomeExpectedError') return null;
      return event;
    },
  });

  console.log('Sentry initialized for production error tracking');
}
```

Key implementation notes from RESEARCH.md:
- Only enable in production (not dev/test)
- 10% tracesSampleRate keeps costs low while providing performance data
- beforeSend hook available for filtering if needed later
- Console.log is OK here since this runs before pino is initialized
  </action>
  <verify>
Run `npm run build` to verify TypeScript compiles.
Check dist/instrument.js is created.
  </verify>
  <done>
- src/instrument.ts exists
- Sentry.init() called only when SENTRY_DSN is set AND NODE_ENV=production
- tracesSampleRate set to 0.1
- Build passes
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Sentry Express error handler to index.ts</name>
  <files>src/index.ts</files>
  <action>
Update src/index.ts to add Sentry's Express error handler.

1. Add import at top of file:
   ```typescript
   import * as Sentry from '@sentry/node';
   ```

2. Add Sentry Express error handler AFTER all routes but BEFORE the 404 catch-all handler:

   Find this section:
   ```typescript
   // Public routes (landing page - mounted last so named routes take precedence)
   app.use(publicRouter);

   // 404 catch-all - must be LAST route
   ```

   Insert BETWEEN them:
   ```typescript
   // Public routes (landing page - mounted last so named routes take precedence)
   app.use(publicRouter);

   // Sentry error handler - captures Express errors for monitoring
   // Must be after all routes but before 404 handler
   Sentry.setupExpressErrorHandler(app);

   // 404 catch-all - must be LAST route
   ```

3. Update package.json scripts for production start with Sentry instrumentation:

   In package.json scripts section, update or add:
   ```json
   "start": "node dist/index.js",
   "start:prod": "node --import ./dist/instrument.js dist/index.js"
   ```

   Keep the simple "start" for backwards compatibility; use "start:prod" for Sentry-enabled production.

Key notes from RESEARCH.md:
- Sentry.setupExpressErrorHandler(app) MUST come after routes
- This captures errors thrown in route handlers
- The 404 handler must still be last (it's not an error handler)
  </action>
  <verify>
Run `npm run build` to verify TypeScript compiles.
Check src/index.ts has Sentry import and setupExpressErrorHandler call.
Check package.json has start:prod script.
  </verify>
  <done>
- src/index.ts imports @sentry/node
- Sentry.setupExpressErrorHandler(app) called after routes
- 404 handler remains last
- package.json has start:prod script with --import flag
- Build passes without errors
  </done>
</task>

</tasks>

<verification>
After completion:

1. Build verification:
   ```bash
   npm run build
   ```
   Should complete without TypeScript errors.

2. File verification:
   - src/instrument.ts exists with Sentry.init()
   - src/config/env.ts has SENTRY_DSN optional
   - src/index.ts has Sentry import and setupExpressErrorHandler

3. Configuration verification:
   - package.json has @sentry/node in dependencies
   - package.json has start:prod script
   - .env.example has SENTRY_DSN placeholder

4. Conditional initialization:
   - Review src/instrument.ts confirms Sentry only initializes when:
     - SENTRY_DSN is set AND
     - NODE_ENV === 'production'
</verification>

<success_criteria>
- @sentry/node installed
- src/instrument.ts created with conditional init
- SENTRY_DSN added as optional env var
- Express error handler integrated in src/index.ts
- start:prod script added for production with instrumentation
- Build passes without errors
- App still runs without SENTRY_DSN (graceful degradation)
</success_criteria>

<output>
After completion, create `.planning/phases/22-operational-readiness/22-02-SUMMARY.md`
</output>
