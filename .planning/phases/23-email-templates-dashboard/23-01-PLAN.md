---
phase: 23-email-templates-dashboard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/email/template-fetcher.ts
  - src/email/send.ts
  - src/routes/admin/templates.ts
autonomous: true

must_haves:
  truths:
    - "Email sending uses database templates when available"
    - "Email sending falls back to hardcoded templates when database template is missing"
    - "Admin can reset a template to default content"
    - "All admins (not just super admin) can edit templates"
    - "Template edits are logged in audit log"
  artifacts:
    - path: "src/email/template-fetcher.ts"
      provides: "Template lookup with DB-first, hardcoded fallback"
      exports: ["getTemplate", "DEFAULT_TEMPLATES", "TEMPLATE_VARIABLES"]
    - path: "src/email/send.ts"
      provides: "Email sending using database templates"
      contains: "getTemplate"
    - path: "src/routes/admin/templates.ts"
      provides: "Reset endpoint and permission change"
      exports: ["adminTemplatesRouter"]
  key_links:
    - from: "src/email/send.ts"
      to: "src/email/template-fetcher.ts"
      via: "import getTemplate"
      pattern: "import.*getTemplate.*template-fetcher"
    - from: "src/email/template-fetcher.ts"
      to: "prisma.emailTemplate"
      via: "database query"
      pattern: "prisma\\.emailTemplate\\.findUnique"
    - from: "src/routes/admin/templates.ts"
      to: "src/email/template-fetcher.ts"
      via: "import DEFAULT_TEMPLATES"
      pattern: "import.*DEFAULT_TEMPLATES.*template-fetcher"
---

<objective>
Wire database email templates to the actual email sending system and add administrative capabilities.

Purpose: Close the critical integration gap where email sending uses hardcoded templates instead of admin-editable database templates. Also enable all admins to edit templates (not just super admin) and add reset-to-default functionality.

Output: Email system that respects admin template edits, plus new reset API endpoint.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-email-templates-dashboard/23-CONTEXT.md
@.planning/phases/23-email-templates-dashboard/23-RESEARCH.md

# Existing email infrastructure
@src/email/send.ts
@src/email/templates.ts
@src/email/provider.ts
@src/routes/admin/templates.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create template fetcher with database-first lookup</name>
  <files>src/email/template-fetcher.ts</files>
  <action>
Create new file `src/email/template-fetcher.ts` that provides:

1. **DEFAULT_TEMPLATES constant** - Move the DEFAULT_TEMPLATES array from `routes/admin/templates.ts` to this file. This becomes the single source of truth for default template content.

2. **TEMPLATE_VARIABLES constant** - Define known variables per template:
```typescript
export const TEMPLATE_VARIABLES: Record<string, string[]> = {
  welcome: ['claimUrl'],
  claim_reminder: ['claimUrl'],
  claim_reminder_cheeky: ['claimUrl'],
  payment_failure: ['gracePeriodHours', 'portalUrl'],
  payment_recovered: [],
  payment_recovered_debtor: [],
  seat_invite: ['teamName', 'claimUrl', 'seatTier'],
  reconciliation_report: ['issuesFound', 'fixStatus', 'summaryText', 'runId'],
};
```

3. **getTemplate function**:
```typescript
export async function getTemplate(
  name: string,
  variables: Record<string, string>
): Promise<{ subject: string; text: string }>
```
- Try prisma.emailTemplate.findUnique({ where: { name } }) first
- If found, substitute variables using regex `\{\{key\}\}` -> value
- If not found in DB, look up in DEFAULT_TEMPLATES and substitute
- If not found anywhere, throw Error(`Template '${name}' not found`)
- Return { subject, text } (use 'text' not 'body' to match provider.send interface)

4. **validateVariables function** (for admin API to use):
```typescript
export function validateVariables(
  templateName: string,
  content: string
): { valid: boolean; unknownVariables: string[] }
```
- Extract all `{{variableName}}` from content using regex
- Compare against TEMPLATE_VARIABLES[templateName]
- Return list of unknown variables

Import prisma from '../lib/prisma.js'. Follow existing ES module patterns with .js extensions.
  </action>
  <verify>
TypeScript compiles without errors: `npx tsc --noEmit`
File exports getTemplate, DEFAULT_TEMPLATES, TEMPLATE_VARIABLES, validateVariables
  </verify>
  <done>
Template fetcher module exists with database-first lookup and variable validation
  </done>
</task>

<task type="auto">
  <name>Task 2: Update email send functions to use database templates</name>
  <files>src/email/send.ts</files>
  <action>
Modify `src/email/send.ts` to use the new template fetcher instead of hardcoded template functions:

1. **Remove imports** of individual template functions from './templates.js':
   - Remove: welcomeEmailTemplate, claimReminderEmailTemplate, paymentFailureEmailTemplate, paymentRecoveredEmailTemplate, seatInviteEmailTemplate, reconciliationReportEmailTemplate

2. **Add import** from './template-fetcher.js':
   - Add: `import { getTemplate } from './template-fetcher.js';`

3. **Update sendWelcomeEmail**:
```typescript
export async function sendWelcomeEmail(email: string, claimUrl: string): Promise<EmailResult> {
  const { subject, text } = await getTemplate('welcome', { claimUrl });
  const result = await emailProvider.send({ to: email, subject, text });
  logger.info({ email, success: result.success }, 'Welcome email sent');
  return result;
}
```

4. **Update sendClaimReminderEmail**:
- Use 'claim_reminder' for daysSincePurchase < 30
- Use 'claim_reminder_cheeky' for daysSincePurchase >= 30
```typescript
const templateName = daysSincePurchase >= 30 ? 'claim_reminder_cheeky' : 'claim_reminder';
const { subject, text } = await getTemplate(templateName, { claimUrl });
```

5. **Update sendPaymentFailureEmail**:
```typescript
const { subject, text } = await getTemplate('payment_failure', {
  gracePeriodHours: String(gracePeriodHours),
  portalUrl,
});
```

6. **Update sendPaymentRecoveredEmail**:
- Use 'payment_recovered' if !wasInDebtorState
- Use 'payment_recovered_debtor' if wasInDebtorState
```typescript
const templateName = wasInDebtorState ? 'payment_recovered_debtor' : 'payment_recovered';
const { subject, text } = await getTemplate(templateName, {});
```

7. **Update sendSeatInviteEmail**:
```typescript
const { subject, text } = await getTemplate('seat_invite', {
  teamName,
  claimUrl,
  seatTier,
});
```

8. **Update sendReconciliationReportEmail**:
Build summaryText and fixStatus strings as before (keep existing logic), then:
```typescript
const { subject, text } = await getTemplate('reconciliation_report', {
  runId: result.runId,
  issuesFound: String(result.issuesFound),
  fixStatus,
  summaryText: summaryLines.join('\n'),
});
```

Note: Keep the existing file `src/email/templates.ts` - it serves as fallback reference and may be useful for testing. The template-fetcher.ts file has its own DEFAULT_TEMPLATES that mirror it.
  </action>
  <verify>
TypeScript compiles without errors: `npx tsc --noEmit`
Running `EMAIL_PROVIDER=console npm run dev` and triggering an email flow shows template content from database (or default fallback)
  </verify>
  <done>
All email send functions use getTemplate() for database-first template lookup with hardcoded fallback
  </done>
</task>

<task type="auto">
  <name>Task 3: Add reset endpoint and change edit permissions</name>
  <files>src/routes/admin/templates.ts</files>
  <action>
Modify `src/routes/admin/templates.ts`:

1. **Update imports** - add import from template-fetcher:
```typescript
import { DEFAULT_TEMPLATES, TEMPLATE_VARIABLES, validateVariables } from '../../email/template-fetcher.js';
```

2. **Remove local DEFAULT_TEMPLATES** - delete the entire DEFAULT_TEMPLATES array (lines ~117-293) since it's now in template-fetcher.ts.

3. **Update SAMPLE_DATA** - keep it here for preview functionality (it has realistic example values different from TEMPLATE_VARIABLES).

4. **Change PUT permission** - Remove `requireSuperAdmin` from the PUT route:
```typescript
// Before:
adminTemplatesRouter.put('/:name', requireAdmin, requireSuperAdmin, async (req, res) => {

// After:
adminTemplatesRouter.put('/:name', requireAdmin, async (req, res) => {
```
This allows all admins to edit templates per CONTEXT.md decision.

5. **Add variable validation to PUT** - After parsing request body, validate variables:
```typescript
const subjectValidation = validateVariables(name, subject);
const bodyValidation = validateVariables(name, body);
const unknownVariables = [
  ...subjectValidation.unknownVariables,
  ...bodyValidation.unknownVariables,
];

// Include warning in response (don't block save, just warn)
```

Update the response to include:
```typescript
res.json({
  success: true,
  template,
  warning: unknownVariables.length > 0
    ? `Unknown variables detected: ${unknownVariables.join(', ')}`
    : undefined,
});
```

6. **Add reset endpoint** - Add new route after the PUT route:
```typescript
/**
 * POST /admin/templates/:name/reset
 * Reset template to default content
 */
adminTemplatesRouter.post('/:name/reset', requireAdmin, async (req, res) => {
  const name = req.params.name as string;
  const admin = res.locals.admin!;

  // Find default template
  const defaultTemplate = DEFAULT_TEMPLATES.find(t => t.name === name);
  if (!defaultTemplate) {
    res.status(404).json({ error: 'No default template exists for this name' });
    return;
  }

  // Get current for audit comparison
  const currentTemplate = await prisma.emailTemplate.findUnique({
    where: { name },
  });

  // Upsert with default values
  const template = await prisma.emailTemplate.upsert({
    where: { name },
    update: {
      subject: defaultTemplate.subject,
      body: defaultTemplate.body,
      updatedBy: admin.id,
    },
    create: {
      name: defaultTemplate.name,
      subject: defaultTemplate.subject,
      body: defaultTemplate.body,
      updatedBy: admin.id,
    },
  });

  // Log audit event
  await logAuditEvent({
    action: AuditAction.EMAIL_TEMPLATE_RESET,
    entityType: 'EmailTemplate',
    entityId: name,
    details: {
      previousSubject: currentTemplate?.subject || null,
      resetTo: 'default',
    },
    performedBy: admin.id,
  });

  res.json({
    success: true,
    template,
    message: 'Template reset to default',
  });
});
```

7. **Add audit action** - If EMAIL_TEMPLATE_RESET doesn't exist in AuditAction enum, it should be added. Check `src/lib/audit.ts` for the enum and add if missing.

8. **Add GET endpoint for available variables** - Add helper endpoint:
```typescript
/**
 * GET /admin/templates/:name/variables
 * Get available variables for a template
 */
adminTemplatesRouter.get('/:name/variables', requireAdmin, async (req, res) => {
  const name = req.params.name as string;
  const variables = TEMPLATE_VARIABLES[name] || [];
  res.json({ variables });
});
```
  </action>
  <verify>
TypeScript compiles without errors: `npx tsc --noEmit`
Reset endpoint is registered (check route list in console output)
PUT no longer requires super admin (test with regular admin token)
  </verify>
  <done>
Reset endpoint exists, all admins can edit, variable validation returns warnings
  </done>
</task>

</tasks>

<verification>
After all tasks:

1. **TypeScript compiles**: `npx tsc --noEmit` succeeds
2. **Email flow works**:
   - Start server with `EMAIL_PROVIDER=console npm run dev`
   - Template content appears in console when email would be sent
3. **Reset endpoint works**:
   - `POST /api/admin/templates/welcome/reset` returns 200 with default content
4. **Permission change verified**:
   - Regular admin (not super admin) can PUT to `/api/admin/templates/:name`
5. **Variable validation works**:
   - PUT with `{{typo}}` in body returns success with warning about unknown variable
</verification>

<success_criteria>
- Email sending uses database templates with hardcoded fallback
- All admins can edit templates (not just super admin)
- Reset-to-default endpoint exists at POST /api/admin/templates/:name/reset
- Variable validation warns about unknown variables on save
- Existing email flows continue to work (welcome, claim reminder, billing, invites)
</success_criteria>

<output>
After completion, create `.planning/phases/23-email-templates-dashboard/23-01-SUMMARY.md`
</output>
