---
phase: 26-database-schema-extension
plan: 03
type: execute
wave: 3
depends_on: ["26-02"]
files_modified:
  - prisma/migrations/
  - prisma/schema.prisma
autonomous: true

must_haves:
  truths:
    - "Points trigger automatically updates Member.totalPoints on PointTransaction insert"
    - "All migrations run successfully on development database"
    - "GIN index exists and supports JSONB containment queries"
    - "Prisma client is regenerated with new model types"
  artifacts:
    - path: "prisma/migrations/*_add_points_trigger/migration.sql"
      provides: "Trigger function and trigger"
      contains: "CREATE TRIGGER"
    - path: "node_modules/.prisma/client"
      provides: "Generated Prisma client"
  key_links:
    - from: "PointTransaction INSERT"
      to: "Member.totalPoints"
      via: "database trigger"
      pattern: "trg_update_member_points"
    - from: "BenchmarkSubmission.data"
      to: "GIN index"
      via: "JSONB containment query"
      pattern: "@>"
---

<objective>
Create the points trigger migration, run all migrations, and verify the complete schema works correctly.

Purpose: The trigger (DB-07) is critical for gamification - it guarantees Member.totalPoints stays consistent with PointTransaction records without application code coordination. Running migrations validates the zero-downtime patterns work.

Output: Fully migrated development database with trigger, indexes, and verified schema.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/26-database-schema-extension/26-RESEARCH.md
@.planning/phases/26-database-schema-extension/26-01-SUMMARY.md
@.planning/phases/26-database-schema-extension/26-02-SUMMARY.md

@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create points trigger migration</name>
  <files>prisma/migrations/</files>
  <action>
Create the database trigger that auto-updates Member.totalPoints when PointTransaction is inserted (DB-07).

**1. Create migration folder (after all index migrations):**

If last index migration is 20260122190017, create 20260122190018_add_points_trigger.

```bash
mkdir -p "prisma/migrations/20260122190018_add_points_trigger"
```

**2. Create migration.sql with trigger function and trigger:**

```sql
-- Create function to update denormalized totalPoints (DB-07)
CREATE OR REPLACE FUNCTION update_member_total_points()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE "Member"
  SET
    "totalPoints" = "totalPoints" + NEW.points,
    "lastActiveAt" = CASE
      WHEN NEW.points > 0 THEN NOW()
      ELSE "lastActiveAt"
    END,
    "updatedAt" = NOW()
  WHERE id = NEW."memberId";
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger that fires after every PointTransaction insert
CREATE TRIGGER trg_update_member_points
  AFTER INSERT ON "PointTransaction"
  FOR EACH ROW
  EXECUTE FUNCTION update_member_total_points();

-- Add comment for documentation
COMMENT ON FUNCTION update_member_total_points() IS 'Automatically updates Member.totalPoints and lastActiveAt when points are awarded. Part of v2.0 gamification system (DB-07).';
```

**Notes:**
- Trigger fires AFTER INSERT to ensure PointTransaction is committed first
- Only updates lastActiveAt for positive point awards (not admin deductions)
- Uses NEW.memberId to find the correct member
- Updates updatedAt for change tracking
  </action>
  <verify>
`cat prisma/migrations/*_add_points_trigger/migration.sql | grep -c "CREATE"` returns at least 2 (function + trigger).
`cat prisma/migrations/*_add_points_trigger/migration.sql | grep "AFTER INSERT"` shows trigger definition.
  </verify>
  <done>
Points trigger migration created. Will automatically update Member.totalPoints on every PointTransaction insert.
  </done>
</task>

<task type="auto">
  <name>Task 2: Run all migrations on development database</name>
  <files>prisma/schema.prisma</files>
  <action>
Apply all migrations to the development database and regenerate Prisma client.

**1. Run migrations:**
```bash
npx prisma migrate dev
```

This will:
- Apply all pending migrations in order
- Regenerate the Prisma client with new types
- May prompt for migration name if baseline wasn't set

**If migration fails with concurrent index error:**
Prisma sometimes wraps migrations in transactions. If a concurrent index migration fails:
1. Check the error message for which index failed
2. Verify that migration file has exactly ONE statement
3. Drop any invalid indexes:
   ```sql
   DROP INDEX IF EXISTS "index_name";
   ```
4. Rerun the migration

**2. Verify Prisma client regenerated:**
```bash
npx prisma generate
```

**3. Check migration status:**
```bash
npx prisma migrate status
```

Should show all migrations as "applied".

**Expected output:**
- All 18+ migrations applied
- Prisma client generated with new model types
- No errors or warnings
  </action>
  <verify>
`npx prisma migrate status` shows all migrations applied (no pending).
`npx prisma generate` completes without errors.
TypeScript compilation: `npx tsc --noEmit` passes (types are correct).
  </verify>
  <done>
All migrations applied. Prisma client regenerated with BenchmarkSubmission, Resource, ResourceDownload, PointTransaction, DiscordActivity types.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify schema, trigger, and indexes work correctly</name>
  <files>prisma/schema.prisma</files>
  <action>
Run verification queries to confirm all DB requirements are met.

**1. Verify tables exist (DB-01 through DB-05):**
```bash
npx prisma db execute --stdin <<'EOF'
SELECT table_name FROM information_schema.tables
WHERE table_schema = 'public'
AND table_name IN ('BenchmarkSubmission', 'Resource', 'ResourceDownload', 'PointTransaction', 'DiscordActivity')
ORDER BY table_name;
EOF
```
Expected: 5 rows (all 5 tables)

**2. Verify Member columns (DB-06):**
```bash
npx prisma db execute --stdin <<'EOF'
SELECT column_name, data_type, column_default
FROM information_schema.columns
WHERE table_name = 'Member'
AND column_name IN ('totalPoints', 'currentStreak', 'lastActiveAt')
ORDER BY column_name;
EOF
```
Expected: 3 rows with correct types (integer, integer, timestamp)

**3. Verify GIN index exists (DB-08):**
```bash
npx prisma db execute --stdin <<'EOF'
SELECT indexname, indexdef FROM pg_indexes
WHERE tablename = 'BenchmarkSubmission'
AND indexdef LIKE '%gin%';
EOF
```
Expected: 1 row showing GIN index on data column

**4. Verify trigger exists and works (DB-07):**
```bash
npx prisma db execute --stdin <<'EOF'
-- Check trigger exists
SELECT trigger_name, event_manipulation, action_statement
FROM information_schema.triggers
WHERE trigger_name = 'trg_update_member_points';
EOF
```
Expected: 1 row showing AFTER INSERT trigger

**5. Test trigger functionality:**
Create a test script `scripts/test-points-trigger.ts`:
```typescript
import { prisma } from '../src/lib/prisma';

async function testPointsTrigger() {
  // Create or find a test member
  const member = await prisma.member.upsert({
    where: { email: 'trigger-test@example.com' },
    create: { email: 'trigger-test@example.com', totalPoints: 0 },
    update: { totalPoints: 0 },
  });

  console.log('Before:', member.totalPoints);

  // Insert a point transaction
  await prisma.pointTransaction.create({
    data: {
      memberId: member.id,
      action: 'test',
      points: 50,
      metadata: { test: true },
    },
  });

  // Check if totalPoints was updated by trigger
  const updated = await prisma.member.findUnique({
    where: { id: member.id }
  });

  console.log('After:', updated?.totalPoints);

  if (updated?.totalPoints === 50) {
    console.log('PASS: Trigger correctly updated totalPoints');
  } else {
    console.log('FAIL: Expected 50, got', updated?.totalPoints);
  }

  // Cleanup
  await prisma.pointTransaction.deleteMany({
    where: { memberId: member.id }
  });
  await prisma.member.delete({ where: { id: member.id } });

  console.log('Cleanup complete');
}

testPointsTrigger()
  .catch(console.error)
  .finally(() => prisma.$disconnect());
```

Run: `npx tsx scripts/test-points-trigger.ts`

**6. Test GIN index query:**
```bash
npx prisma db execute --stdin <<'EOF'
EXPLAIN (ANALYZE, FORMAT TEXT)
SELECT * FROM "BenchmarkSubmission"
WHERE data @> '{"salary": 100000}'::jsonb;
EOF
```
Expected: Query plan shows "Bitmap Index Scan" on the GIN index (if data exists) or just the index scan plan.

**7. Verify all foreign keys (DB-09):**
```bash
npx prisma db execute --stdin <<'EOF'
SELECT conname, conrelid::regclass, confrelid::regclass
FROM pg_constraint
WHERE contype = 'f'
AND conrelid::regclass::text IN ('BenchmarkSubmission', 'ResourceDownload', 'PointTransaction', 'DiscordActivity')
ORDER BY conname;
EOF
```
Expected: 5 foreign key constraints all referencing Member (or Resource for ResourceDownload)
  </action>
  <verify>
5 new tables exist.
Member has totalPoints, currentStreak, lastActiveAt columns.
GIN index exists on BenchmarkSubmission.data.
Points trigger exists and fires on INSERT.
Test script shows trigger correctly updates totalPoints.
All foreign keys are valid (not in NOT VALID state).
  </verify>
  <done>
All 10 DB requirements verified:
- DB-01: BenchmarkSubmission table with JSONB data
- DB-02: Resource table with category taxonomy
- DB-03: ResourceDownload table tracks download events
- DB-04: PointTransaction immutable ledger
- DB-05: DiscordActivity table for MEE6 XP sync
- DB-06: Member extended with totalPoints, currentStreak, lastActiveAt
- DB-07: Trigger auto-updates Member.totalPoints
- DB-08: GIN index on BenchmarkSubmission.data
- DB-09: All foreign keys to Member established
- DB-10: Zero-downtime patterns (concurrent indexes, NOT VALID FKs) used
  </done>
</task>

</tasks>

<verification>
1. All 18+ migrations applied successfully
2. Prisma client regenerated with new types
3. `npx tsc --noEmit` passes
4. Trigger test shows totalPoints auto-updates
5. GIN index exists and supports @> queries
6. Foreign keys validated (not in NOT VALID state)
</verification>

<success_criteria>
- DB-07 (trigger): INSERT into PointTransaction automatically increments Member.totalPoints
- Schema complete: All 5 new models accessible via Prisma client
- Type safety: TypeScript compilation passes with new types
- Indexes active: GIN index on BenchmarkSubmission.data is usable
- FK integrity: All foreign keys fully validated (constraint enforcement active)
- Ready for Phase 27: Points system backend can use PointTransaction model
</success_criteria>

<output>
After completion, create `.planning/phases/26-database-schema-extension/26-03-SUMMARY.md`
</output>
