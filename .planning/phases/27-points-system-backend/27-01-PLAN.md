---
phase: 27-points-system-backend
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - prisma/migrations/*/migration.sql
  - src/points/config.ts
  - src/points/types.ts
  - src/routes/admin/points-config.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Admin can configure point values per action type"
    - "Point values load from database with caching"
    - "Default point values seeded on first run"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "PointConfig model"
      contains: "model PointConfig"
    - path: "src/points/config.ts"
      provides: "Point value lookup with caching"
      exports: ["getPointValue", "isActionEnabled", "invalidateConfigCache"]
    - path: "src/points/types.ts"
      provides: "Point action constants and types"
      exports: ["PointAction", "PointActionType", "PointActionLabels"]
    - path: "src/routes/admin/points-config.ts"
      provides: "Admin API for point configuration"
      exports: ["adminPointsConfigRouter"]
  key_links:
    - from: "src/points/config.ts"
      to: "prisma.pointConfig"
      via: "database query with cache"
      pattern: "prisma\\.pointConfig\\.findMany"
    - from: "src/routes/admin/points-config.ts"
      to: "src/points/config.ts"
      via: "invalidateConfigCache on update"
      pattern: "invalidateConfigCache"
---

<objective>
Create point configuration system with admin-manageable values

Purpose: Allow admins to configure point values per action type without code changes. Values cached for performance with 1-minute TTL (matching FeatureFlag pattern).

Output: PointConfig model, config service with caching, admin API for CRUD operations, seeded defaults (+50 benchmark, +5 download, +1 XP, +25 intro)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-points-system-backend/27-RESEARCH.md
@.planning/phases/27-points-system-backend/27-CONTEXT.md

# Existing patterns to follow
@src/lib/feature-flags.ts
@src/lib/audit.ts
@src/routes/admin/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PointConfig schema and migration</name>
  <files>prisma/schema.prisma, prisma/migrations/*/migration.sql</files>
  <action>
Add PointConfig model to prisma/schema.prisma (after FeatureFlag model):

```prisma
model PointConfig {
  id          String   @id @default(cuid())
  action      String   @unique  // "benchmark_submission", "resource_download", etc.
  points      Int                // Point value for this action
  enabled     Boolean  @default(true)  // Toggle per action
  label       String             // Human-readable: "Benchmark Submission"
  description String?            // Optional admin notes
  updatedAt   DateTime @updatedAt
  updatedBy   String?            // Admin ID who last updated

  @@index([action])
}
```

Run `npx prisma migrate dev --name add_point_config --create-only` to create migration without applying.

Edit the generated migration to use IF NOT EXISTS pattern (matches 26-02 patterns):
- CREATE TABLE IF NOT EXISTS "PointConfig"
- CREATE UNIQUE INDEX IF NOT EXISTS on action

Apply migration with `npx prisma migrate dev`.

Generate client with `npx prisma generate`.
  </action>
  <verify>
- `npx prisma migrate status` shows all migrations applied
- `npx prisma studio` opens and shows empty PointConfig table
  </verify>
  <done>PointConfig table exists in database with unique constraint on action column</done>
</task>

<task type="auto">
  <name>Task 2: Create point types and config service</name>
  <files>src/points/types.ts, src/points/config.ts</files>
  <action>
Create `src/points/` directory and two files:

**src/points/types.ts:**
```typescript
// Point action type constants - matches PointTransaction.action values
export const PointAction = {
  BENCHMARK_SUBMISSION: 'benchmark_submission',
  RESOURCE_DOWNLOAD: 'resource_download',
  DISCORD_ACTIVITY: 'discord_activity',
  INTRO_COMPLETED: 'intro_completed',
  ADMIN_ADJUSTMENT: 'admin_adjustment',
} as const;

export type PointActionType = (typeof PointAction)[keyof typeof PointAction];

// Human-readable labels for UI display
export const PointActionLabels: Record<PointActionType, string> = {
  benchmark_submission: 'Benchmark Submission',
  resource_download: 'Resource Download',
  discord_activity: 'Discord Activity',
  intro_completed: 'Introduction Completed',
  admin_adjustment: 'Admin Adjustment',
};

// Configurable actions (admin_adjustment is not configurable)
export const CONFIGURABLE_ACTIONS = [
  PointAction.BENCHMARK_SUBMISSION,
  PointAction.RESOURCE_DOWNLOAD,
  PointAction.DISCORD_ACTIVITY,
  PointAction.INTRO_COMPLETED,
] as const;
```

**src/points/config.ts:**
Follow FeatureFlag caching pattern exactly:
- In-memory cache with 60-second TTL
- `getPointValue(action)` returns points (0 if disabled or missing)
- `isActionEnabled(action)` returns boolean
- `invalidateConfigCache()` clears cache immediately
- `getAllPointConfigs()` returns fresh data for admin panel
- `updatePointConfig(action, data, adminId)` updates and invalidates cache
- `seedDefaultPointConfigs()` seeds defaults with skipDuplicates

Default values from CONTEXT.md:
- benchmark_submission: 50 points, "Benchmark Submission"
- resource_download: 5 points, "Resource Download"
- discord_activity: 1 point, "Discord XP (per 100)"
- intro_completed: 25 points, "Introduction Completed"
  </action>
  <verify>
- TypeScript compiles: `npx tsc --noEmit`
- Files exist at src/points/types.ts and src/points/config.ts
  </verify>
  <done>Point action types defined; config service implements caching with 60s TTL matching FeatureFlag pattern</done>
</task>

<task type="auto">
  <name>Task 3: Create admin points config API and wire up</name>
  <files>src/routes/admin/points-config.ts, src/index.ts</files>
  <action>
**src/routes/admin/points-config.ts:**
Create admin router for point configuration CRUD:

```typescript
// GET /api/admin/points-config - List all point configs
// PUT /api/admin/points-config/:action - Update specific action config
// POST /api/admin/points-config/seed - Seed defaults (SUPER_ADMIN only)
```

Follow patterns from src/routes/admin/config.ts:
- Use requireAdmin middleware
- Zod validation for request body
- Audit log updates with logAuditEvent (action: 'POINT_CONFIG_UPDATED')
- Return updated config in response

PUT endpoint accepts:
```typescript
{
  points: number;     // Required, min 0
  enabled: boolean;   // Required
  label?: string;     // Optional
  description?: string; // Optional
}
```

**src/index.ts:**
Import and mount the router:
```typescript
import { adminPointsConfigRouter } from './routes/admin/points-config.js';
// ... in admin routes section
app.use('/api/admin/points-config', adminPointsConfigRouter);
```

Call seedDefaultPointConfigs() in startup (after seedDefaultFlags pattern).
  </action>
  <verify>
- Server starts without errors: `npm run dev`
- `curl http://localhost:4000/api/admin/points-config` returns 401 (auth required)
- Check src/index.ts includes the route mount
  </verify>
  <done>Admin can GET/PUT point configs; defaults seeded on startup; audit logged</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Database verification:
   - `npx prisma studio` shows PointConfig table with 4 seeded rows
   - Each row has action, points, enabled=true, label

2. API verification (with valid admin session):
   - GET /api/admin/points-config returns array of 4 configs
   - PUT /api/admin/points-config/benchmark_submission with {points: 100, enabled: true} updates
   - GET shows updated value
   - Audit log shows POINT_CONFIG_UPDATED entry

3. Code verification:
   - `npx tsc --noEmit` passes
   - `npm run lint` passes (if configured)
</verification>

<success_criteria>
- [ ] PointConfig model exists in schema with action unique constraint
- [ ] Migration applied without errors
- [ ] Point types exported from src/points/types.ts
- [ ] Config service caches values with 60s TTL
- [ ] Admin API allows GET and PUT of point configs
- [ ] Defaults seeded on startup (4 action types)
- [ ] Changes trigger cache invalidation
- [ ] Updates audit logged
</success_criteria>

<output>
After completion, create `.planning/phases/27-points-system-backend/27-01-SUMMARY.md`
</output>
