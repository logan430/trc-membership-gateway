---
phase: 27-points-system-backend
plan: 02
type: execute
wave: 2
depends_on: ["27-01"]
files_modified:
  - src/points/service.ts
  - src/bot/events/introduction.ts
  - src/lib/audit.ts
autonomous: true

must_haves:
  truths:
    - "Points awarded idempotently - same action never awards twice"
    - "Intro completion awards +25 points automatically"
    - "Each awarding function checks if action is enabled before awarding"
  artifacts:
    - path: "src/points/service.ts"
      provides: "Idempotent point awarding functions"
      exports: ["awardBenchmarkPoints", "awardDownloadPoints", "awardIntroPoints", "awardDiscordPoints", "adminAdjustPoints"]
    - path: "src/lib/audit.ts"
      provides: "POINTS_ADJUSTED audit action"
      contains: "POINTS_ADJUSTED"
  key_links:
    - from: "src/points/service.ts"
      to: "src/points/config.ts"
      via: "getPointValue, isActionEnabled"
      pattern: "getPointValue|isActionEnabled"
    - from: "src/points/service.ts"
      to: "prisma.pointTransaction"
      via: "database insert"
      pattern: "prisma\\.pointTransaction\\.create"
    - from: "src/bot/events/introduction.ts"
      to: "src/points/service.ts"
      via: "awardIntroPoints call"
      pattern: "awardIntroPoints"
---

<objective>
Create idempotent points service layer with integration into introduction handler

Purpose: Centralize all point-awarding logic with duplicate prevention. Integrate intro points into existing flow. Other integrations (benchmark, download, Discord XP) happen in their respective phases.

Output: Service module with award functions for all action types; intro handler integration; admin adjustment function with audit logging
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-points-system-backend/27-RESEARCH.md
@.planning/phases/27-points-system-backend/27-CONTEXT.md

# Reference 27-01 SUMMARY for config service exports
@.planning/phases/27-points-system-backend/27-01-SUMMARY.md

# Existing patterns and integration points
@src/bot/events/introduction.ts
@src/lib/audit.ts
@src/webhooks/stripe.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create points service with idempotent awarding</name>
  <files>src/points/service.ts</files>
  <action>
Create `src/points/service.ts` with the following functions:

**Interface for award results:**
```typescript
interface AwardResult {
  awarded: boolean;
  points: number;
  reason?: string;  // Why not awarded (e.g., "Already awarded for this category")
}
```

**awardBenchmarkPoints(memberId: string, category: string): Promise<AwardResult>**
- Check isActionEnabled first; return early if disabled
- Idempotency: Check for existing PointTransaction with action='benchmark_submission' AND metadata.category matches
- Per CONTEXT.md: One award per category EVER (not per submission)
- On award: create transaction with metadata { category, awardedAt }
- Log with pino logger

**awardDownloadPoints(memberId: string, resourceId: string, resourceTitle: string): Promise<AwardResult>**
- Check isActionEnabled first
- Idempotency: Check for existing transaction with action='resource_download' AND metadata.resourceId matches
- Per CONTEXT.md: First download only awards per resource
- On award: create transaction with metadata { resourceId, resourceTitle, awardedAt }

**awardIntroPoints(memberId: string): Promise<AwardResult>**
- Check isActionEnabled first
- Idempotency: Check for ANY existing transaction with action='intro_completed' for this member
- One-time ever per member
- On award: create transaction with metadata { awardedAt }

**awardDiscordPoints(memberId: string, xpDelta: number, syncId: string): Promise<AwardResult>**
- Check isActionEnabled first
- Calculate points: floor(xpDelta / 100) * pointValue
- If calculated points <= 0, return early (no award for small deltas)
- Idempotency: Check for existing transaction with metadata.syncId matches (prevents duplicate sync processing)
- On award: create transaction with metadata { xpDelta, syncId, awardedAt }

**adminAdjustPoints(params: { memberId, points, reason?, notifyMember, adminId }): Promise<void>**
- NO enable check - admin adjustments always work
- Create PointTransaction with action='admin_adjustment'
- Include metadata: { reason, adminId, notifyMember, adjustedAt }
- Log audit event (see Task 2)
- If notifyMember is true, queue Discord DM notification (fire-and-forget pattern)

All functions:
- Use getPointValue() from config module (not hardcoded values)
- Use PointAction constants from types module
- Log at info level for awards, debug for skip/already-awarded
- Import logger from '../index.js'
  </action>
  <verify>
- TypeScript compiles: `npx tsc --noEmit`
- File exports all 5 functions
  </verify>
  <done>Points service provides idempotent awarding for all action types with config-driven values</done>
</task>

<task type="auto">
  <name>Task 2: Add POINTS_ADJUSTED audit action and integrate</name>
  <files>src/lib/audit.ts</files>
  <action>
Update `src/lib/audit.ts` to add new audit action:

In AuditAction constant object, add:
```typescript
// Points actions
POINTS_ADJUSTED: 'POINTS_ADJUSTED',
```

This action is used by adminAdjustPoints in the service layer. The details field should include:
- points (the adjustment amount, can be negative)
- reason (optional)
- notifyMember (boolean)
- previousTotal (before adjustment)
- newTotal (after adjustment)

No other changes needed - logAuditEvent already accepts any action string.
  </action>
  <verify>
- TypeScript compiles: `npx tsc --noEmit`
- AuditAction.POINTS_ADJUSTED is exported
  </verify>
  <done>POINTS_ADJUSTED audit action available for admin point adjustments</done>
</task>

<task type="auto">
  <name>Task 3: Integrate intro points into introduction handler</name>
  <files>src/bot/events/introduction.ts</files>
  <action>
Update `src/bot/events/introduction.ts` to award intro points when member is promoted.

At top of file, add import:
```typescript
import { awardIntroPoints } from '../points/service.js';
```

In `promoteAfterIntro` function, after the database update (line ~179-186) and before sendWelcomeDM:

```typescript
// Award intro points (idempotent - safe if somehow called multiple times)
const pointsResult = await awardIntroPoints(member.id);
if (pointsResult.awarded) {
  logger.debug(
    { memberId: member.id, points: pointsResult.points },
    'Intro points awarded'
  );
}
```

The award is after DB update because:
1. Member must be marked introCompleted before points matter
2. Points trigger updates Member.totalPoints automatically
3. If role swap fails but intro is saved, points still awarded (acceptable)

Note: This is the ONLY integration in Phase 27. Benchmark (Phase 28), Download (Phase 29), and Discord (Phase 30) integrate in their respective phases.
  </action>
  <verify>
- TypeScript compiles: `npx tsc --noEmit`
- Server starts without errors: `npm run dev`
- File contains import for awardIntroPoints
  </verify>
  <done>Introduction completion automatically awards configured points</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Code verification:
   - `npx tsc --noEmit` passes
   - All exports present in src/points/service.ts

2. Manual test (requires test member):
   - Find a test member without intro points
   - Simulate intro completion (or wait for real one)
   - Check Member.totalPoints increased by configured value
   - Check PointTransaction created with action='intro_completed'

3. Idempotency test:
   - Call awardIntroPoints twice for same member
   - Second call returns { awarded: false, reason: 'Already awarded' }
   - Only one PointTransaction exists
</verification>

<success_criteria>
- [ ] Points service exports 5 award functions
- [ ] Each function checks isActionEnabled before awarding
- [ ] Each function uses metadata-based idempotency
- [ ] Each function uses getPointValue for configured amounts
- [ ] POINTS_ADJUSTED added to AuditAction
- [ ] Introduction handler calls awardIntroPoints on promotion
- [ ] TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/27-points-system-backend/27-02-SUMMARY.md`
</output>
