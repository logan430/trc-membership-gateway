---
phase: 28-benchmarking-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/benchmarks/types.ts
  - src/benchmarks/schemas.ts
autonomous: true

must_haves:
  truths:
    - "Benchmark data can be validated against category-specific schemas"
    - "TypeScript provides type safety for benchmark operations"
    - "All 4 benchmark categories have defined field structures"
  artifacts:
    - path: "src/benchmarks/types.ts"
      provides: "TypeScript types for benchmarks"
      exports: ["BenchmarkCategory", "BenchmarkFieldConfig", "CompensationData", "InfrastructureData", "BusinessData", "OperationalData"]
    - path: "src/benchmarks/schemas.ts"
      provides: "Zod validation schemas per category"
      exports: ["compensationSchema", "infrastructureSchema", "businessSchema", "operationalSchema", "benchmarkDataSchemas", "K_ANONYMITY_THRESHOLD"]
  key_links:
    - from: "src/benchmarks/schemas.ts"
      to: "src/benchmarks/types.ts"
      via: "imports types for inference"
      pattern: "import.*from.*types"
---

<objective>
Create TypeScript types and Zod validation schemas for the 4 benchmark categories.

Purpose: Establish the type-safe foundation for benchmark submission validation. These schemas define what data can be submitted in each category (compensation, infrastructure, business, operational) and enable validation at the API layer before database writes.

Output: Two files in src/benchmarks/ providing types and Zod schemas that the service layer will import.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/28-benchmarking-system/28-RESEARCH.md

Reference for field definitions:
@Chris's Dashboard & Features for Review & Integration/revenue-council/revenue-council/src/app/(member)/benchmarks/submit/benchmark-submit-form.tsx

Existing patterns to follow:
@src/points/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create benchmark types</name>
  <files>src/benchmarks/types.ts</files>
  <action>
Create src/benchmarks/types.ts with:

1. Re-export BenchmarkCategory enum from Prisma client (already exists in schema)

2. Define typed interfaces for each category's data structure:
   - CompensationData: gtm_engineer_us, gtm_engineer_offshore, sdr_bdr_us_salary, sdr_bdr_us_commission, sdr_bdr_offshore_salary, account_manager, virtual_assistant_hourly, copywriter_hourly
   - InfrastructureData: cost_per_domain, domain_vendor, cost_per_inbox, inbox_provider, warmup_tool, warmup_cost, sending_platform, sending_platform_cost, data_enrichment_cost
   - BusinessData: annual_revenue_band, agency_type, average_monthly_retainer, pricing_model, gross_margin_percent, monthly_client_churn_percent, revenue_per_employee
   - OperationalData: domains_per_client, inboxes_per_domain, daily_sends_per_inbox, warmup_period_days, average_reply_rate_percent, average_positive_reply_rate_percent, average_meeting_rate_percent

3. All numeric fields should be optional (number | undefined), all string fields should be optional (string | undefined) - users submit partial data

4. Create BenchmarkData union type: CompensationData | InfrastructureData | BusinessData | OperationalData

5. Create BenchmarkFieldConfig interface for UI metadata (key, label, type, prefix, suffix, options, max)

Follow the patterns from src/points/types.ts for export style.
  </action>
  <verify>
TypeScript compiles without errors: `npx tsc --noEmit src/benchmarks/types.ts`
  </verify>
  <done>
Types file exists with all 4 category interfaces and can be imported by other modules.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Zod validation schemas</name>
  <files>src/benchmarks/schemas.ts</files>
  <action>
Create src/benchmarks/schemas.ts with:

1. Import z from 'zod' and types from './types.js'

2. Define K_ANONYMITY_THRESHOLD = 5 constant (per research)

3. Create Zod schemas for each category matching the type interfaces:

compensationSchema = z.object({
  gtm_engineer_us: z.number().optional(),
  gtm_engineer_offshore: z.number().optional(),
  sdr_bdr_us_salary: z.number().optional(),
  sdr_bdr_us_commission: z.string().optional(), // Text field for commission structure
  sdr_bdr_offshore_salary: z.number().optional(),
  account_manager: z.number().optional(),
  virtual_assistant_hourly: z.number().optional(),
  copywriter_hourly: z.number().optional(),
})

infrastructureSchema = z.object({
  cost_per_domain: z.number().optional(),
  domain_vendor: z.string().optional(),
  cost_per_inbox: z.number().optional(),
  inbox_provider: z.string().optional(),
  warmup_tool: z.string().optional(),
  warmup_cost: z.number().optional(),
  sending_platform: z.string().optional(),
  sending_platform_cost: z.number().optional(),
  data_enrichment_cost: z.number().optional(),
})

businessSchema = z.object({
  annual_revenue_band: z.string().optional(),
  agency_type: z.string().optional(),
  average_monthly_retainer: z.number().optional(),
  pricing_model: z.string().optional(),
  gross_margin_percent: z.number().min(0).max(100).optional(),
  monthly_client_churn_percent: z.number().min(0).max(100).optional(),
  revenue_per_employee: z.number().optional(),
})

operationalSchema = z.object({
  domains_per_client: z.number().optional(),
  inboxes_per_domain: z.number().optional(),
  daily_sends_per_inbox: z.number().optional(),
  warmup_period_days: z.number().optional(),
  average_reply_rate_percent: z.number().min(0).max(100).optional(),
  average_positive_reply_rate_percent: z.number().min(0).max(100).optional(),
  average_meeting_rate_percent: z.number().min(0).max(100).optional(),
})

4. Create benchmarkDataSchemas map:
export const benchmarkDataSchemas = {
  COMPENSATION: compensationSchema,
  INFRASTRUCTURE: infrastructureSchema,
  BUSINESS: businessSchema,
  OPERATIONAL: operationalSchema,
} as const;

5. Export all schemas, the map, and the K_ANONYMITY_THRESHOLD constant.

6. Add type inference exports:
export type CompensationInput = z.infer<typeof compensationSchema>;
export type InfrastructureInput = z.infer<typeof infrastructureSchema>;
export type BusinessInput = z.infer<typeof businessSchema>;
export type OperationalInput = z.infer<typeof operationalSchema>;
  </action>
  <verify>
TypeScript compiles without errors: `npx tsc --noEmit src/benchmarks/schemas.ts`
Test schema validation:
```typescript
import { benchmarkDataSchemas } from './schemas.js';
benchmarkDataSchemas.COMPENSATION.parse({ gtm_engineer_us: 85000 }); // Should succeed
benchmarkDataSchemas.BUSINESS.parse({ gross_margin_percent: 150 }); // Should fail (max 100)
```
  </verify>
  <done>
Schemas file exists with all 4 category schemas, K_ANONYMITY_THRESHOLD exported, and can validate incoming benchmark data.
  </done>
</task>

</tasks>

<verification>
1. Both files compile: `npx tsc --noEmit src/benchmarks/*.ts`
2. Schemas can be imported: `node -e "import('./dist/benchmarks/schemas.js').then(m => console.log(Object.keys(m.benchmarkDataSchemas)))"`
3. All 4 categories present in benchmarkDataSchemas: COMPENSATION, INFRASTRUCTURE, BUSINESS, OPERATIONAL
4. K_ANONYMITY_THRESHOLD equals 5
</verification>

<success_criteria>
- src/benchmarks/types.ts exists with typed interfaces for all 4 categories
- src/benchmarks/schemas.ts exists with Zod schemas for all 4 categories
- All fields are optional (partial data allowed)
- Percentage fields have min(0).max(100) constraints
- K_ANONYMITY_THRESHOLD = 5 is exported
- TypeScript compilation succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/28-benchmarking-system/28-01-SUMMARY.md`
</output>
