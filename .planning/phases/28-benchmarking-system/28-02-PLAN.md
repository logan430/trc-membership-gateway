---
phase: 28-benchmarking-system
plan: 02
type: execute
wave: 2
depends_on: ["28-01"]
files_modified:
  - src/benchmarks/service.ts
autonomous: true

must_haves:
  truths:
    - "Member can submit benchmark data that gets validated and stored"
    - "Member can retrieve their own benchmark submissions"
    - "Aggregates are calculated with k-anonymity protection (5+ submissions per field)"
    - "Outliers (>3 sigma from median) are flagged with isValid=false"
    - "Points are awarded once per category via existing awardBenchmarkPoints()"
  artifacts:
    - path: "src/benchmarks/service.ts"
      provides: "Benchmark business logic layer"
      exports: ["submitBenchmark", "getMySubmissions", "getAggregates", "detectOutliers"]
  key_links:
    - from: "src/benchmarks/service.ts"
      to: "src/benchmarks/schemas.ts"
      via: "imports validation schemas"
      pattern: "import.*from.*schemas"
    - from: "src/benchmarks/service.ts"
      to: "src/points/service.ts"
      via: "calls awardBenchmarkPoints"
      pattern: "awardBenchmarkPoints"
    - from: "src/benchmarks/service.ts"
      to: "prisma.benchmarkSubmission"
      via: "database operations"
      pattern: "prisma\\.benchmarkSubmission"
---

<objective>
Create the benchmark service layer with business logic for submission, aggregation, and outlier detection.

Purpose: Encapsulate all benchmark operations in a service layer that handles validation, database writes, aggregate calculation via PostgreSQL functions, k-anonymity filtering, and outlier detection. This service will be called by the API routes.

Output: src/benchmarks/service.ts with submitBenchmark(), getMySubmissions(), getAggregates(), and detectOutliers() functions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/28-benchmarking-system/28-RESEARCH.md
@.planning/phases/28-benchmarking-system/28-01-SUMMARY.md

Existing patterns:
@src/points/service.ts
@src/lib/prisma.js
@src/lib/audit.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create benchmark service with submit and query functions</name>
  <files>src/benchmarks/service.ts</files>
  <action>
Create src/benchmarks/service.ts with the following structure:

1. **Imports:**
```typescript
import { prisma } from '../lib/prisma.js';
import { logger } from '../index.js';
import { awardBenchmarkPoints } from '../points/service.js';
import { benchmarkDataSchemas, K_ANONYMITY_THRESHOLD } from './schemas.js';
import type { BenchmarkCategory, Prisma } from '@prisma/client';
```

2. **Type definitions:**
```typescript
interface SubmitResult {
  submission: {
    id: string;
    category: BenchmarkCategory;
    submittedAt: Date;
    isValid: boolean;
  };
  outlierFields: string[];
  pointsAwarded: number;
}

interface AggregateField {
  field: string;
  median: number | null;
  p25: number | null;
  p75: number | null;
  min: number | null;
  max: number | null;
  count: number;
  yourValue?: number;
}

interface InsufficientField {
  field: string;
  currentCount: number;
  needMore: number;
}

interface AggregateResult {
  category: BenchmarkCategory;
  available: AggregateField[];
  insufficient: InsufficientField[];
  totalSubmissions: number;
}
```

3. **detectOutliers() function:**
- Takes category and validated data object
- For each numeric field with a value, query existing stats using PostgreSQL percentile_cont() and stddev()
- Only flag as outlier if field has K_ANONYMITY_THRESHOLD+ existing submissions (sparse data can't reliably detect outliers)
- Return array of field names where value is >3 standard deviations from median
- Use Prisma.$queryRaw with proper parameterization

Key implementation detail from research:
```typescript
async function detectOutliers(
  category: BenchmarkCategory,
  data: Record<string, unknown>
): Promise<string[]> {
  const outlierFields: string[] = [];
  const schema = benchmarkDataSchemas[category];
  const numericFields = Object.keys(schema.shape).filter(
    (key) => typeof data[key] === 'number'
  );

  for (const field of numericFields) {
    const value = data[field] as number;

    // Query stats for this field
    const stats = await prisma.$queryRaw<{ count: bigint; median: number; stddev: number }[]>`
      SELECT
        count(*)::bigint as count,
        percentile_cont(0.5) WITHIN GROUP (ORDER BY (data->>${Prisma.raw(`'${field}'`)})::numeric) as median,
        stddev((data->>${Prisma.raw(`'${field}'`)})::numeric) as stddev
      FROM "BenchmarkSubmission"
      WHERE category = ${category}::"BenchmarkCategory"
        AND "isValid" = true
        AND data->>${Prisma.raw(`'${field}'`)} IS NOT NULL
    `;

    const { count, median, stddev } = stats[0] || { count: 0n, median: null, stddev: null };

    // Only check outlier if sufficient data exists
    if (Number(count) >= K_ANONYMITY_THRESHOLD && stddev && stddev > 0) {
      const zScore = Math.abs((value - median) / stddev);
      if (zScore > 3) {
        outlierFields.push(field);
      }
    }
  }

  return outlierFields;
}
```

4. **submitBenchmark() function:**
- Takes memberId, category, and raw data
- Validate data against category-specific Zod schema
- Call detectOutliers() to check for statistical anomalies
- Use Prisma upsert with memberId_category unique constraint
- Set isValid = false if any outliers detected
- Call awardBenchmarkPoints() (handles idempotency internally)
- Return SubmitResult

5. **getMySubmissions() function:**
- Takes memberId
- Query all benchmark submissions for member
- Return array of { id, category, data, isValid, submittedAt, updatedAt }

6. **getAggregates() function:**
- Takes category and optional memberId (to include their value in response)
- Get field list from schema
- For each numeric field, query aggregates via PostgreSQL percentile_cont()
- Apply k-anonymity filter (only return fields with count >= K_ANONYMITY_THRESHOLD)
- If memberId provided, include their value for comparison
- Return AggregateResult

Key implementation for aggregates:
```typescript
async function getAggregates(
  category: BenchmarkCategory,
  memberId?: string
): Promise<AggregateResult> {
  // Get user's submission if memberId provided
  const userSubmission = memberId
    ? await prisma.benchmarkSubmission.findUnique({
        where: { memberId_category: { memberId, category } },
      })
    : null;

  const schema = benchmarkDataSchemas[category];
  const fields = Object.keys(schema.shape);

  // Calculate aggregates for each numeric field
  const aggregates = await Promise.all(
    fields.map(async (field) => {
      const result = await prisma.$queryRaw<{
        count: bigint;
        median: number | null;
        p25: number | null;
        p75: number | null;
        min: number | null;
        max: number | null;
      }[]>`
        SELECT
          count(*)::bigint as count,
          percentile_cont(0.5) WITHIN GROUP (ORDER BY (data->>${Prisma.raw(`'${field}'`)})::numeric) as median,
          percentile_cont(0.25) WITHIN GROUP (ORDER BY (data->>${Prisma.raw(`'${field}'`)})::numeric) as p25,
          percentile_cont(0.75) WITHIN GROUP (ORDER BY (data->>${Prisma.raw(`'${field}'`)})::numeric) as p75,
          min((data->>${Prisma.raw(`'${field}'`)})::numeric) as min,
          max((data->>${Prisma.raw(`'${field}'`)})::numeric) as max
        FROM "BenchmarkSubmission"
        WHERE category = ${category}::"BenchmarkCategory"
          AND "isValid" = true
          AND data->>${Prisma.raw(`'${field}'`)} IS NOT NULL
      `;

      const userData = userSubmission?.data as Record<string, unknown> | null;
      const yourValue = typeof userData?.[field] === 'number' ? userData[field] as number : undefined;

      return {
        field,
        ...result[0],
        count: Number(result[0]?.count || 0),
        yourValue,
      };
    })
  );

  // Apply k-anonymity filter
  const available = aggregates
    .filter((a) => a.count >= K_ANONYMITY_THRESHOLD)
    .map((a) => ({
      field: a.field,
      median: a.median,
      p25: a.p25,
      p75: a.p75,
      min: a.min,
      max: a.max,
      count: a.count,
      yourValue: a.yourValue,
    }));

  const insufficient = aggregates
    .filter((a) => a.count < K_ANONYMITY_THRESHOLD && a.count > 0)
    .map((a) => ({
      field: a.field,
      currentCount: a.count,
      needMore: K_ANONYMITY_THRESHOLD - a.count,
    }));

  const totalSubmissions = await prisma.benchmarkSubmission.count({
    where: { category, isValid: true },
  });

  return { category, available, insufficient, totalSubmissions };
}
```

7. **Export all functions:**
```typescript
export {
  submitBenchmark,
  getMySubmissions,
  getAggregates,
  detectOutliers,
  type SubmitResult,
  type AggregateResult,
};
```

**Important implementation notes:**
- Use Prisma.raw() for field names in raw queries (validated against schema keys)
- Cast JSON values to numeric explicitly in SQL
- Handle bigint from count(*) by converting to Number()
- Log operations for debugging
  </action>
  <verify>
TypeScript compiles without errors: `npx tsc --noEmit src/benchmarks/service.ts`
  </verify>
  <done>
Service file exists with all 4 functions exported, uses PostgreSQL aggregates for performance, applies k-anonymity filtering, and integrates with existing points system.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add segment filtering support to aggregates</name>
  <files>src/benchmarks/service.ts</files>
  <action>
Extend getAggregates() to support optional segment filters per BENCH-09.

Since Member model doesn't have companySize/industry/role fields (per research), and to keep Phase 28 focused on benchmarks, implement segment filtering using benchmark submission metadata.

1. Add SegmentFilters interface:
```typescript
interface SegmentFilters {
  companySize?: string;  // Will match against business category's annual_revenue_band
  industry?: string;     // Will match against business category's agency_type
  // Note: role filter deferred - would need Member schema changes
}
```

2. Update getAggregates() signature:
```typescript
async function getAggregates(
  category: BenchmarkCategory,
  memberId?: string,
  filters?: SegmentFilters
): Promise<AggregateResult>
```

3. When filters provided:
- If companySize filter set, only include submissions where the member's BUSINESS submission has matching annual_revenue_band
- If industry filter set, only include submissions where the member's BUSINESS submission has matching agency_type
- This requires a subquery to find memberIds with matching BUSINESS submissions, then filter main query

4. Key implementation change in aggregate queries:
```typescript
// Build member filter subquery if segment filters provided
let memberFilter = '';
if (filters?.companySize || filters?.industry) {
  const conditions: string[] = [];
  if (filters.companySize) {
    conditions.push(`data->>'annual_revenue_band' = '${filters.companySize}'`);
  }
  if (filters.industry) {
    conditions.push(`data->>'agency_type' = '${filters.industry}'`);
  }
  memberFilter = `
    AND "memberId" IN (
      SELECT "memberId" FROM "BenchmarkSubmission"
      WHERE category = 'BUSINESS'::"BenchmarkCategory"
        AND "isValid" = true
        AND ${conditions.join(' AND ')}
    )
  `;
}
```

5. **CRITICAL for k-anonymity:** Re-check count AFTER applying segment filters. If filtered count < K_ANONYMITY_THRESHOLD, move field to insufficient array.

6. Add logging when segment filters reduce available data:
```typescript
logger.debug({ category, filters, filteredCount }, 'Segment filter applied to aggregates');
```

Note: Document in code comments that full segment filtering (by member profile fields) requires Member schema extension in a future phase.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit src/benchmarks/service.ts`
Test that filters parameter is optional and doesn't break default behavior.
  </verify>
  <done>
getAggregates() accepts optional segment filters, applies cross-category filtering via BUSINESS submission data, and re-validates k-anonymity after filtering.
  </done>
</task>

</tasks>

<verification>
1. File compiles: `npx tsc --noEmit src/benchmarks/service.ts`
2. Exports are correct: Check that submitBenchmark, getMySubmissions, getAggregates, detectOutliers are exported
3. Zod schemas are imported and used for validation
4. awardBenchmarkPoints is called in submitBenchmark
5. K_ANONYMITY_THRESHOLD is used in aggregate filtering
6. Raw queries use proper parameterization (no SQL injection)
</verification>

<success_criteria>
- src/benchmarks/service.ts exists with all 4 functions
- submitBenchmark() validates data, detects outliers, upserts, and awards points
- getMySubmissions() returns member's submissions
- getAggregates() calculates median/percentiles via PostgreSQL and applies k-anonymity
- detectOutliers() flags values >3 sigma from median
- Segment filters are supported but optional
- TypeScript compilation succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/28-benchmarking-system/28-02-SUMMARY.md`
</output>
