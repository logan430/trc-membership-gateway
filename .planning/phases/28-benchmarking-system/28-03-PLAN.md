---
phase: 28-benchmarking-system
plan: 03
type: execute
wave: 3
depends_on: ["28-02"]
files_modified:
  - src/routes/benchmarks.ts
  - src/routes/admin/benchmarks.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Member can submit benchmark data via POST /api/benchmarks/submit"
    - "Member can view their own submissions via GET /api/benchmarks/my-submissions"
    - "Member can view aggregates via GET /api/benchmarks/aggregates/:category"
    - "Admin can view flagged submissions via GET /api/admin/benchmarks/flagged"
    - "Admin can approve or reject submissions via POST /api/admin/benchmarks/:id/review"
    - "Admin can view submission stats via GET /api/admin/benchmarks/stats"
  artifacts:
    - path: "src/routes/benchmarks.ts"
      provides: "Member-facing benchmark API endpoints"
      exports: ["benchmarksRouter"]
    - path: "src/routes/admin/benchmarks.ts"
      provides: "Admin benchmark moderation endpoints"
      exports: ["adminBenchmarksRouter"]
  key_links:
    - from: "src/routes/benchmarks.ts"
      to: "src/benchmarks/service.ts"
      via: "calls service functions"
      pattern: "import.*from.*service"
    - from: "src/routes/admin/benchmarks.ts"
      to: "prisma.benchmarkSubmission"
      via: "database queries for moderation"
      pattern: "prisma\\.benchmarkSubmission"
    - from: "src/index.ts"
      to: "src/routes/benchmarks.ts"
      via: "mounts router at /api/benchmarks"
      pattern: "app\\.use.*benchmarksRouter"
    - from: "src/index.ts"
      to: "src/routes/admin/benchmarks.ts"
      via: "mounts router at /api/admin/benchmarks"
      pattern: "app\\.use.*adminBenchmarksRouter"
---

<objective>
Create API endpoints for benchmark submission, retrieval, and admin moderation.

Purpose: Expose the benchmark service layer via REST API. Member endpoints allow submitting data, viewing own submissions, and querying aggregates. Admin endpoints enable moderation of flagged submissions and viewing system-wide stats.

Output: Two route files (member and admin) mounted in Express app at /api/benchmarks and /api/admin/benchmarks.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/28-benchmarking-system/28-RESEARCH.md
@.planning/phases/28-benchmarking-system/28-02-SUMMARY.md

Existing patterns:
@src/routes/points.ts
@src/routes/admin/points.ts
@src/routes/admin/members.ts
@src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create member-facing benchmark routes</name>
  <files>src/routes/benchmarks.ts</files>
  <action>
Create src/routes/benchmarks.ts following the pattern from src/routes/points.ts:

```typescript
/**
 * Member-facing benchmark API routes
 * Endpoints for submitting benchmarks, viewing submissions, and querying aggregates
 */
import { Router } from 'express';
import { z } from 'zod';
import { requireAuth, type AuthenticatedRequest } from '../middleware/session.js';
import {
  submitBenchmark,
  getMySubmissions,
  getAggregates,
} from '../benchmarks/service.js';
import { BenchmarkCategory } from '@prisma/client';

export const benchmarksRouter = Router();
```

**Endpoint 1: POST /submit**
- Requires auth (requireAuth middleware)
- Request body: { category: BenchmarkCategory, data: Record<string, unknown> }
- Validates category is one of: COMPENSATION, INFRASTRUCTURE, BUSINESS, OPERATIONAL
- Calls submitBenchmark(memberId, category, data)
- Returns: { submission, outlierFields?, pointsAwarded }
- On validation error: 400 with { error, details }

```typescript
const submitSchema = z.object({
  category: z.enum(['COMPENSATION', 'INFRASTRUCTURE', 'BUSINESS', 'OPERATIONAL']),
  data: z.record(z.unknown()),
});

benchmarksRouter.post('/submit', requireAuth, async (req: AuthenticatedRequest, res) => {
  try {
    const { category, data } = submitSchema.parse(req.body);
    const memberId = req.memberId!;

    const result = await submitBenchmark(memberId, category as BenchmarkCategory, data);

    res.json({
      submission: result.submission,
      outlierFields: result.outlierFields.length > 0 ? result.outlierFields : undefined,
      pointsAwarded: result.pointsAwarded,
    });
  } catch (error) {
    if (error instanceof z.ZodError) {
      res.status(400).json({ error: 'Validation failed', details: error.issues });
      return;
    }
    throw error;
  }
});
```

**Endpoint 2: GET /my-submissions**
- Requires auth
- No parameters
- Calls getMySubmissions(memberId)
- Returns: { submissions: Array<{ id, category, data, isValid, submittedAt, updatedAt }> }

```typescript
benchmarksRouter.get('/my-submissions', requireAuth, async (req: AuthenticatedRequest, res) => {
  const memberId = req.memberId!;
  const submissions = await getMySubmissions(memberId);
  res.json({ submissions });
});
```

**Endpoint 3: GET /aggregates/:category**
- Requires auth
- Path param: category (validated)
- Query params (optional): companySize, industry (for segment filtering)
- Calls getAggregates(category, memberId, filters)
- Returns: { category, available, insufficient, totalSubmissions }

```typescript
const aggregatesQuerySchema = z.object({
  companySize: z.string().optional(),
  industry: z.string().optional(),
});

benchmarksRouter.get('/aggregates/:category', requireAuth, async (req: AuthenticatedRequest, res) => {
  try {
    const category = z.enum(['COMPENSATION', 'INFRASTRUCTURE', 'BUSINESS', 'OPERATIONAL'])
      .parse(req.params.category);
    const filters = aggregatesQuerySchema.parse(req.query);
    const memberId = req.memberId!;

    const result = await getAggregates(
      category as BenchmarkCategory,
      memberId,
      Object.keys(filters).length > 0 ? filters : undefined
    );

    res.json(result);
  } catch (error) {
    if (error instanceof z.ZodError) {
      res.status(400).json({ error: 'Invalid category', details: error.issues });
      return;
    }
    throw error;
  }
});
```
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit src/routes/benchmarks.ts`
  </verify>
  <done>
Member benchmark routes file exists with /submit, /my-submissions, and /aggregates/:category endpoints.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create admin benchmark moderation routes</name>
  <files>src/routes/admin/benchmarks.ts</files>
  <action>
Create src/routes/admin/benchmarks.ts following the pattern from src/routes/admin/members.ts:

```typescript
/**
 * Admin benchmark moderation API routes
 * Endpoints for reviewing flagged submissions and viewing stats
 */
import { Router } from 'express';
import { z } from 'zod';
import { requireAdmin } from '../../middleware/admin-session.js';
import { prisma } from '../../lib/prisma.js';
import { logAuditEvent, AuditAction } from '../../lib/audit.js';
import { BenchmarkCategory } from '@prisma/client';

export const adminBenchmarksRouter = Router();
```

**Endpoint 1: GET /flagged**
- Requires admin auth
- Query params: cursor (optional), limit (default 50, max 100), category (optional filter)
- Returns paginated list of submissions where isValid = false
- Includes member info (id, email, discordUsername)
- Returns: { submissions, nextCursor, hasMore }

```typescript
const flaggedQuerySchema = z.object({
  cursor: z.string().optional(),
  limit: z.coerce.number().min(1).max(100).default(50),
  category: z.enum(['COMPENSATION', 'INFRASTRUCTURE', 'BUSINESS', 'OPERATIONAL']).optional(),
});

adminBenchmarksRouter.get('/flagged', requireAdmin, async (req, res) => {
  const query = flaggedQuerySchema.parse(req.query);

  const submissions = await prisma.benchmarkSubmission.findMany({
    take: query.limit + 1,
    skip: query.cursor ? 1 : 0,
    cursor: query.cursor ? { id: query.cursor } : undefined,
    where: {
      isValid: false,
      ...(query.category ? { category: query.category as BenchmarkCategory } : {}),
    },
    include: {
      member: {
        select: { id: true, email: true, discordUsername: true },
      },
    },
    orderBy: { updatedAt: 'desc' },
  });

  const hasMore = submissions.length > query.limit;
  const results = hasMore ? submissions.slice(0, query.limit) : submissions;

  res.json({
    submissions: results,
    nextCursor: hasMore ? results[results.length - 1].id : null,
    hasMore,
  });
});
```

**Endpoint 2: POST /:id/review**
- Requires admin auth
- Path param: id (submission ID)
- Request body: { action: 'approve' | 'reject' }
- Updates isValid based on action (approve = true, reject = false)
- Logs audit event with admin ID
- Returns: { success: true }

```typescript
const reviewSchema = z.object({
  action: z.enum(['approve', 'reject']),
});

adminBenchmarksRouter.post('/:id/review', requireAdmin, async (req, res) => {
  const { id } = z.object({ id: z.string() }).parse(req.params);
  const { action } = reviewSchema.parse(req.body);
  const admin = res.locals.admin!;

  const submission = await prisma.benchmarkSubmission.findUnique({
    where: { id },
  });

  if (!submission) {
    res.status(404).json({ error: 'Submission not found' });
    return;
  }

  // Update isValid based on action
  await prisma.benchmarkSubmission.update({
    where: { id },
    data: { isValid: action === 'approve' },
  });

  // Log audit event
  await logAuditEvent({
    action: AuditAction.BENCHMARK_REVIEWED,
    entityType: 'Member',
    entityId: submission.memberId,
    details: {
      submissionId: id,
      category: submission.category,
      action,
      reviewedBy: admin.id,
    },
    performedBy: admin.id,
  });

  res.json({ success: true });
});
```

**Endpoint 3: GET /stats**
- Requires admin auth
- Returns submission counts per category
- Includes total, valid, and flagged counts

```typescript
adminBenchmarksRouter.get('/stats', requireAdmin, async (req, res) => {
  const categories: BenchmarkCategory[] = ['COMPENSATION', 'INFRASTRUCTURE', 'BUSINESS', 'OPERATIONAL'];

  const stats = await Promise.all(
    categories.map(async (category) => {
      const [total, valid, flagged] = await Promise.all([
        prisma.benchmarkSubmission.count({ where: { category } }),
        prisma.benchmarkSubmission.count({ where: { category, isValid: true } }),
        prisma.benchmarkSubmission.count({ where: { category, isValid: false } }),
      ]);
      return { category, total, valid, flagged };
    })
  );

  const totals = {
    total: stats.reduce((sum, s) => sum + s.total, 0),
    valid: stats.reduce((sum, s) => sum + s.valid, 0),
    flagged: stats.reduce((sum, s) => sum + s.flagged, 0),
  };

  res.json({ stats, totals });
});
```

**Add BENCHMARK_REVIEWED to AuditAction:**
Check if it exists in src/lib/audit.ts. If not, add it to the AuditAction enum.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit src/routes/admin/benchmarks.ts`
  </verify>
  <done>
Admin benchmark routes file exists with /flagged, /:id/review, and /stats endpoints.
  </done>
</task>

<task type="auto">
  <name>Task 3: Mount routes in Express app and add audit action</name>
  <files>src/index.ts, src/lib/audit.ts</files>
  <action>
**1. Update src/lib/audit.ts:**
Add BENCHMARK_REVIEWED to the AuditAction enum if it doesn't exist:
```typescript
export const AuditAction = {
  // ... existing actions
  BENCHMARK_REVIEWED: 'BENCHMARK_REVIEWED',
} as const;
```

**2. Update src/index.ts:**

Add imports at the top with other route imports:
```typescript
import { benchmarksRouter } from './routes/benchmarks.js';
import { adminBenchmarksRouter } from './routes/admin/benchmarks.js';
```

Mount the routes in the appropriate sections:

After the points routes (~line 109), add member benchmarks route:
```typescript
// Benchmark routes (member-facing)
app.use('/api/benchmarks', benchmarksRouter);
```

After the admin points routes (~line 106), add admin benchmarks route:
```typescript
app.use('/api/admin/benchmarks', adminBenchmarksRouter);
```

The order should be:
- Admin API routes section:
  - ...existing admin routes...
  - app.use('/api/admin/benchmarks', adminBenchmarksRouter);
- Member API routes:
  - app.use('/api/points', pointsRouter);
  - app.use('/api/benchmarks', benchmarksRouter);
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit`
2. Server starts without errors: `npm run dev` (check logs)
3. Endpoints respond:
   - `curl http://localhost:4000/api/benchmarks/my-submissions` (should return 401 - no auth)
   - `curl http://localhost:4000/api/admin/benchmarks/stats` (should return 401 - no admin auth)
  </verify>
  <done>
Both routers are imported and mounted in Express app. BENCHMARK_REVIEWED audit action exists. All 6 endpoints are accessible at their expected paths.
  </done>
</task>

</tasks>

<verification>
1. All files compile: `npx tsc --noEmit`
2. Server starts: `npm run dev`
3. Member endpoints exist (return 401 without auth):
   - POST /api/benchmarks/submit
   - GET /api/benchmarks/my-submissions
   - GET /api/benchmarks/aggregates/COMPENSATION
4. Admin endpoints exist (return 401 without admin auth):
   - GET /api/admin/benchmarks/flagged
   - POST /api/admin/benchmarks/:id/review
   - GET /api/admin/benchmarks/stats
5. BENCHMARK_REVIEWED is in AuditAction enum
</verification>

<success_criteria>
- src/routes/benchmarks.ts exists with 3 member endpoints
- src/routes/admin/benchmarks.ts exists with 3 admin endpoints
- Both routers mounted in src/index.ts
- BENCHMARK_REVIEWED audit action exists
- TypeScript compilation succeeds
- Server starts without errors
- Endpoints return appropriate auth errors when called without authentication
</success_criteria>

<output>
After completion, create `.planning/phases/28-benchmarking-system/28-03-SUMMARY.md`
</output>
