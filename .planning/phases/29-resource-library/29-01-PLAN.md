---
phase: 29-resource-library
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - prisma/migrations/YYYYMMDDHHMMSS_resource_library_schema/migration.sql
  - src/config/env.ts
  - .env.example
  - src/lib/supabase.ts
  - src/lib/file-validation.ts
autonomous: true
user_setup:
  - service: supabase-storage
    why: "File storage for resource library"
    env_vars:
      - name: SUPABASE_URL
        source: "Supabase Dashboard -> Project Settings -> API -> Project URL"
      - name: SUPABASE_SERVICE_ROLE_KEY
        source: "Supabase Dashboard -> Project Settings -> API -> Service Role Key (secret)"
    dashboard_config:
      - task: "Create private bucket named 'resources'"
        location: "Supabase Dashboard -> Storage -> New Bucket -> Name: resources, Public: OFF"

must_haves:
  truths:
    - "Resource model supports flat tags, version history, and publishing states"
    - "ResourceTag table allows admin-managed tag list"
    - "ResourceVersion tracks file history with changelog"
    - "Supabase Storage client can upload and generate signed URLs"
    - "File validation detects PDF, DOCX, XLSX, MP4, ZIP via magic numbers"
    - "SVG files are blocked (XSS prevention)"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "Resource, ResourceTag, ResourceVersion models with ResourceStatus enum"
      contains: "enum ResourceStatus"
    - path: "src/lib/supabase.ts"
      provides: "Supabase client with service role key"
      exports: ["getSupabaseClient"]
    - path: "src/lib/file-validation.ts"
      provides: "Magic number validation for allowed file types"
      exports: ["validateFileType"]
    - path: "src/config/env.ts"
      provides: "SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY env vars"
      contains: "SUPABASE_URL"
  key_links:
    - from: "src/lib/supabase.ts"
      to: "src/config/env.ts"
      via: "env.SUPABASE_URL, env.SUPABASE_SERVICE_ROLE_KEY"
      pattern: "env\\.SUPABASE_"
    - from: "src/lib/file-validation.ts"
      to: "file-type"
      via: "fileTypeFromBuffer import"
      pattern: "from 'file-type'"
---

<objective>
Set up database schema and core infrastructure for resource library.

Purpose: Establish the foundation for resource storage - schema with flat tags, versioning, publishing states, plus Supabase Storage client and file validation.

Output: Migration files, Supabase client, and file validation service ready for storage service layer.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-resource-library/29-CONTEXT.md
@.planning/phases/29-resource-library/29-RESEARCH.md
@prisma/schema.prisma
@src/config/env.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create resource library schema migration</name>
  <files>
    prisma/schema.prisma
    prisma/migrations/YYYYMMDDHHMMSS_resource_library_schema/migration.sql
  </files>
  <action>
Create Prisma schema changes and migration for resource library:

1. Add ResourceStatus enum:
   - DRAFT, PUBLISHED, SCHEDULED

2. Create ResourceTag model (admin-managed tag list):
   - id: String @id @default(cuid())
   - name: String @unique
   - createdAt: DateTime @default(now())
   - createdBy: String? (admin ID)

3. Modify Resource model (evolve existing, don't recreate):
   - REMOVE: category (ResourceCategory enum - per CONTEXT.md, using flat tags instead)
   - KEEP: id, title, description, type, isFeatured, downloadCount, createdAt, updatedAt, downloads relation
   - CHANGE: fileUrl -> storagePath (Supabase Storage path, not URL)
   - ADD: tags String[] @default([]) (flat tags array)
   - ADD: status ResourceStatus @default(DRAFT)
   - ADD: publishAt DateTime? (for scheduled publishing)
   - ADD: uploadedBy String? (admin ID - internal tracking)
   - ADD: author String? (public attribution)
   - ADD: fileSize Int?
   - ADD: mimeType String?
   - ADD: deletedAt DateTime? (soft delete)
   - ADD: currentVersion Int @default(1)
   - ADD: versions ResourceVersion[] relation

4. Create ResourceVersion model:
   - id: String @id @default(cuid())
   - resourceId: String (relation to Resource)
   - version: Int
   - storagePath: String
   - fileSize: Int?
   - changelog: String? (optional version notes)
   - uploadedBy: String
   - createdAt: DateTime @default(now())
   - @@unique([resourceId, version])
   - @@index([resourceId])

5. Add GIN index on Resource.tags for fast array queries

6. Generate migration with `npx prisma migrate dev --create-only --name resource_library_schema`

7. Edit migration.sql for zero-downtime patterns:
   - Use NOT VALID for foreign keys
   - Create indexes CONCURRENTLY (remove transaction wrapper if present)
   - Handle existing data: Set storagePath = fileUrl for existing rows, then drop fileUrl column

IMPORTANT: The existing ResourceCategory enum can be removed - per CONTEXT.md, we use flat tags. Remove the enum and the category column from Resource.
  </action>
  <verify>
npx prisma validate
Migration file exists and contains: CREATE TYPE "ResourceStatus", CREATE TABLE "ResourceTag", CREATE TABLE "ResourceVersion", ALTER TABLE "Resource"
  </verify>
  <done>
Prisma schema valid. Migration file ready for manual review. Resource model supports flat tags, versioning, and publishing states.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Supabase Storage client and env vars</name>
  <files>
    src/config/env.ts
    .env.example
    src/lib/supabase.ts
  </files>
  <action>
1. Update src/config/env.ts to add Supabase env vars:
   - SUPABASE_URL: z.string().url()
   - SUPABASE_SERVICE_ROLE_KEY: z.string().min(1)
   Both should be optional with helpful error messages when storage operations are attempted without them.

2. Update .env.example with Supabase vars (no real values):
   ```
   # Supabase Storage (for resource library)
   SUPABASE_URL=https://[project-ref].supabase.co
   SUPABASE_SERVICE_ROLE_KEY=your-service-role-key
   ```

3. Create src/lib/supabase.ts:
   - Import createClient from @supabase/supabase-js
   - Import env from ../config/env.js
   - Singleton pattern (lazy init)
   - Service role client (bypasses RLS)
   - Export getSupabaseClient() function
   - Throw helpful error if env vars not configured

4. Install @supabase/supabase-js:
   npm install @supabase/supabase-js
  </action>
  <verify>
npm run build (TypeScript compiles)
grep -q "SUPABASE_URL" src/config/env.ts
grep -q "getSupabaseClient" src/lib/supabase.ts
  </verify>
  <done>
Supabase client configured with service role key. Env vars documented in .env.example.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create file validation service</name>
  <files>
    src/lib/file-validation.ts
  </files>
  <action>
Create src/lib/file-validation.ts with magic number validation:

1. Install file-type:
   npm install file-type
   (Already ESM-only, project uses ESM so this is compatible)

2. Create file-validation.ts:
   - Import fileTypeFromBuffer from 'file-type'

   - Define ALLOWED_MIME_TYPES set per SEC-02:
     * application/pdf (PDF)
     * application/vnd.openxmlformats-officedocument.wordprocessingml.document (DOCX)
     * application/vnd.openxmlformats-officedocument.spreadsheetml.sheet (XLSX)
     * video/mp4 (MP4)
     * application/zip (ZIP - also covers DOCX/XLSX internals)
     * application/x-zip-compressed (ZIP variant)

   - Define BLOCKED_MIME_TYPES set per SEC-03:
     * image/svg+xml (XSS risk)
     * application/xml
     * text/xml

   - Define EXTENSION_MIME_MAP for cross-validation:
     * pdf -> ['application/pdf']
     * docx -> ['application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'application/zip']
     * xlsx -> ['application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'application/zip']
     * mp4 -> ['video/mp4']
     * zip -> ['application/zip', 'application/x-zip-compressed']

   - Export ValidationResult interface:
     * valid: boolean
     * detectedMime?: string
     * detectedExt?: string
     * error?: string

   - Export async validateFileType(buffer: Buffer, originalFilename: string): Promise<ValidationResult>
     1. Call fileTypeFromBuffer(buffer)
     2. If no detection, return error "Could not detect file type"
     3. If detected MIME in BLOCKED_MIME_TYPES, return error with security message
     4. If detected MIME not in ALLOWED_MIME_TYPES, return error with allowed list
     5. Cross-check: extension should match expected MIME types (prevent spoofing)
     6. Return valid: true with detected MIME and extension

Note per RESEARCH.md: DOCX/XLSX are ZIP-based, so file-type may detect them as application/zip. This is why EXTENSION_MIME_MAP allows both specific Office MIME and generic ZIP for Office extensions.
  </action>
  <verify>
npm run build
grep -q "fileTypeFromBuffer" src/lib/file-validation.ts
grep -q "BLOCKED_MIME_TYPES" src/lib/file-validation.ts
grep -q "validateFileType" src/lib/file-validation.ts
  </verify>
  <done>
File validation service detects PDF, DOCX, XLSX, MP4, ZIP via magic numbers. SVG and other dangerous types blocked. Extension spoofing prevented via cross-validation.
  </done>
</task>

</tasks>

<verification>
- [ ] npx prisma validate passes
- [ ] Migration file exists with correct DDL
- [ ] npm run build compiles without errors
- [ ] Supabase client exports getSupabaseClient
- [ ] File validation exports validateFileType
- [ ] .env.example documents SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY
</verification>

<success_criteria>
1. Resource schema supports flat tags (String[]), version history, and Draft/Published/Scheduled states
2. ResourceTag table exists for admin-managed tag list
3. ResourceVersion table tracks file versions with changelog
4. Supabase Storage client configured with service role key
5. File validation detects allowed types via magic numbers and blocks SVG
6. Migration ready for review (not applied - zero-downtime patterns)
</success_criteria>

<output>
After completion, create `.planning/phases/29-resource-library/29-01-SUMMARY.md`
</output>
