---
phase: 29-resource-library
plan: 02
type: execute
wave: 2
depends_on: ["29-01"]
files_modified:
  - src/middleware/rate-limit.ts
  - src/storage/types.ts
  - src/storage/upload.ts
  - src/storage/download.ts
  - src/resources/types.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "File uploads limited to 100MB (SEC-01)"
    - "Upload rate limited to 5 files per hour per admin (SEC-07)"
    - "Files upload to Supabase Storage private bucket"
    - "Signed URLs generated with 1-hour expiry (SEC-05)"
    - "Signed URLs include Content-Disposition: attachment (SEC-06)"
    - "Storage paths organized by admin ID and timestamp"
  artifacts:
    - path: "src/middleware/rate-limit.ts"
      provides: "uploadLimiter for 5 files/hour/admin"
      exports: ["uploadLimiter"]
    - path: "src/storage/types.ts"
      provides: "Storage constants and types"
      exports: ["MAX_FILE_SIZE", "BUCKET_NAME", "SIGNED_URL_EXPIRY"]
    - path: "src/storage/upload.ts"
      provides: "Multer middleware and Supabase upload function"
      exports: ["uploadMiddleware", "uploadToStorage"]
    - path: "src/storage/download.ts"
      provides: "Signed URL generation"
      exports: ["generateSignedUrl"]
    - path: "src/resources/types.ts"
      provides: "Resource domain types"
      exports: ["ResourceWithDetails", "CreateResourceInput"]
  key_links:
    - from: "src/storage/upload.ts"
      to: "src/lib/supabase.ts"
      via: "getSupabaseClient() call"
      pattern: "getSupabaseClient\\(\\)"
    - from: "src/storage/upload.ts"
      to: "src/lib/file-validation.ts"
      via: "validateFileType() call"
      pattern: "validateFileType\\("
    - from: "src/storage/download.ts"
      to: "src/lib/supabase.ts"
      via: "getSupabaseClient() call"
      pattern: "getSupabaseClient\\(\\)"
---

<objective>
Build storage infrastructure with rate limiting, upload/download services, and resource types.

Purpose: Create the complete storage layer that handles file uploads to Supabase, generates signed URLs, and enforces security constraints (size limits, rate limits).

Output: Ready-to-use storage services for resource service layer.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-resource-library/29-CONTEXT.md
@.planning/phases/29-resource-library/29-RESEARCH.md
@.planning/phases/29-resource-library/29-01-SUMMARY.md
@src/lib/supabase.ts
@src/lib/file-validation.ts
@src/middleware/rate-limit.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add upload rate limiter and install multer</name>
  <files>
    src/middleware/rate-limit.ts
    package.json
  </files>
  <action>
1. Install multer and types:
   npm install multer
   npm install --save-dev @types/multer

2. Update src/middleware/rate-limit.ts to add uploadLimiter:

   Import at top if not already present:
   - import rateLimit from 'express-rate-limit';

   Add new limiter (following existing pattern):
   ```typescript
   /**
    * Rate limiter for file uploads
    * SEC-07: 5 files per hour per admin
    * Keyed by admin ID from authenticated session
    */
   export const uploadLimiter = rateLimit({
     windowMs: 60 * 60 * 1000, // 1 hour
     max: 5,
     message: { error: 'Upload limit reached. You can upload up to 5 files per hour.' },
     standardHeaders: true,
     legacyHeaders: false,
     keyGenerator: (req) => {
       // Key by admin ID from authenticated session (set by requireAdmin middleware)
       const adminId = (req as any).adminId || res.locals?.admin?.id || req.ip;
       return `upload:${adminId}`;
     },
   });
   ```

Note: The adminId will come from res.locals.admin.id set by requireAdmin middleware. Since keyGenerator only has access to req, we need to handle this carefully - the admin ID might be stored on req by middleware. Check existing admin middleware pattern.
  </action>
  <verify>
npm run build
grep -q "uploadLimiter" src/middleware/rate-limit.ts
grep -q "5 files per hour" src/middleware/rate-limit.ts
  </verify>
  <done>
Upload rate limiter configured for 5 files per hour per admin. Multer installed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create storage service layer</name>
  <files>
    src/storage/types.ts
    src/storage/upload.ts
    src/storage/download.ts
  </files>
  <action>
Create storage service directory and files:

1. Create src/storage/types.ts:
   ```typescript
   // Storage constants per requirements
   export const MAX_FILE_SIZE = 100 * 1024 * 1024; // SEC-01: 100MB
   export const BUCKET_NAME = 'resources';
   export const SIGNED_URL_EXPIRY = 3600; // SEC-05: 1 hour in seconds

   // Allowed extensions for preliminary check (magic number validation is authoritative)
   export const ALLOWED_EXTENSIONS = ['.pdf', '.docx', '.xlsx', '.mp4', '.zip'];

   export interface UploadResult {
     storagePath: string;
     fileSize: number;
     mimeType: string;
   }

   export interface SignedUrlResult {
     url: string;
     expiresAt: Date;
   }
   ```

2. Create src/storage/upload.ts:
   ```typescript
   import multer from 'multer';
   import { RequestHandler } from 'express';
   import { getSupabaseClient } from '../lib/supabase.js';
   import { validateFileType } from '../lib/file-validation.js';
   import { logger } from '../index.js';
   import { MAX_FILE_SIZE, BUCKET_NAME, ALLOWED_EXTENSIONS, UploadResult } from './types.js';

   // Multer memory storage - file in req.file.buffer
   const storage = multer.memoryStorage();

   // Preliminary extension filter (magic number validation happens after)
   const fileFilter: multer.Options['fileFilter'] = (req, file, cb) => {
     const ext = '.' + file.originalname.split('.').pop()?.toLowerCase();
     if (!ALLOWED_EXTENSIONS.includes(ext)) {
       cb(new Error(`File extension ${ext} not allowed. Allowed: ${ALLOWED_EXTENSIONS.join(', ')}`));
       return;
     }
     cb(null, true);
   };

   /**
    * Multer middleware for single file upload
    * SEC-01: 100MB limit
    * SEC-02: Extension pre-filter (magic validation after)
    */
   export const uploadMiddleware: RequestHandler = multer({
     storage,
     limits: {
       fileSize: MAX_FILE_SIZE,
       files: 1,
     },
     fileFilter,
   }).single('file');

   /**
    * Upload validated file to Supabase Storage
    * Call AFTER uploadMiddleware and validateFileType
    */
   export async function uploadToStorage(
     buffer: Buffer,
     originalFilename: string,
     adminId: string,
     validatedMime: string
   ): Promise<UploadResult> {
     const supabase = getSupabaseClient();

     // Generate unique path: uploads/{adminId}/{timestamp}-{sanitized-filename}
     const timestamp = Date.now();
     const safeFilename = originalFilename.replace(/[^a-zA-Z0-9.-]/g, '_');
     const storagePath = `uploads/${adminId}/${timestamp}-${safeFilename}`;

     const { error } = await supabase.storage
       .from(BUCKET_NAME)
       .upload(storagePath, buffer, {
         contentType: validatedMime,
         upsert: false, // Fail if exists (unique paths anyway)
       });

     if (error) {
       logger.error({ error, storagePath }, 'Failed to upload to Supabase Storage');
       throw new Error(`Failed to upload file: ${error.message}`);
     }

     logger.info({ storagePath, fileSize: buffer.length, mimeType: validatedMime }, 'File uploaded to storage');

     return {
       storagePath,
       fileSize: buffer.length,
       mimeType: validatedMime,
     };
   }

   /**
    * Delete file from Supabase Storage
    * Used when resource is deleted or version pruned
    */
   export async function deleteFromStorage(storagePath: string): Promise<void> {
     const supabase = getSupabaseClient();

     const { error } = await supabase.storage
       .from(BUCKET_NAME)
       .remove([storagePath]);

     if (error) {
       logger.error({ error, storagePath }, 'Failed to delete from Supabase Storage');
       throw new Error(`Failed to delete file: ${error.message}`);
     }

     logger.info({ storagePath }, 'File deleted from storage');
   }
   ```

3. Create src/storage/download.ts:
   ```typescript
   import { getSupabaseClient } from '../lib/supabase.js';
   import { logger } from '../index.js';
   import { BUCKET_NAME, SIGNED_URL_EXPIRY, SignedUrlResult } from './types.js';

   /**
    * Generate signed download URL for a resource file
    * SEC-05: 1-hour expiration
    * SEC-06: Content-Disposition: attachment header via download option
    */
   export async function generateSignedUrl(
     storagePath: string,
     filename: string
   ): Promise<SignedUrlResult> {
     const supabase = getSupabaseClient();

     const { data, error } = await supabase.storage
       .from(BUCKET_NAME)
       .createSignedUrl(storagePath, SIGNED_URL_EXPIRY, {
         download: filename, // Sets Content-Disposition: attachment; filename="..."
       });

     if (error || !data?.signedUrl) {
       logger.error({ error, storagePath }, 'Failed to create signed URL');
       throw new Error('Failed to generate download URL');
     }

     return {
       url: data.signedUrl,
       expiresAt: new Date(Date.now() + SIGNED_URL_EXPIRY * 1000),
     };
   }
   ```
  </action>
  <verify>
npm run build
ls src/storage/types.ts src/storage/upload.ts src/storage/download.ts
grep -q "MAX_FILE_SIZE" src/storage/types.ts
grep -q "uploadToStorage" src/storage/upload.ts
grep -q "generateSignedUrl" src/storage/download.ts
  </verify>
  <done>
Storage service complete: upload middleware (100MB limit), Supabase upload function, signed URL generation (1-hour, attachment header).
  </done>
</task>

<task type="auto">
  <name>Task 3: Create resource domain types</name>
  <files>
    src/resources/types.ts
  </files>
  <action>
Create src/resources/types.ts with domain types for resource operations:

```typescript
import { ResourceType, ResourceStatus } from '@prisma/client';

/**
 * Resource with version and download details
 * Used for detail views and admin management
 */
export interface ResourceWithDetails {
  id: string;
  title: string;
  description: string;
  tags: string[];
  type: ResourceType;
  status: ResourceStatus;
  publishAt: Date | null;
  author: string | null;
  uploadedBy: string | null;
  storagePath: string;
  fileSize: number | null;
  mimeType: string | null;
  isFeatured: boolean;
  downloadCount: number;
  currentVersion: number;
  createdAt: Date;
  updatedAt: Date;
  deletedAt: Date | null;
}

/**
 * Input for creating a new resource
 */
export interface CreateResourceInput {
  title: string;
  description: string;
  tags: string[];
  type: ResourceType;
  status?: ResourceStatus;
  publishAt?: Date;
  author?: string;
  isFeatured?: boolean;
}

/**
 * Input for updating resource metadata
 * Note: File replacement is separate (creates new version)
 */
export interface UpdateResourceInput {
  title?: string;
  description?: string;
  tags?: string[];
  type?: ResourceType;
  status?: ResourceStatus;
  publishAt?: Date | null;
  author?: string | null;
  isFeatured?: boolean;
}

/**
 * Resource list item (for browse views)
 * Lighter than full details
 */
export interface ResourceListItem {
  id: string;
  title: string;
  description: string;
  tags: string[];
  type: ResourceType;
  author: string | null;
  fileSize: number | null;
  mimeType: string | null;
  isFeatured: boolean;
  downloadCount: number;
  createdAt: Date;
}

/**
 * Filters for resource listing
 */
export interface ResourceFilters {
  tags?: string[];
  type?: ResourceType;
  search?: string;
  isFeatured?: boolean;
}

/**
 * Resource analytics data
 */
export interface ResourceAnalytics {
  totalResources: number;
  totalDownloads: number;
  uniqueDownloaders: number;
  downloadsByResource: {
    resourceId: string;
    title: string;
    downloads: number;
    uniqueDownloaders: number;
  }[];
  trendingResources: {
    resourceId: string;
    title: string;
    recentDownloads: number; // Downloads in last 7 days
  }[];
}

/**
 * Version info for version history
 */
export interface ResourceVersionInfo {
  id: string;
  version: number;
  fileSize: number | null;
  changelog: string | null;
  uploadedBy: string;
  createdAt: Date;
}
```
  </action>
  <verify>
npm run build
grep -q "ResourceWithDetails" src/resources/types.ts
grep -q "CreateResourceInput" src/resources/types.ts
grep -q "ResourceFilters" src/resources/types.ts
  </verify>
  <done>
Resource domain types defined: CRUD inputs, list items, filters, analytics, version info.
  </done>
</task>

</tasks>

<verification>
- [ ] npm run build compiles without errors
- [ ] multer and @types/multer installed
- [ ] uploadLimiter exported from rate-limit.ts
- [ ] Storage types define MAX_FILE_SIZE = 100MB
- [ ] uploadMiddleware handles single file with size limit
- [ ] uploadToStorage writes to Supabase with sanitized paths
- [ ] generateSignedUrl returns URL with 1-hour expiry
- [ ] Resource types cover all CRUD operations
</verification>

<success_criteria>
1. Upload rate limiter enforces 5 files/hour/admin (SEC-07)
2. Multer middleware limits files to 100MB (SEC-01)
3. uploadToStorage writes to Supabase with organized paths
4. generateSignedUrl returns 1-hour URLs with attachment headers (SEC-05, SEC-06)
5. Resource domain types ready for service layer
</success_criteria>

<output>
After completion, create `.planning/phases/29-resource-library/29-02-SUMMARY.md`
</output>
