---
phase: 29-resource-library
plan: 02
type: execute
wave: 2
depends_on: ["29-01"]
files_modified:
  - src/middleware/rate-limit.ts
  - src/storage/types.ts
  - src/storage/upload.ts
  - src/storage/download.ts
  - src/storage/malware-scan.ts
  - src/resources/types.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "File uploads limited to 100MB (SEC-01)"
    - "Upload rate limited to 5 files per hour per admin (SEC-07)"
    - "Files upload to Supabase Storage private bucket"
    - "Signed URLs generated with 1-hour expiry (SEC-05)"
    - "Signed URLs include Content-Disposition: attachment (SEC-06)"
    - "Storage paths organized by admin ID and timestamp"
    - "Malware scanning available via ClamAV when enabled (SEC-04)"
  artifacts:
    - path: "src/middleware/rate-limit.ts"
      provides: "uploadLimiter for 5 files/hour/admin"
      exports: ["uploadLimiter"]
    - path: "src/storage/types.ts"
      provides: "Storage constants and types"
      exports: ["MAX_FILE_SIZE", "BUCKET_NAME", "SIGNED_URL_EXPIRY"]
    - path: "src/storage/upload.ts"
      provides: "Multer middleware and Supabase upload function"
      exports: ["uploadMiddleware", "uploadToStorage"]
    - path: "src/storage/download.ts"
      provides: "Signed URL generation"
      exports: ["generateSignedUrl"]
    - path: "src/storage/malware-scan.ts"
      provides: "Optional ClamAV malware scanning"
      exports: ["scanForMalware", "isMalwareScanEnabled"]
    - path: "src/resources/types.ts"
      provides: "Resource domain types"
      exports: ["ResourceWithDetails", "CreateResourceInput"]
  key_links:
    - from: "src/storage/upload.ts"
      to: "src/lib/supabase.ts"
      via: "getSupabaseClient() call"
      pattern: "getSupabaseClient\\(\\)"
    - from: "src/storage/upload.ts"
      to: "src/lib/file-validation.ts"
      via: "validateFileType() call"
      pattern: "validateFileType\\("
    - from: "src/storage/upload.ts"
      to: "src/storage/malware-scan.ts"
      via: "scanForMalware() call when enabled"
      pattern: "scanForMalware\\("
    - from: "src/storage/download.ts"
      to: "src/lib/supabase.ts"
      via: "getSupabaseClient() call"
      pattern: "getSupabaseClient\\(\\)"
---

<objective>
Build storage infrastructure with rate limiting, upload/download services, malware scanning, and resource types.

Purpose: Create the complete storage layer that handles file uploads to Supabase, generates signed URLs, optionally scans for malware, and enforces security constraints (size limits, rate limits).

Output: Ready-to-use storage services for resource service layer.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-resource-library/29-CONTEXT.md
@.planning/phases/29-resource-library/29-RESEARCH.md
@.planning/phases/29-resource-library/29-01-SUMMARY.md
@src/lib/supabase.ts
@src/lib/file-validation.ts
@src/middleware/rate-limit.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add upload rate limiter and install multer</name>
  <files>
    src/middleware/rate-limit.ts
    package.json
  </files>
  <action>
1. Install multer and types:
   npm install multer
   npm install --save-dev @types/multer

2. Update src/middleware/rate-limit.ts to add uploadLimiter:

   Import at top if not already present:
   - import rateLimit from 'express-rate-limit';

   Add new limiter (following existing pattern):
   ```typescript
   /**
    * Rate limiter for file uploads
    * SEC-07: 5 files per hour per admin
    * Keyed by admin ID from authenticated session
    */
   export const uploadLimiter = rateLimit({
     windowMs: 60 * 60 * 1000, // 1 hour
     max: 5,
     message: { error: 'Upload limit reached. You can upload up to 5 files per hour.' },
     standardHeaders: true,
     legacyHeaders: false,
     keyGenerator: (req) => {
       // Key by admin ID from authenticated session (set by requireAdmin middleware)
       const adminId = (req as any).adminId || res.locals?.admin?.id || req.ip;
       return `upload:${adminId}`;
     },
   });
   ```

Note: The adminId will come from res.locals.admin.id set by requireAdmin middleware. Since keyGenerator only has access to req, we need to handle this carefully - the admin ID might be stored on req by middleware. Check existing admin middleware pattern.
  </action>
  <verify>
npm run build
grep -q "uploadLimiter" src/middleware/rate-limit.ts
grep -q "5 files per hour" src/middleware/rate-limit.ts
  </verify>
  <done>
Upload rate limiter configured for 5 files per hour per admin. Multer installed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create storage service layer with malware scanning</name>
  <files>
    src/storage/types.ts
    src/storage/upload.ts
    src/storage/download.ts
    src/storage/malware-scan.ts
    src/config/env.ts
  </files>
  <action>
Create storage service directory and files:

1. Update src/config/env.ts to add optional malware scanning env var:
   ```typescript
   // Add to schema (optional - malware scanning disabled by default)
   CLAMAV_HOST: z.string().optional(), // e.g., 'localhost' or '127.0.0.1'
   CLAMAV_PORT: z.coerce.number().optional().default(3310),
   ENABLE_MALWARE_SCAN: z.enum(['true', 'false']).optional().default('false'),
   ```

2. Create src/storage/types.ts:
   ```typescript
   // Storage constants per requirements
   export const MAX_FILE_SIZE = 100 * 1024 * 1024; // SEC-01: 100MB
   export const BUCKET_NAME = 'resources';
   export const SIGNED_URL_EXPIRY = 3600; // SEC-05: 1 hour in seconds

   // Allowed extensions for preliminary check (magic number validation is authoritative)
   export const ALLOWED_EXTENSIONS = ['.pdf', '.docx', '.xlsx', '.mp4', '.zip'];

   export interface UploadResult {
     storagePath: string;
     fileSize: number;
     mimeType: string;
   }

   export interface SignedUrlResult {
     url: string;
     expiresAt: Date;
   }

   export interface MalwareScanResult {
     clean: boolean;
     threat?: string;
     scanned: boolean; // false if scanning disabled/unavailable
   }
   ```

3. Create src/storage/malware-scan.ts (SEC-04):
   ```typescript
   /**
    * Optional malware scanning via ClamAV
    * SEC-04: Scan uploaded files for malware
    *
    * Requires ClamAV daemon running. Disabled by default.
    * Enable via ENABLE_MALWARE_SCAN=true and CLAMAV_HOST env vars.
    */
   import { env } from '../config/env.js';
   import { logger } from '../index.js';
   import type { MalwareScanResult } from './types.js';

   // Lazy-loaded clamscan instance
   let clamInstance: any = null;

   /**
    * Check if malware scanning is enabled and available
    */
   export function isMalwareScanEnabled(): boolean {
     return env.ENABLE_MALWARE_SCAN === 'true' && !!env.CLAMAV_HOST;
   }

   /**
    * Initialize ClamAV client (lazy, once)
    */
   async function getClamClient(): Promise<any> {
     if (clamInstance) return clamInstance;

     if (!isMalwareScanEnabled()) {
       return null;
     }

     try {
       // Dynamic import - clamscan is optional dependency
       const NodeClam = (await import('clamscan')).default;

       clamInstance = await new NodeClam().init({
         clamdscan: {
           host: env.CLAMAV_HOST,
           port: env.CLAMAV_PORT || 3310,
           timeout: 60000, // 60 second timeout for large files
           localFallback: false,
         },
         preference: 'clamdscan',
       });

       logger.info({ host: env.CLAMAV_HOST, port: env.CLAMAV_PORT }, 'ClamAV client initialized');
       return clamInstance;
     } catch (error) {
       logger.error({ error }, 'Failed to initialize ClamAV client - malware scanning disabled');
       return null;
     }
   }

   /**
    * Scan a file buffer for malware
    * Returns clean: true if no malware detected or scanning disabled
    */
   export async function scanForMalware(buffer: Buffer, filename: string): Promise<MalwareScanResult> {
     if (!isMalwareScanEnabled()) {
       return { clean: true, scanned: false };
     }

     const clam = await getClamClient();
     if (!clam) {
       logger.warn({ filename }, 'ClamAV unavailable - skipping malware scan');
       return { clean: true, scanned: false };
     }

     try {
       // Scan the buffer directly
       const { isInfected, viruses } = await clam.scanBuffer(buffer);

       if (isInfected) {
         const threat = viruses?.join(', ') || 'Unknown threat';
         logger.warn({ filename, threat }, 'Malware detected in uploaded file');
         return { clean: false, threat, scanned: true };
       }

       logger.info({ filename }, 'File passed malware scan');
       return { clean: true, scanned: true };
     } catch (error) {
       logger.error({ error, filename }, 'Malware scan failed');
       // Fail open with warning - don't block uploads if scanner errors
       // Change to fail closed (return clean: false) for stricter security
       return { clean: true, scanned: false };
     }
   }
   ```

4. Create src/storage/upload.ts:
   ```typescript
   import multer from 'multer';
   import { RequestHandler } from 'express';
   import { getSupabaseClient } from '../lib/supabase.js';
   import { validateFileType } from '../lib/file-validation.js';
   import { scanForMalware, isMalwareScanEnabled } from './malware-scan.js';
   import { logger } from '../index.js';
   import { MAX_FILE_SIZE, BUCKET_NAME, ALLOWED_EXTENSIONS, UploadResult } from './types.js';

   // Multer memory storage - file in req.file.buffer
   const storage = multer.memoryStorage();

   // Preliminary extension filter (magic number validation happens after)
   const fileFilter: multer.Options['fileFilter'] = (req, file, cb) => {
     const ext = '.' + file.originalname.split('.').pop()?.toLowerCase();
     if (!ALLOWED_EXTENSIONS.includes(ext)) {
       cb(new Error(`File extension ${ext} not allowed. Allowed: ${ALLOWED_EXTENSIONS.join(', ')}`));
       return;
     }
     cb(null, true);
   };

   /**
    * Multer middleware for single file upload
    * SEC-01: 100MB limit
    * SEC-02: Extension pre-filter (magic validation after)
    */
   export const uploadMiddleware: RequestHandler = multer({
     storage,
     limits: {
       fileSize: MAX_FILE_SIZE,
       files: 1,
     },
     fileFilter,
   }).single('file');

   /**
    * Upload validated file to Supabase Storage
    * Call AFTER uploadMiddleware and validateFileType
    * Includes optional malware scan (SEC-04)
    */
   export async function uploadToStorage(
     buffer: Buffer,
     originalFilename: string,
     adminId: string,
     validatedMime: string
   ): Promise<UploadResult> {
     // SEC-04: Malware scan (if enabled)
     const scanResult = await scanForMalware(buffer, originalFilename);
     if (!scanResult.clean) {
       throw new Error(`File rejected: malware detected (${scanResult.threat})`);
     }

     const supabase = getSupabaseClient();

     // Generate unique path: uploads/{adminId}/{timestamp}-{sanitized-filename}
     const timestamp = Date.now();
     const safeFilename = originalFilename.replace(/[^a-zA-Z0-9.-]/g, '_');
     const storagePath = `uploads/${adminId}/${timestamp}-${safeFilename}`;

     const { error } = await supabase.storage
       .from(BUCKET_NAME)
       .upload(storagePath, buffer, {
         contentType: validatedMime,
         upsert: false, // Fail if exists (unique paths anyway)
       });

     if (error) {
       logger.error({ error, storagePath }, 'Failed to upload to Supabase Storage');
       throw new Error(`Failed to upload file: ${error.message}`);
     }

     logger.info({
       storagePath,
       fileSize: buffer.length,
       mimeType: validatedMime,
       malwareScanned: scanResult.scanned,
     }, 'File uploaded to storage');

     return {
       storagePath,
       fileSize: buffer.length,
       mimeType: validatedMime,
     };
   }

   /**
    * Delete file from Supabase Storage
    * Used when resource is deleted or version pruned
    */
   export async function deleteFromStorage(storagePath: string): Promise<void> {
     const supabase = getSupabaseClient();

     const { error } = await supabase.storage
       .from(BUCKET_NAME)
       .remove([storagePath]);

     if (error) {
       logger.error({ error, storagePath }, 'Failed to delete from Supabase Storage');
       throw new Error(`Failed to delete file: ${error.message}`);
     }

     logger.info({ storagePath }, 'File deleted from storage');
   }
   ```

5. Create src/storage/download.ts:
   ```typescript
   import { getSupabaseClient } from '../lib/supabase.js';
   import { logger } from '../index.js';
   import { BUCKET_NAME, SIGNED_URL_EXPIRY, SignedUrlResult } from './types.js';

   /**
    * Generate signed download URL for a resource file
    * SEC-05: 1-hour expiration
    * SEC-06: Content-Disposition: attachment header via download option
    */
   export async function generateSignedUrl(
     storagePath: string,
     filename: string
   ): Promise<SignedUrlResult> {
     const supabase = getSupabaseClient();

     const { data, error } = await supabase.storage
       .from(BUCKET_NAME)
       .createSignedUrl(storagePath, SIGNED_URL_EXPIRY, {
         download: filename, // Sets Content-Disposition: attachment; filename="..."
       });

     if (error || !data?.signedUrl) {
       logger.error({ error, storagePath }, 'Failed to create signed URL');
       throw new Error('Failed to generate download URL');
     }

     return {
       url: data.signedUrl,
       expiresAt: new Date(Date.now() + SIGNED_URL_EXPIRY * 1000),
     };
   }
   ```

6. Update .env.example with malware scanning vars (optional):
   ```
   # Malware Scanning (optional - requires ClamAV daemon)
   # ENABLE_MALWARE_SCAN=true
   # CLAMAV_HOST=localhost
   # CLAMAV_PORT=3310
   ```

7. Note: clamscan is an optional peer dependency. Add to package.json optionalDependencies if desired, or document that it should be installed manually when ENABLE_MALWARE_SCAN=true.
  </action>
  <verify>
npm run build
ls src/storage/types.ts src/storage/upload.ts src/storage/download.ts src/storage/malware-scan.ts
grep -q "MAX_FILE_SIZE" src/storage/types.ts
grep -q "uploadToStorage" src/storage/upload.ts
grep -q "generateSignedUrl" src/storage/download.ts
grep -q "scanForMalware" src/storage/malware-scan.ts
grep -q "ENABLE_MALWARE_SCAN" src/config/env.ts
  </verify>
  <done>
Storage service complete: upload middleware (100MB limit), Supabase upload function, signed URL generation (1-hour, attachment header), optional malware scanning via ClamAV (SEC-04).
  </done>
</task>

<task type="auto">
  <name>Task 3: Create resource domain types</name>
  <files>
    src/resources/types.ts
  </files>
  <action>
Create src/resources/types.ts with domain types for resource operations:

```typescript
import { ResourceType, ResourceStatus } from '@prisma/client';

/**
 * Resource with version and download details
 * Used for detail views and admin management
 */
export interface ResourceWithDetails {
  id: string;
  title: string;
  description: string;
  tags: string[];
  type: ResourceType;
  status: ResourceStatus;
  publishAt: Date | null;
  author: string | null;
  uploadedBy: string | null;
  storagePath: string;
  fileSize: number | null;
  mimeType: string | null;
  isFeatured: boolean;
  downloadCount: number;
  currentVersion: number;
  createdAt: Date;
  updatedAt: Date;
  deletedAt: Date | null;
}

/**
 * Input for creating a new resource
 */
export interface CreateResourceInput {
  title: string;
  description: string;
  tags: string[];
  type: ResourceType;
  status?: ResourceStatus;
  publishAt?: Date;
  author?: string;
  isFeatured?: boolean;
}

/**
 * Input for updating resource metadata
 * Note: File replacement is separate (creates new version)
 */
export interface UpdateResourceInput {
  title?: string;
  description?: string;
  tags?: string[];
  type?: ResourceType;
  status?: ResourceStatus;
  publishAt?: Date | null;
  author?: string | null;
  isFeatured?: boolean;
}

/**
 * Resource list item (for browse views)
 * Lighter than full details
 */
export interface ResourceListItem {
  id: string;
  title: string;
  description: string;
  tags: string[];
  type: ResourceType;
  author: string | null;
  fileSize: number | null;
  mimeType: string | null;
  isFeatured: boolean;
  downloadCount: number;
  createdAt: Date;
}

/**
 * Admin resource list item (includes status for management)
 */
export interface AdminResourceListItem extends ResourceListItem {
  status: ResourceStatus;
  publishAt: Date | null;
  uploadedBy: string | null;
  deletedAt: Date | null;
}

/**
 * Filters for resource listing (member view - published only)
 */
export interface ResourceFilters {
  tags?: string[];
  type?: ResourceType;
  search?: string;
  isFeatured?: boolean;
}

/**
 * Filters for admin resource listing (all statuses)
 */
export interface AdminResourceFilters extends ResourceFilters {
  status?: ResourceStatus;
  includeDeleted?: boolean;
}

/**
 * Resource analytics data
 */
export interface ResourceAnalytics {
  totalResources: number;
  totalDownloads: number;
  uniqueDownloaders: number;
  downloadsByResource: {
    resourceId: string;
    title: string;
    downloads: number;
    uniqueDownloaders: number;
  }[];
  trendingResources: {
    resourceId: string;
    title: string;
    recentDownloads: number; // Downloads in last 7 days
  }[];
}

/**
 * Version info for version history
 */
export interface ResourceVersionInfo {
  id: string;
  version: number;
  fileSize: number | null;
  changelog: string | null;
  uploadedBy: string;
  createdAt: Date;
}
```
  </action>
  <verify>
npm run build
grep -q "ResourceWithDetails" src/resources/types.ts
grep -q "CreateResourceInput" src/resources/types.ts
grep -q "ResourceFilters" src/resources/types.ts
grep -q "AdminResourceFilters" src/resources/types.ts
grep -q "AdminResourceListItem" src/resources/types.ts
  </verify>
  <done>
Resource domain types defined: CRUD inputs, list items, filters, analytics, version info. Added AdminResourceListItem and AdminResourceFilters for admin management view.
  </done>
</task>

</tasks>

<verification>
- [ ] npm run build compiles without errors
- [ ] multer and @types/multer installed
- [ ] uploadLimiter exported from rate-limit.ts
- [ ] Storage types define MAX_FILE_SIZE = 100MB
- [ ] uploadMiddleware handles single file with size limit
- [ ] uploadToStorage writes to Supabase with sanitized paths
- [ ] uploadToStorage calls scanForMalware when enabled (SEC-04)
- [ ] generateSignedUrl returns URL with 1-hour expiry
- [ ] scanForMalware function exists with feature flag check
- [ ] ENABLE_MALWARE_SCAN env var added to config
- [ ] Resource types cover all CRUD operations including admin filters
</verification>

<success_criteria>
1. Upload rate limiter enforces 5 files/hour/admin (SEC-07)
2. Multer middleware limits files to 100MB (SEC-01)
3. uploadToStorage writes to Supabase with organized paths
4. Malware scanning available via ClamAV when ENABLE_MALWARE_SCAN=true (SEC-04)
5. generateSignedUrl returns 1-hour URLs with attachment headers (SEC-05, SEC-06)
6. Resource domain types ready for service layer (including admin-specific types)
</success_criteria>

<output>
After completion, create `.planning/phases/29-resource-library/29-02-SUMMARY.md`
</output>
