---
phase: 29-resource-library
plan: 03
type: execute
wave: 3
depends_on: ["29-01", "29-02"]
files_modified:
  - src/resources/service.ts
  - src/lib/audit.ts
autonomous: true

must_haves:
  truths:
    - "Admin can create resource with file upload, metadata, and tags"
    - "Admin can update resource metadata without creating new file version"
    - "Admin can upload new file version with changelog (creates ResourceVersion record)"
    - "Admin can soft delete resource (sets deletedAt)"
    - "Member can browse published resources with tag/type/search filters"
    - "Member can download resource and receive signed URL"
    - "Download awards +5 points (first download only per resource)"
    - "Download tracked in ResourceDownload table"
    - "Admin can view resource analytics (downloads, unique downloaders, trending)"
    - "Version history retained (last 5 versions per resource)"
  artifacts:
    - path: "src/resources/service.ts"
      provides: "Resource business logic for CRUD, download, analytics"
      exports: ["createResource", "updateResource", "uploadNewVersion", "softDeleteResource", "listResources", "downloadResource", "getResourceAnalytics"]
    - path: "src/lib/audit.ts"
      provides: "Resource audit actions"
      contains: "RESOURCE_CREATED"
  key_links:
    - from: "src/resources/service.ts"
      to: "src/storage/upload.ts"
      via: "uploadToStorage() call"
      pattern: "uploadToStorage\\("
    - from: "src/resources/service.ts"
      to: "src/storage/download.ts"
      via: "generateSignedUrl() call"
      pattern: "generateSignedUrl\\("
    - from: "src/resources/service.ts"
      to: "src/points/service.ts"
      via: "awardDownloadPoints() call"
      pattern: "awardDownloadPoints\\("
    - from: "src/resources/service.ts"
      to: "prisma"
      via: "prisma.resource, prisma.resourceVersion, prisma.resourceDownload"
      pattern: "prisma\\.resource"
---

<objective>
Build the resource service layer with CRUD operations, download handling, and analytics.

Purpose: Implement all business logic for resource management - admin CRUD with versioning, member browsing and downloads with points integration, and analytics for admin dashboard.

Output: Complete service layer ready for API routes.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-resource-library/29-CONTEXT.md
@.planning/phases/29-resource-library/29-RESEARCH.md
@.planning/phases/29-resource-library/29-01-SUMMARY.md
@.planning/phases/29-resource-library/29-02-SUMMARY.md
@src/storage/upload.ts
@src/storage/download.ts
@src/resources/types.ts
@src/points/service.ts
@src/lib/audit.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add resource audit actions</name>
  <files>
    src/lib/audit.ts
  </files>
  <action>
Update src/lib/audit.ts to add resource-related audit actions to the AuditAction object:

```typescript
// Add to existing AuditAction object:

// Resource actions
RESOURCE_CREATED: 'RESOURCE_CREATED',
RESOURCE_UPDATED: 'RESOURCE_UPDATED',
RESOURCE_VERSION_UPLOADED: 'RESOURCE_VERSION_UPLOADED',
RESOURCE_DELETED: 'RESOURCE_DELETED',
RESOURCE_RESTORED: 'RESOURCE_RESTORED',
```

Also update the EntityType union to include 'Resource':
```typescript
export type EntityType = 'Admin' | 'Member' | 'Team' | 'FeatureFlag' | 'EmailTemplate' | 'Resource';
```
  </action>
  <verify>
npm run build
grep -q "RESOURCE_CREATED" src/lib/audit.ts
grep -q "'Resource'" src/lib/audit.ts
  </verify>
  <done>
Audit actions added for resource operations. EntityType includes 'Resource'.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create resource service layer</name>
  <files>
    src/resources/service.ts
  </files>
  <action>
Create src/resources/service.ts with complete business logic:

```typescript
/**
 * Resource service layer
 * Handles CRUD, downloads, versioning, and analytics
 */
import { prisma } from '../lib/prisma.js';
import { logger } from '../index.js';
import { uploadToStorage, deleteFromStorage } from '../storage/upload.js';
import { generateSignedUrl } from '../storage/download.js';
import { validateFileType } from '../lib/file-validation.js';
import { awardDownloadPoints } from '../points/service.js';
import { logAuditEvent, AuditAction } from '../lib/audit.js';
import { ResourceStatus, ResourceType } from '@prisma/client';
import type {
  CreateResourceInput,
  UpdateResourceInput,
  ResourceFilters,
  ResourceListItem,
  ResourceWithDetails,
  ResourceAnalytics,
  ResourceVersionInfo,
} from './types.js';

// Version retention limit per CONTEXT.md (Claude's discretion: keep last 5)
const MAX_VERSIONS_TO_KEEP = 5;

/**
 * Create a new resource with file upload
 * RES-01: Admin uploads file with metadata
 */
export async function createResource(
  file: { buffer: Buffer; originalname: string },
  input: CreateResourceInput,
  adminId: string
): Promise<ResourceWithDetails> {
  // Validate file type via magic number (RES-02)
  const validation = await validateFileType(file.buffer, file.originalname);
  if (!validation.valid) {
    throw new Error(validation.error);
  }

  // Upload to Supabase Storage (RES-03)
  const uploadResult = await uploadToStorage(
    file.buffer,
    file.originalname,
    adminId,
    validation.detectedMime!
  );

  // Create resource and initial version in transaction
  const resource = await prisma.$transaction(async (tx) => {
    const res = await tx.resource.create({
      data: {
        title: input.title,
        description: input.description,
        tags: input.tags,
        type: input.type,
        status: input.status ?? 'DRAFT',
        publishAt: input.publishAt ?? null,
        author: input.author ?? null,
        isFeatured: input.isFeatured ?? false,
        uploadedBy: adminId,
        storagePath: uploadResult.storagePath,
        fileSize: uploadResult.fileSize,
        mimeType: uploadResult.mimeType,
        currentVersion: 1,
      },
    });

    // Create initial version record
    await tx.resourceVersion.create({
      data: {
        resourceId: res.id,
        version: 1,
        storagePath: uploadResult.storagePath,
        fileSize: uploadResult.fileSize,
        uploadedBy: adminId,
      },
    });

    return res;
  });

  // Log audit event
  await logAuditEvent({
    action: AuditAction.RESOURCE_CREATED,
    entityType: 'Resource',
    entityId: resource.id,
    details: {
      title: resource.title,
      type: resource.type,
      tags: resource.tags,
      status: resource.status,
    },
    performedBy: adminId,
  });

  logger.info({ resourceId: resource.id, title: resource.title }, 'Resource created');

  return resource as ResourceWithDetails;
}

/**
 * Update resource metadata (no file change)
 * RES-12: Admin can update title, description, tags, etc.
 * Does NOT create new version - metadata is independent of file
 */
export async function updateResource(
  resourceId: string,
  input: UpdateResourceInput,
  adminId: string
): Promise<ResourceWithDetails> {
  const existing = await prisma.resource.findUnique({
    where: { id: resourceId },
  });

  if (!existing || existing.deletedAt) {
    throw new Error('Resource not found');
  }

  const resource = await prisma.resource.update({
    where: { id: resourceId },
    data: {
      ...(input.title !== undefined && { title: input.title }),
      ...(input.description !== undefined && { description: input.description }),
      ...(input.tags !== undefined && { tags: input.tags }),
      ...(input.type !== undefined && { type: input.type }),
      ...(input.status !== undefined && { status: input.status }),
      ...(input.publishAt !== undefined && { publishAt: input.publishAt }),
      ...(input.author !== undefined && { author: input.author }),
      ...(input.isFeatured !== undefined && { isFeatured: input.isFeatured }),
    },
  });

  await logAuditEvent({
    action: AuditAction.RESOURCE_UPDATED,
    entityType: 'Resource',
    entityId: resourceId,
    details: { updates: input },
    performedBy: adminId,
  });

  logger.info({ resourceId, updates: input }, 'Resource metadata updated');

  return resource as ResourceWithDetails;
}

/**
 * Upload new file version
 * RES-13: Replace file with version history
 */
export async function uploadNewVersion(
  resourceId: string,
  file: { buffer: Buffer; originalname: string },
  changelog: string | undefined,
  adminId: string
): Promise<{ resource: ResourceWithDetails; version: ResourceVersionInfo }> {
  const existing = await prisma.resource.findUnique({
    where: { id: resourceId },
  });

  if (!existing || existing.deletedAt) {
    throw new Error('Resource not found');
  }

  // Validate file type
  const validation = await validateFileType(file.buffer, file.originalname);
  if (!validation.valid) {
    throw new Error(validation.error);
  }

  // Upload to storage
  const uploadResult = await uploadToStorage(
    file.buffer,
    file.originalname,
    adminId,
    validation.detectedMime!
  );

  const newVersionNumber = existing.currentVersion + 1;

  // Create version and update resource in transaction
  const result = await prisma.$transaction(async (tx) => {
    // Create new version
    const version = await tx.resourceVersion.create({
      data: {
        resourceId,
        version: newVersionNumber,
        storagePath: uploadResult.storagePath,
        fileSize: uploadResult.fileSize,
        changelog: changelog ?? null,
        uploadedBy: adminId,
      },
    });

    // Update resource to point to new version
    const resource = await tx.resource.update({
      where: { id: resourceId },
      data: {
        storagePath: uploadResult.storagePath,
        fileSize: uploadResult.fileSize,
        mimeType: uploadResult.mimeType,
        currentVersion: newVersionNumber,
      },
    });

    return { resource, version };
  });

  // Prune old versions (keep last MAX_VERSIONS_TO_KEEP)
  await pruneOldVersions(resourceId);

  await logAuditEvent({
    action: AuditAction.RESOURCE_VERSION_UPLOADED,
    entityType: 'Resource',
    entityId: resourceId,
    details: {
      version: newVersionNumber,
      changelog,
      previousVersion: existing.currentVersion,
    },
    performedBy: adminId,
  });

  logger.info({ resourceId, version: newVersionNumber, changelog }, 'New resource version uploaded');

  return {
    resource: result.resource as ResourceWithDetails,
    version: result.version as ResourceVersionInfo,
  };
}

/**
 * Prune old versions beyond retention limit
 * Deletes files from storage and version records
 */
async function pruneOldVersions(resourceId: string): Promise<void> {
  const versions = await prisma.resourceVersion.findMany({
    where: { resourceId },
    orderBy: { version: 'desc' },
  });

  if (versions.length <= MAX_VERSIONS_TO_KEEP) {
    return;
  }

  const versionsToDelete = versions.slice(MAX_VERSIONS_TO_KEEP);

  for (const version of versionsToDelete) {
    try {
      await deleteFromStorage(version.storagePath);
    } catch (err) {
      logger.warn({ resourceId, version: version.version, error: err }, 'Failed to delete old version file');
    }

    await prisma.resourceVersion.delete({
      where: { id: version.id },
    });
  }

  logger.info(
    { resourceId, deletedVersions: versionsToDelete.length },
    'Pruned old resource versions'
  );
}

/**
 * Soft delete resource
 * RES-14: Sets deletedAt, preserves for audit
 */
export async function softDeleteResource(
  resourceId: string,
  adminId: string
): Promise<void> {
  const existing = await prisma.resource.findUnique({
    where: { id: resourceId },
  });

  if (!existing) {
    throw new Error('Resource not found');
  }

  await prisma.resource.update({
    where: { id: resourceId },
    data: { deletedAt: new Date() },
  });

  await logAuditEvent({
    action: AuditAction.RESOURCE_DELETED,
    entityType: 'Resource',
    entityId: resourceId,
    details: { title: existing.title },
    performedBy: adminId,
  });

  logger.info({ resourceId, title: existing.title }, 'Resource soft deleted');
}

/**
 * Get resource by ID (admin view - includes drafts and scheduled)
 */
export async function getResourceById(
  resourceId: string,
  includeDeleted = false
): Promise<ResourceWithDetails | null> {
  const resource = await prisma.resource.findUnique({
    where: { id: resourceId },
  });

  if (!resource) return null;
  if (resource.deletedAt && !includeDeleted) return null;

  return resource as ResourceWithDetails;
}

/**
 * Get resource version history
 */
export async function getVersionHistory(resourceId: string): Promise<ResourceVersionInfo[]> {
  const versions = await prisma.resourceVersion.findMany({
    where: { resourceId },
    orderBy: { version: 'desc' },
  });

  return versions as ResourceVersionInfo[];
}

/**
 * List published resources for members
 * RES-06: Browse with filtering (tags, type, search)
 */
export async function listResources(
  filters: ResourceFilters,
  cursor?: string,
  limit = 20
): Promise<{ resources: ResourceListItem[]; nextCursor: string | null }> {
  const now = new Date();

  const where: any = {
    deletedAt: null,
    OR: [
      { status: 'PUBLISHED' },
      { status: 'SCHEDULED', publishAt: { lte: now } }, // Scheduled and past publish date
    ],
  };

  // Tag filter (any of the provided tags)
  if (filters.tags && filters.tags.length > 0) {
    where.tags = { hasSome: filters.tags };
  }

  // Type filter
  if (filters.type) {
    where.type = filters.type;
  }

  // Featured filter
  if (filters.isFeatured !== undefined) {
    where.isFeatured = filters.isFeatured;
  }

  // Search filter (title and description)
  if (filters.search) {
    where.AND = [
      {
        OR: [
          { title: { contains: filters.search, mode: 'insensitive' } },
          { description: { contains: filters.search, mode: 'insensitive' } },
        ],
      },
    ];
  }

  const resources = await prisma.resource.findMany({
    take: limit + 1,
    skip: cursor ? 1 : 0,
    cursor: cursor ? { id: cursor } : undefined,
    where,
    orderBy: [
      { isFeatured: 'desc' }, // Featured first
      { createdAt: 'desc' },
    ],
    select: {
      id: true,
      title: true,
      description: true,
      tags: true,
      type: true,
      author: true,
      fileSize: true,
      mimeType: true,
      isFeatured: true,
      downloadCount: true,
      createdAt: true,
    },
  });

  const hasMore = resources.length > limit;
  const results = hasMore ? resources.slice(0, limit) : resources;

  return {
    resources: results as ResourceListItem[],
    nextCursor: hasMore ? results[results.length - 1].id : null,
  };
}

/**
 * Download resource
 * RES-08, RES-09, RES-10: Generate signed URL, track download, award points
 */
export async function downloadResource(
  resourceId: string,
  memberId: string
): Promise<{ url: string; expiresAt: Date; pointsAwarded: boolean }> {
  const resource = await prisma.resource.findUnique({
    where: { id: resourceId },
  });

  if (!resource || resource.deletedAt) {
    throw new Error('Resource not found');
  }

  // Check if published (or scheduled and past publish date)
  const now = new Date();
  const isPublished =
    resource.status === 'PUBLISHED' ||
    (resource.status === 'SCHEDULED' && resource.publishAt && resource.publishAt <= now);

  if (!isPublished) {
    throw new Error('Resource not available');
  }

  // Generate signed URL (SEC-05, SEC-06)
  const signedUrl = await generateSignedUrl(resource.storagePath, resource.title);

  // Record download (RES-09)
  await prisma.resourceDownload.create({
    data: {
      memberId,
      resourceId,
    },
  });

  // Increment download count (denormalized for fast sorting)
  await prisma.resource.update({
    where: { id: resourceId },
    data: { downloadCount: { increment: 1 } },
  });

  // Award points (RES-10) - first download only per resource (handled by awardDownloadPoints idempotency)
  const pointsResult = await awardDownloadPoints(memberId, resourceId, resource.title);

  logger.info(
    { resourceId, memberId, pointsAwarded: pointsResult.awarded },
    'Resource downloaded'
  );

  return {
    url: signedUrl.url,
    expiresAt: signedUrl.expiresAt,
    pointsAwarded: pointsResult.awarded,
  };
}

/**
 * Get resource analytics for admin dashboard
 * RES-11: Downloads, unique downloaders, trending
 */
export async function getResourceAnalytics(): Promise<ResourceAnalytics> {
  const sevenDaysAgo = new Date();
  sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

  // Total resources (excluding deleted)
  const totalResources = await prisma.resource.count({
    where: { deletedAt: null },
  });

  // Total downloads
  const totalDownloads = await prisma.resourceDownload.count();

  // Unique downloaders
  const uniqueDownloaders = await prisma.resourceDownload.groupBy({
    by: ['memberId'],
  });

  // Downloads by resource
  const downloadsByResource = await prisma.resource.findMany({
    where: { deletedAt: null },
    select: {
      id: true,
      title: true,
      downloadCount: true,
      _count: {
        select: { downloads: true },
      },
      downloads: {
        select: { memberId: true },
        distinct: ['memberId'],
      },
    },
    orderBy: { downloadCount: 'desc' },
    take: 20,
  });

  // Trending resources (most downloads in last 7 days)
  const recentDownloads = await prisma.resourceDownload.groupBy({
    by: ['resourceId'],
    where: { downloadedAt: { gte: sevenDaysAgo } },
    _count: { resourceId: true },
    orderBy: { _count: { resourceId: 'desc' } },
    take: 10,
  });

  const trendingResourceIds = recentDownloads.map((d) => d.resourceId);
  const trendingResources = await prisma.resource.findMany({
    where: { id: { in: trendingResourceIds }, deletedAt: null },
    select: { id: true, title: true },
  });

  const trendingMap = new Map(trendingResources.map((r) => [r.id, r.title]));

  return {
    totalResources,
    totalDownloads,
    uniqueDownloaders: uniqueDownloaders.length,
    downloadsByResource: downloadsByResource.map((r) => ({
      resourceId: r.id,
      title: r.title,
      downloads: r.downloadCount,
      uniqueDownloaders: r.downloads.length,
    })),
    trendingResources: recentDownloads.map((d) => ({
      resourceId: d.resourceId,
      title: trendingMap.get(d.resourceId) ?? 'Unknown',
      recentDownloads: d._count.resourceId,
    })),
  };
}

/**
 * Get all tags (for admin management and member filtering)
 */
export async function getAllTags(): Promise<{ id: string; name: string }[]> {
  return prisma.resourceTag.findMany({
    orderBy: { name: 'asc' },
    select: { id: true, name: true },
  });
}

/**
 * Create new tag (admin only)
 */
export async function createTag(name: string, adminId: string): Promise<{ id: string; name: string }> {
  const tag = await prisma.resourceTag.create({
    data: {
      name: name.trim(),
      createdBy: adminId,
    },
  });

  logger.info({ tagId: tag.id, name: tag.name }, 'Resource tag created');

  return { id: tag.id, name: tag.name };
}

/**
 * Delete tag (admin only)
 * Note: Does not remove tag from existing resources
 */
export async function deleteTag(tagId: string): Promise<void> {
  await prisma.resourceTag.delete({
    where: { id: tagId },
  });

  logger.info({ tagId }, 'Resource tag deleted');
}

/**
 * Get recommended resources for member
 * RES-15: Simple recommendation based on previously downloaded resource tags
 */
export async function getRecommendedResources(
  memberId: string,
  limit = 5
): Promise<ResourceListItem[]> {
  // Get tags from member's downloaded resources
  const downloads = await prisma.resourceDownload.findMany({
    where: { memberId },
    select: { resource: { select: { tags: true } } },
    orderBy: { downloadedAt: 'desc' },
    take: 10, // Look at last 10 downloads
  });

  // Collect all tags
  const tagCounts = new Map<string, number>();
  for (const d of downloads) {
    for (const tag of d.resource.tags) {
      tagCounts.set(tag, (tagCounts.get(tag) || 0) + 1);
    }
  }

  // If no download history, return featured resources
  if (tagCounts.size === 0) {
    const { resources } = await listResources({ isFeatured: true }, undefined, limit);
    return resources;
  }

  // Sort tags by frequency
  const topTags = [...tagCounts.entries()]
    .sort((a, b) => b[1] - a[1])
    .slice(0, 3)
    .map(([tag]) => tag);

  // Get downloaded resource IDs to exclude
  const downloadedIds = await prisma.resourceDownload.findMany({
    where: { memberId },
    select: { resourceId: true },
  });
  const downloadedSet = new Set(downloadedIds.map((d) => d.resourceId));

  // Find resources with matching tags that member hasn't downloaded
  const now = new Date();
  const recommendations = await prisma.resource.findMany({
    where: {
      deletedAt: null,
      id: { notIn: [...downloadedSet] },
      tags: { hasSome: topTags },
      OR: [
        { status: 'PUBLISHED' },
        { status: 'SCHEDULED', publishAt: { lte: now } },
      ],
    },
    orderBy: { downloadCount: 'desc' },
    take: limit,
    select: {
      id: true,
      title: true,
      description: true,
      tags: true,
      type: true,
      author: true,
      fileSize: true,
      mimeType: true,
      isFeatured: true,
      downloadCount: true,
      createdAt: true,
    },
  });

  return recommendations as ResourceListItem[];
}
```
  </action>
  <verify>
npm run build
grep -q "createResource" src/resources/service.ts
grep -q "downloadResource" src/resources/service.ts
grep -q "getResourceAnalytics" src/resources/service.ts
grep -q "awardDownloadPoints" src/resources/service.ts
  </verify>
  <done>
Resource service complete with:
- Admin CRUD (create, update metadata, soft delete)
- Version management (upload new version, prune old versions - keep 5)
- Member operations (list with filters, download with signed URL)
- Points integration (first download only awards +5)
- Analytics (totals, per-resource, trending)
- Tag management (list, create, delete)
- Recommendations (based on download history tags)
  </done>
</task>

</tasks>

<verification>
- [ ] npm run build compiles without errors
- [ ] Audit actions include RESOURCE_CREATED, RESOURCE_UPDATED, etc.
- [ ] createResource validates file, uploads to storage, creates resource + version
- [ ] uploadNewVersion creates version record and prunes old versions
- [ ] softDeleteResource sets deletedAt timestamp
- [ ] listResources filters by tags, type, search; excludes deleted/draft
- [ ] downloadResource generates signed URL, records download, awards points
- [ ] getResourceAnalytics returns totals and trending data
- [ ] getRecommendedResources uses download history tags
</verification>

<success_criteria>
1. Resource CRUD with versioning (create, update metadata, upload new version, soft delete)
2. Version retention: maximum 5 versions kept, old ones pruned
3. Member listing: only published/scheduled-and-ready resources shown
4. Download flow: signed URL + ResourceDownload record + points award
5. Points: first download only per member+resource (idempotency from points service)
6. Analytics: totals, per-resource stats, trending (7-day window)
7. Recommendations: tag-based matching from download history
</success_criteria>

<output>
After completion, create `.planning/phases/29-resource-library/29-03-SUMMARY.md`
</output>
