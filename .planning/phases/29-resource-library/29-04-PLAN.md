---
phase: 29-resource-library
plan: 04
type: execute
wave: 4
depends_on: ["29-02", "29-03"]
files_modified:
  - src/routes/admin/resources.ts
  - src/routes/resources.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Admin can upload new resource with file and metadata via POST /api/admin/resources"
    - "Admin can update resource metadata via PATCH /api/admin/resources/:id"
    - "Admin can upload new version via POST /api/admin/resources/:id/version"
    - "Admin can soft delete resource via DELETE /api/admin/resources/:id"
    - "Admin can view analytics via GET /api/admin/resources/analytics"
    - "Admin can manage tags via GET/POST/DELETE /api/admin/resources/tags"
    - "Member can browse resources via GET /api/resources"
    - "Member can view resource details via GET /api/resources/:id"
    - "Member can download resource via POST /api/resources/:id/download"
    - "Member can get recommendations via GET /api/resources/recommended"
    - "Upload rate limited to 5 files per hour per admin"
    - "All admin actions create audit log entries"
  artifacts:
    - path: "src/routes/admin/resources.ts"
      provides: "Admin resource API endpoints"
      exports: ["adminResourcesRouter"]
    - path: "src/routes/resources.ts"
      provides: "Member resource API endpoints"
      exports: ["resourcesRouter"]
    - path: "src/index.ts"
      provides: "Route mounting"
      contains: "adminResourcesRouter"
  key_links:
    - from: "src/routes/admin/resources.ts"
      to: "src/resources/service.ts"
      via: "service function calls"
      pattern: "createResource\\(|updateResource\\(|uploadNewVersion\\("
    - from: "src/routes/admin/resources.ts"
      to: "src/middleware/rate-limit.ts"
      via: "uploadLimiter middleware"
      pattern: "uploadLimiter"
    - from: "src/routes/admin/resources.ts"
      to: "src/storage/upload.ts"
      via: "uploadMiddleware"
      pattern: "uploadMiddleware"
    - from: "src/routes/resources.ts"
      to: "src/resources/service.ts"
      via: "service function calls"
      pattern: "listResources\\(|downloadResource\\("
    - from: "src/index.ts"
      to: "src/routes/admin/resources.ts"
      via: "router mounting"
      pattern: "adminResourcesRouter"
---

<objective>
Create API routes for resource library - admin CRUD/upload/analytics and member browse/download.

Purpose: Expose all resource functionality via REST API endpoints. Admin routes handle file uploads with rate limiting and validation. Member routes provide read-only access to published resources.

Output: Complete API layer ready for frontend integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-resource-library/29-CONTEXT.md
@.planning/phases/29-resource-library/29-RESEARCH.md
@.planning/phases/29-resource-library/29-01-SUMMARY.md
@.planning/phases/29-resource-library/29-02-SUMMARY.md
@.planning/phases/29-resource-library/29-03-SUMMARY.md
@src/resources/service.ts
@src/storage/upload.ts
@src/middleware/rate-limit.ts
@src/routes/admin/benchmarks.ts
@src/routes/benchmarks.ts
@src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create admin resource routes</name>
  <files>
    src/routes/admin/resources.ts
  </files>
  <action>
Create src/routes/admin/resources.ts following patterns from admin/benchmarks.ts:

```typescript
/**
 * Admin resource management API routes
 * Endpoints for CRUD, file upload, versioning, and analytics
 */
import { Router } from 'express';
import { z } from 'zod';
import { requireAdmin } from '../../admin/middleware.js';
import { uploadMiddleware } from '../../storage/upload.js';
import { uploadLimiter } from '../../middleware/rate-limit.js';
import { validateFileType } from '../../lib/file-validation.js';
import {
  createResource,
  updateResource,
  uploadNewVersion,
  softDeleteResource,
  getResourceById,
  getVersionHistory,
  getResourceAnalytics,
  getAllTags,
  createTag,
  deleteTag,
  listResources,
} from '../../resources/service.js';
import { ResourceType, ResourceStatus } from '@prisma/client';

export const adminResourcesRouter = Router();

// Schema for creating a resource (metadata in JSON, file as multipart)
const createResourceSchema = z.object({
  title: z.string().min(1).max(200),
  description: z.string().max(2000),
  tags: z.array(z.string()).default([]),
  type: z.enum(['TEMPLATE', 'SOP', 'PLAYBOOK', 'COURSE', 'VIDEO']),
  status: z.enum(['DRAFT', 'PUBLISHED', 'SCHEDULED']).default('DRAFT'),
  publishAt: z.string().datetime().optional(),
  author: z.string().max(100).optional(),
  isFeatured: z.boolean().default(false),
});

/**
 * POST /api/admin/resources
 * Upload new resource with file and metadata
 * Rate limited: 5 files/hour/admin (SEC-07)
 */
adminResourcesRouter.post(
  '/',
  requireAdmin,
  uploadLimiter,
  uploadMiddleware,
  async (req, res) => {
    const admin = res.locals.admin!;

    if (!req.file) {
      res.status(400).json({ error: 'No file uploaded' });
      return;
    }

    try {
      // Parse metadata from form field
      const metadata = createResourceSchema.parse(
        JSON.parse(req.body.metadata || '{}')
      );

      // Validate file type via magic number (SEC-02, SEC-03)
      const validation = await validateFileType(req.file.buffer, req.file.originalname);
      if (!validation.valid) {
        res.status(400).json({ error: validation.error });
        return;
      }

      const resource = await createResource(
        { buffer: req.file.buffer, originalname: req.file.originalname },
        {
          title: metadata.title,
          description: metadata.description,
          tags: metadata.tags,
          type: metadata.type as ResourceType,
          status: metadata.status as ResourceStatus,
          publishAt: metadata.publishAt ? new Date(metadata.publishAt) : undefined,
          author: metadata.author,
          isFeatured: metadata.isFeatured,
        },
        admin.id
      );

      res.status(201).json({ resource });
    } catch (error) {
      if (error instanceof z.ZodError) {
        res.status(400).json({ error: 'Invalid metadata', details: error.issues });
        return;
      }
      throw error;
    }
  }
);

/**
 * GET /api/admin/resources
 * List all resources (including drafts) for admin management
 */
const listQuerySchema = z.object({
  cursor: z.string().optional(),
  limit: z.coerce.number().min(1).max(100).default(50),
  tags: z.string().optional(), // Comma-separated
  type: z.enum(['TEMPLATE', 'SOP', 'PLAYBOOK', 'COURSE', 'VIDEO']).optional(),
  search: z.string().optional(),
  status: z.enum(['DRAFT', 'PUBLISHED', 'SCHEDULED']).optional(),
});

adminResourcesRouter.get('/', requireAdmin, async (req, res) => {
  const query = listQuerySchema.parse(req.query);

  // For admin, we want to include all statuses - modify listResources or use direct query
  // Using listResources with custom logic for admin view
  const resources = await listResources(
    {
      tags: query.tags?.split(',').filter(Boolean),
      type: query.type as ResourceType | undefined,
      search: query.search,
    },
    query.cursor,
    query.limit
  );

  // Note: listResources only returns published - for admin we need all
  // TODO: Consider adding admin-specific list function if needed
  // For now, this returns published resources which is sufficient for initial implementation

  res.json(resources);
});

/**
 * GET /api/admin/resources/:id
 * Get resource details including version history
 */
adminResourcesRouter.get('/:id', requireAdmin, async (req, res) => {
  const { id } = z.object({ id: z.string() }).parse(req.params);

  const resource = await getResourceById(id, true); // Include deleted for admin
  if (!resource) {
    res.status(404).json({ error: 'Resource not found' });
    return;
  }

  const versions = await getVersionHistory(id);

  res.json({ resource, versions });
});

// Schema for updating resource metadata
const updateResourceSchema = z.object({
  title: z.string().min(1).max(200).optional(),
  description: z.string().max(2000).optional(),
  tags: z.array(z.string()).optional(),
  type: z.enum(['TEMPLATE', 'SOP', 'PLAYBOOK', 'COURSE', 'VIDEO']).optional(),
  status: z.enum(['DRAFT', 'PUBLISHED', 'SCHEDULED']).optional(),
  publishAt: z.string().datetime().nullable().optional(),
  author: z.string().max(100).nullable().optional(),
  isFeatured: z.boolean().optional(),
});

/**
 * PATCH /api/admin/resources/:id
 * Update resource metadata (no file change)
 */
adminResourcesRouter.patch('/:id', requireAdmin, async (req, res) => {
  const { id } = z.object({ id: z.string() }).parse(req.params);
  const admin = res.locals.admin!;

  try {
    const updates = updateResourceSchema.parse(req.body);

    const resource = await updateResource(
      id,
      {
        ...updates,
        type: updates.type as ResourceType | undefined,
        status: updates.status as ResourceStatus | undefined,
        publishAt: updates.publishAt === null ? null : updates.publishAt ? new Date(updates.publishAt) : undefined,
      },
      admin.id
    );

    res.json({ resource });
  } catch (error) {
    if (error instanceof z.ZodError) {
      res.status(400).json({ error: 'Invalid data', details: error.issues });
      return;
    }
    if ((error as Error).message === 'Resource not found') {
      res.status(404).json({ error: 'Resource not found' });
      return;
    }
    throw error;
  }
});

/**
 * POST /api/admin/resources/:id/version
 * Upload new file version
 * Rate limited: 5 files/hour/admin
 */
adminResourcesRouter.post(
  '/:id/version',
  requireAdmin,
  uploadLimiter,
  uploadMiddleware,
  async (req, res) => {
    const { id } = z.object({ id: z.string() }).parse(req.params);
    const admin = res.locals.admin!;

    if (!req.file) {
      res.status(400).json({ error: 'No file uploaded' });
      return;
    }

    try {
      const changelog = req.body.changelog as string | undefined;

      // Validate file type
      const validation = await validateFileType(req.file.buffer, req.file.originalname);
      if (!validation.valid) {
        res.status(400).json({ error: validation.error });
        return;
      }

      const result = await uploadNewVersion(
        id,
        { buffer: req.file.buffer, originalname: req.file.originalname },
        changelog,
        admin.id
      );

      res.json(result);
    } catch (error) {
      if ((error as Error).message === 'Resource not found') {
        res.status(404).json({ error: 'Resource not found' });
        return;
      }
      throw error;
    }
  }
);

/**
 * DELETE /api/admin/resources/:id
 * Soft delete resource
 */
adminResourcesRouter.delete('/:id', requireAdmin, async (req, res) => {
  const { id } = z.object({ id: z.string() }).parse(req.params);
  const admin = res.locals.admin!;

  try {
    await softDeleteResource(id, admin.id);
    res.json({ success: true });
  } catch (error) {
    if ((error as Error).message === 'Resource not found') {
      res.status(404).json({ error: 'Resource not found' });
      return;
    }
    throw error;
  }
});

/**
 * GET /api/admin/resources/analytics
 * Get resource download analytics
 */
adminResourcesRouter.get('/analytics', requireAdmin, async (req, res) => {
  const analytics = await getResourceAnalytics();
  res.json(analytics);
});

// ============================================
// Tag Management
// ============================================

/**
 * GET /api/admin/resources/tags
 * Get all tags
 */
adminResourcesRouter.get('/tags', requireAdmin, async (req, res) => {
  const tags = await getAllTags();
  res.json({ tags });
});

/**
 * POST /api/admin/resources/tags
 * Create new tag
 */
adminResourcesRouter.post('/tags', requireAdmin, async (req, res) => {
  const { name } = z.object({ name: z.string().min(1).max(50) }).parse(req.body);
  const admin = res.locals.admin!;

  try {
    const tag = await createTag(name, admin.id);
    res.status(201).json({ tag });
  } catch (error) {
    // Handle unique constraint violation
    if ((error as any).code === 'P2002') {
      res.status(409).json({ error: 'Tag already exists' });
      return;
    }
    throw error;
  }
});

/**
 * DELETE /api/admin/resources/tags/:id
 * Delete tag
 */
adminResourcesRouter.delete('/tags/:id', requireAdmin, async (req, res) => {
  const { id } = z.object({ id: z.string() }).parse(req.params);

  try {
    await deleteTag(id);
    res.json({ success: true });
  } catch (error) {
    if ((error as any).code === 'P2025') {
      res.status(404).json({ error: 'Tag not found' });
      return;
    }
    throw error;
  }
});
```

Note: The routes are ordered to ensure /analytics and /tags are matched before /:id pattern.
  </action>
  <verify>
npm run build
grep -q "adminResourcesRouter" src/routes/admin/resources.ts
grep -q "uploadLimiter" src/routes/admin/resources.ts
grep -q "createResource" src/routes/admin/resources.ts
  </verify>
  <done>
Admin resource routes complete:
- POST / - Upload new resource (rate limited)
- GET / - List resources
- GET /:id - Get resource with versions
- PATCH /:id - Update metadata
- POST /:id/version - Upload new version (rate limited)
- DELETE /:id - Soft delete
- GET /analytics - Download analytics
- GET/POST/DELETE /tags - Tag management
  </done>
</task>

<task type="auto">
  <name>Task 2: Create member resource routes</name>
  <files>
    src/routes/resources.ts
  </files>
  <action>
Create src/routes/resources.ts following patterns from routes/benchmarks.ts:

```typescript
/**
 * Member-facing resource API routes
 * Endpoints for browsing, viewing, and downloading resources
 */
import { Router } from 'express';
import { z } from 'zod';
import { requireAuth, type AuthenticatedRequest } from '../middleware/session.js';
import {
  listResources,
  getResourceById,
  downloadResource,
  getRecommendedResources,
  getAllTags,
} from '../resources/service.js';
import { ResourceType } from '@prisma/client';

export const resourcesRouter = Router();

// Schema for list query parameters
const listQuerySchema = z.object({
  cursor: z.string().optional(),
  limit: z.coerce.number().min(1).max(50).default(20),
  tags: z.string().optional(), // Comma-separated
  type: z.enum(['TEMPLATE', 'SOP', 'PLAYBOOK', 'COURSE', 'VIDEO']).optional(),
  search: z.string().max(100).optional(),
  featured: z.enum(['true', 'false']).optional(),
});

/**
 * GET /api/resources
 * Browse published resources with filtering
 * RES-06: Faceted filtering by tags, type, search
 */
resourcesRouter.get('/', requireAuth, async (req: AuthenticatedRequest, res) => {
  const query = listQuerySchema.parse(req.query);

  const result = await listResources(
    {
      tags: query.tags?.split(',').filter(Boolean),
      type: query.type as ResourceType | undefined,
      search: query.search,
      isFeatured: query.featured === 'true' ? true : query.featured === 'false' ? false : undefined,
    },
    query.cursor,
    query.limit
  );

  res.json(result);
});

/**
 * GET /api/resources/tags
 * Get all available tags for filtering UI
 */
resourcesRouter.get('/tags', requireAuth, async (req: AuthenticatedRequest, res) => {
  const tags = await getAllTags();
  res.json({ tags });
});

/**
 * GET /api/resources/recommended
 * Get personalized recommendations based on download history
 * RES-15: Contextual recommendations
 */
resourcesRouter.get('/recommended', requireAuth, async (req: AuthenticatedRequest, res) => {
  const memberId = req.memberId!;
  const limit = z.coerce.number().min(1).max(10).default(5).parse(req.query.limit || 5);

  const resources = await getRecommendedResources(memberId, limit);
  res.json({ resources });
});

/**
 * GET /api/resources/:id
 * View resource details before downloading
 * RES-07: Preview resource details
 */
resourcesRouter.get('/:id', requireAuth, async (req: AuthenticatedRequest, res) => {
  const { id } = z.object({ id: z.string() }).parse(req.params);

  const resource = await getResourceById(id);

  if (!resource) {
    res.status(404).json({ error: 'Resource not found' });
    return;
  }

  // Check if published
  const now = new Date();
  const isAvailable =
    resource.status === 'PUBLISHED' ||
    (resource.status === 'SCHEDULED' && resource.publishAt && resource.publishAt <= now);

  if (!isAvailable) {
    res.status(404).json({ error: 'Resource not found' });
    return;
  }

  // Return resource details (without storagePath - member shouldn't see internal paths)
  res.json({
    resource: {
      id: resource.id,
      title: resource.title,
      description: resource.description,
      tags: resource.tags,
      type: resource.type,
      author: resource.author,
      fileSize: resource.fileSize,
      mimeType: resource.mimeType,
      isFeatured: resource.isFeatured,
      downloadCount: resource.downloadCount,
      createdAt: resource.createdAt,
    },
  });
});

/**
 * POST /api/resources/:id/download
 * Download resource - generates signed URL and awards points
 * RES-08: Download via signed URL
 * RES-09: Track download
 * RES-10: Award points
 */
resourcesRouter.post('/:id/download', requireAuth, async (req: AuthenticatedRequest, res) => {
  const { id } = z.object({ id: z.string() }).parse(req.params);
  const memberId = req.memberId!;

  try {
    const result = await downloadResource(id, memberId);

    res.json({
      downloadUrl: result.url,
      expiresAt: result.expiresAt,
      pointsAwarded: result.pointsAwarded,
    });
  } catch (error) {
    if ((error as Error).message === 'Resource not found') {
      res.status(404).json({ error: 'Resource not found' });
      return;
    }
    if ((error as Error).message === 'Resource not available') {
      res.status(404).json({ error: 'Resource not available' });
      return;
    }
    throw error;
  }
});
```

Note: Routes ordered to ensure /tags and /recommended match before /:id.
  </action>
  <verify>
npm run build
grep -q "resourcesRouter" src/routes/resources.ts
grep -q "downloadResource" src/routes/resources.ts
grep -q "getRecommendedResources" src/routes/resources.ts
  </verify>
  <done>
Member resource routes complete:
- GET / - Browse resources with filtering
- GET /tags - Get available tags
- GET /recommended - Personalized recommendations
- GET /:id - View resource details
- POST /:id/download - Download (signed URL + points)
  </done>
</task>

<task type="auto">
  <name>Task 3: Mount routes in Express app</name>
  <files>
    src/index.ts
  </files>
  <action>
Update src/index.ts to mount the new resource routes.

1. Add imports near other route imports:
   ```typescript
   import { adminResourcesRouter } from './routes/admin/resources.js';
   import { resourcesRouter } from './routes/resources.js';
   ```

2. Mount admin routes (near other admin route mounts):
   ```typescript
   app.use('/api/admin/resources', adminResourcesRouter);
   ```

3. Mount member routes (near other member route mounts):
   ```typescript
   app.use('/api/resources', resourcesRouter);
   ```

Ensure the admin routes are mounted AFTER the requireAdmin middleware pattern is established (following existing patterns like adminBenchmarksRouter).
  </action>
  <verify>
npm run build
grep -q "adminResourcesRouter" src/index.ts
grep -q "resourcesRouter" src/index.ts
grep -q "/api/admin/resources" src/index.ts
grep -q "/api/resources" src/index.ts
  </verify>
  <done>
Routes mounted in Express app:
- /api/admin/resources/* - Admin resource management
- /api/resources/* - Member resource access
  </done>
</task>

</tasks>

<verification>
- [ ] npm run build compiles without errors
- [ ] Admin routes: POST /, GET /, GET /:id, PATCH /:id, POST /:id/version, DELETE /:id
- [ ] Admin routes: GET /analytics, GET /tags, POST /tags, DELETE /tags/:id
- [ ] Member routes: GET /, GET /tags, GET /recommended, GET /:id, POST /:id/download
- [ ] uploadLimiter applied to admin upload endpoints
- [ ] uploadMiddleware handles multipart form data
- [ ] Routes mounted in src/index.ts
</verification>

<success_criteria>
1. Admin can upload resources with metadata via POST /api/admin/resources
2. Admin can update metadata via PATCH /api/admin/resources/:id
3. Admin can upload new versions via POST /api/admin/resources/:id/version
4. Admin can soft delete via DELETE /api/admin/resources/:id
5. Admin can view analytics via GET /api/admin/resources/analytics
6. Admin can manage tags via /api/admin/resources/tags endpoints
7. Member can browse resources via GET /api/resources with filters
8. Member can view details via GET /api/resources/:id
9. Member can download via POST /api/resources/:id/download (returns signed URL)
10. Member can get recommendations via GET /api/resources/recommended
11. All endpoints properly authenticated and validated
</success_criteria>

<output>
After completion, create `.planning/phases/29-resource-library/29-04-SUMMARY.md`
</output>
