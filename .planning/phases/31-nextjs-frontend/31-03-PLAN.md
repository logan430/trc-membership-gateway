---
phase: 31-nextjs-frontend
plan: 03
type: execute
wave: 2
depends_on: ["31-01", "31-02"]
files_modified:
  - dashboard/src/lib/auth.ts
  - dashboard/src/middleware.ts
  - dashboard/src/lib/api.ts
autonomous: true

must_haves:
  truths:
    - "Next.js middleware validates JWT from refresh token cookie"
    - "Invalid/missing tokens redirect to /login on Express"
    - "Valid tokens allow access to /dashboard/* pages"
    - "API client forwards credentials for authenticated requests"
  artifacts:
    - path: "dashboard/src/lib/auth.ts"
      provides: "JWT verification using jose library"
      contains: "jwtVerify"
    - path: "dashboard/src/middleware.ts"
      provides: "Route protection middleware"
      contains: "NextResponse.redirect"
    - path: "dashboard/src/lib/api.ts"
      provides: "API client for Express backend"
      contains: "credentials: 'include'"
  key_links:
    - from: "dashboard/src/middleware.ts"
      to: "dashboard/src/lib/auth.ts"
      via: "import verifyToken"
      pattern: "import.*verifyToken.*from.*auth"
    - from: "dashboard/src/lib/auth.ts"
      to: "jose"
      via: "JWT verification"
      pattern: "jwtVerify.*JWT_SECRET"
---

<objective>
Create Next.js authentication middleware that validates JWT tokens using the same jose library as Express, enabling shared session between apps.

Purpose: Protect all /dashboard/* routes in Next.js by validating the refresh token cookie set by Express auth, ensuring only authenticated members can access the React dashboard.

Output: Working auth middleware that reads cookies, validates JWTs, and redirects unauthenticated users to Express login.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-nextjs-frontend/31-RESEARCH.md
@src/auth/session.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create JWT verification library</name>
  <files>
    dashboard/src/lib/auth.ts
  </files>
  <action>
Create the auth library that shares JWT verification logic with Express. This uses jose (already installed in 31-01) which is Edge Runtime compatible.

Create `dashboard/src/lib/auth.ts`:
```typescript
import { jwtVerify, type JWTPayload } from 'jose';

/**
 * JWT verification for Next.js middleware
 * Uses same jose library and secret as Express backend
 *
 * @see src/auth/session.ts in Express app for token creation
 */

// JWT secret from environment - MUST match Express JWT_SECRET
const JWT_SECRET = new TextEncoder().encode(process.env.JWT_SECRET);

// Token payload shape (matches Express TokenPayload)
export interface TokenPayload {
  sub: string;          // Member ID
  type?: 'refresh';     // Token type (refresh tokens have this)
  iat?: number;         // Issued at
  exp?: number;         // Expiration
}

/**
 * Verify a JWT token
 * Returns payload on success, null on any error (expired, invalid, malformed)
 */
export async function verifyToken(token: string): Promise<TokenPayload | null> {
  // Validate JWT_SECRET is configured
  if (!process.env.JWT_SECRET) {
    console.error('JWT_SECRET environment variable not set');
    return null;
  }

  try {
    const { payload } = await jwtVerify(token, JWT_SECRET);

    return {
      sub: payload.sub as string,
      type: payload.type as 'refresh' | undefined,
      iat: payload.iat,
      exp: payload.exp,
    };
  } catch (error) {
    // Token is expired, invalid, or malformed
    // Don't log in production (expected for invalid tokens)
    if (process.env.NODE_ENV === 'development') {
      console.debug('Token verification failed:', error);
    }
    return null;
  }
}

/**
 * Extract member ID from a valid refresh token
 * Returns member ID string or null if invalid
 */
export async function getMemberIdFromToken(token: string): Promise<string | null> {
  const payload = await verifyToken(token);

  // Must be a refresh token (has type: 'refresh')
  if (!payload || payload.type !== 'refresh') {
    return null;
  }

  return payload.sub;
}

// Cookie name (matches Express REFRESH_COOKIE_NAME)
export const REFRESH_COOKIE_NAME = 'trc_refresh';
```
  </action>
  <verify>
- `ls dashboard/src/lib/auth.ts` (file exists)
- `grep "jwtVerify" dashboard/src/lib/auth.ts` (uses jose)
- `grep "JWT_SECRET" dashboard/src/lib/auth.ts` (uses env secret)
  </verify>
  <done>JWT verification library created using jose, matching Express patterns</done>
</task>

<task type="auto">
  <name>Task 2: Create Next.js auth middleware</name>
  <files>
    dashboard/src/middleware.ts
  </files>
  <action>
Create the Next.js middleware that protects all /dashboard/* routes by validating the refresh token cookie.

Create `dashboard/src/middleware.ts`:
```typescript
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { verifyToken, REFRESH_COOKIE_NAME } from './lib/auth';

/**
 * Next.js Middleware - Authentication Guard
 *
 * Protects all /dashboard/* routes by validating the refresh token cookie.
 * Invalid or missing tokens redirect to Express login page.
 *
 * How it works:
 * 1. User logs in via Express at /login
 * 2. Express sets httpOnly refresh token cookie (path: '/')
 * 3. User navigates to /dashboard/* (proxied to Next.js)
 * 4. This middleware reads cookie, validates JWT
 * 5. Valid: continue to page. Invalid: redirect to /login
 */

export async function middleware(request: NextRequest) {
  // Get refresh token from cookies
  const refreshToken = request.cookies.get(REFRESH_COOKIE_NAME)?.value;

  // No token = not logged in
  if (!refreshToken) {
    return redirectToLogin(request, 'no_token');
  }

  // Verify the token
  const payload = await verifyToken(refreshToken);

  // Invalid token (expired, malformed, wrong signature)
  if (!payload) {
    return redirectToLogin(request, 'invalid_token');
  }

  // Must be a refresh token (not an access token)
  if (payload.type !== 'refresh') {
    return redirectToLogin(request, 'wrong_token_type');
  }

  // Token valid - continue to page
  // Optionally add member ID to headers for server components
  const response = NextResponse.next();
  response.headers.set('x-member-id', payload.sub);

  return response;
}

/**
 * Redirect to Express login page with optional reason
 * Uses the Express app URL (goes through proxy or directly)
 */
function redirectToLogin(request: NextRequest, reason?: string): NextResponse {
  // Build login URL - use origin to stay on same host
  // This works because Express (port 4000) proxies to us
  const loginUrl = new URL('/login', request.url);

  // Add return URL so user comes back after login
  loginUrl.searchParams.set('returnTo', request.nextUrl.pathname);

  // Add reason in development for debugging
  if (reason && process.env.NODE_ENV === 'development') {
    loginUrl.searchParams.set('reason', reason);
  }

  return NextResponse.redirect(loginUrl);
}

/**
 * Middleware matcher configuration
 * Only run on /dashboard/* routes (our protected pages)
 */
export const config = {
  matcher: [
    /*
     * Match all paths starting with /dashboard
     * Excludes:
     * - _next/static (static files)
     * - _next/image (image optimization)
     * - favicon.ico, images, etc.
     */
    '/dashboard/:path*',
  ],
};
```
  </action>
  <verify>
- `ls dashboard/src/middleware.ts` (file exists)
- `grep "verifyToken" dashboard/src/middleware.ts` (imports auth)
- `grep "NextResponse.redirect" dashboard/src/middleware.ts` (redirects on failure)
- `grep "matcher.*dashboard" dashboard/src/middleware.ts` (correct path matching)
  </verify>
  <done>Next.js middleware protects /dashboard/* with JWT validation</done>
</task>

<task type="auto">
  <name>Task 3: Create API client for Express backend</name>
  <files>
    dashboard/src/lib/api.ts
  </files>
  <action>
Create an API client that Next.js components will use to call Express backend endpoints. This client includes credentials for cookie-based auth.

Create `dashboard/src/lib/api.ts`:
```typescript
/**
 * API Client for Express Backend
 *
 * All API calls go to Express (same origin via proxy or direct).
 * Credentials are included to forward httpOnly cookies.
 */

// Base URL for API calls
// In production: same origin (proxied through Express)
// In development: can be direct or proxied
const API_BASE = process.env.NEXT_PUBLIC_API_URL || '';

/**
 * Fetch wrapper with credentials and error handling
 */
async function apiFetch<T>(
  endpoint: string,
  options: RequestInit = {}
): Promise<T> {
  const url = `${API_BASE}${endpoint}`;

  const response = await fetch(url, {
    ...options,
    credentials: 'include', // CRITICAL: Include cookies for auth
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

  // Handle auth errors
  if (response.status === 401) {
    // Redirect to login if on client side
    if (typeof window !== 'undefined') {
      window.location.href = '/login?reason=session_expired';
    }
    throw new ApiError('Session expired', 401);
  }

  // Handle other errors
  if (!response.ok) {
    const error = await response.json().catch(() => ({ error: 'Unknown error' }));
    throw new ApiError(error.error || 'Request failed', response.status);
  }

  // Parse JSON response
  return response.json();
}

/**
 * Custom error class for API errors
 */
export class ApiError extends Error {
  constructor(
    message: string,
    public status: number
  ) {
    super(message);
    this.name = 'ApiError';
  }
}

// =============================================================================
// API Methods - Points
// =============================================================================

export interface PointsSummary {
  totalPoints: number;
  currentStreak: number;
  monthlyPoints: number;
  lastActiveAt: string | null;
}

export interface PointTransaction {
  id: string;
  points: number;
  type: string;
  reason: string;
  createdAt: string;
}

export const pointsApi = {
  /** Get member's point summary */
  getSummary: () => apiFetch<PointsSummary>('/api/points/summary'),

  /** Get member's point history */
  getHistory: (limit = 20, offset = 0) =>
    apiFetch<{ transactions: PointTransaction[]; total: number }>(
      `/api/points/history?limit=${limit}&offset=${offset}`
    ),

  /** Get point values configuration */
  getValues: () => apiFetch<Record<string, number>>('/api/points/values'),
};

// =============================================================================
// API Methods - Benchmarks
// =============================================================================

export interface BenchmarkCategory {
  id: string;
  name: string;
  description: string;
  submissionCount: number;
  hasSubmitted: boolean;
}

export const benchmarksApi = {
  /** Get available benchmark categories */
  getCategories: () => apiFetch<BenchmarkCategory[]>('/api/benchmarks/categories'),

  /** Get member's submissions */
  getSubmissions: () => apiFetch<Record<string, unknown>[]>('/api/benchmarks/submissions'),

  /** Submit benchmark data */
  submit: (category: string, data: Record<string, unknown>) =>
    apiFetch<{ id: string }>('/api/benchmarks/submit', {
      method: 'POST',
      body: JSON.stringify({ category, data }),
    }),

  /** Get benchmark results for a category */
  getResults: (category: string, filters?: Record<string, string>) => {
    const params = new URLSearchParams(filters);
    return apiFetch<Record<string, unknown>>(
      `/api/benchmarks/results/${category}?${params}`
    );
  },
};

// =============================================================================
// API Methods - Resources
// =============================================================================

export interface Resource {
  id: string;
  title: string;
  description: string;
  type: string;
  tags: string[];
  downloadCount: number;
  createdAt: string;
}

export const resourcesApi = {
  /** List resources with optional filters */
  list: (filters?: { type?: string; tags?: string; search?: string; limit?: number; offset?: number }) => {
    const params = new URLSearchParams();
    if (filters?.type) params.set('type', filters.type);
    if (filters?.tags) params.set('tags', filters.tags);
    if (filters?.search) params.set('search', filters.search);
    if (filters?.limit) params.set('limit', String(filters.limit));
    if (filters?.offset) params.set('offset', String(filters.offset));
    return apiFetch<{ resources: Resource[]; total: number }>(
      `/api/resources?${params}`
    );
  },

  /** Get resource details */
  get: (id: string) => apiFetch<Resource>(`/api/resources/${id}`),

  /** Download resource (returns signed URL) */
  download: (id: string) =>
    apiFetch<{ url: string }>(`/api/resources/${id}/download`, {
      method: 'POST',
    }),

  /** Get recommended resources */
  getRecommended: () => apiFetch<Resource[]>('/api/resources/recommended'),
};

// =============================================================================
// API Methods - Member Profile
// =============================================================================

export interface MemberProfile {
  id: string;
  email: string;
  name: string | null;
  discordId: string | null;
  discordUsername: string | null;
  totalPoints: number;
  currentStreak: number;
  createdAt: string;
}

export const memberApi = {
  /** Get current member's profile */
  getProfile: () => apiFetch<MemberProfile>('/dashboard/profile'),

  /** Update profile */
  updateProfile: (data: { name?: string }) =>
    apiFetch<MemberProfile>('/dashboard/profile', {
      method: 'PATCH',
      body: JSON.stringify(data),
    }),
};

// Export all APIs
export const api = {
  points: pointsApi,
  benchmarks: benchmarksApi,
  resources: resourcesApi,
  member: memberApi,
};
```
  </action>
  <verify>
- `ls dashboard/src/lib/api.ts` (file exists)
- `grep "credentials: 'include'" dashboard/src/lib/api.ts` (cookies forwarded)
- `grep "pointsApi" dashboard/src/lib/api.ts` (API methods defined)
  </verify>
  <done>API client created with credentials for authenticated requests to Express backend</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `ls dashboard/src/lib/auth.ts dashboard/src/middleware.ts dashboard/src/lib/api.ts` (all files exist)
2. `cd dashboard && npm run build` completes without errors
3. Middleware config targets /dashboard/* routes
4. Auth library uses jose for JWT verification
5. API client includes credentials for cookie forwarding
</verification>

<success_criteria>
- JWT verification in dashboard/src/lib/auth.ts uses jose and reads JWT_SECRET from env
- Middleware in dashboard/src/middleware.ts validates refresh token cookie
- Invalid tokens redirect to /login with returnTo parameter
- API client in dashboard/src/lib/api.ts forwards credentials
- Next.js builds without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/31-nextjs-frontend/31-03-SUMMARY.md`
</output>
