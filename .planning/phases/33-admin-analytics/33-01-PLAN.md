---
phase: 33-admin-analytics
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/analytics/types.ts
  - src/analytics/member-analytics.ts
  - src/analytics/engagement-analytics.ts
  - src/analytics/benchmark-analytics.ts
  - src/analytics/resource-analytics.ts
  - src/analytics/churn-prediction.ts

autonomous: true

must_haves:
  truths:
    - "Analytics service can compute member counts (total, active, inactive)"
    - "Analytics service can aggregate engagement metrics over time periods"
    - "Analytics service can compute benchmark statistics by category"
    - "Analytics service can compute resource download analytics"
    - "Analytics service can score member churn risk using multi-factor algorithm"
  artifacts:
    - path: "src/analytics/types.ts"
      provides: "Analytics type definitions and interfaces"
      exports: ["MemberOverview", "EngagementTrend", "BenchmarkStats", "ResourceStats", "ChurnRiskScore", "CohortRetention"]
    - path: "src/analytics/member-analytics.ts"
      provides: "Member overview and cohort aggregation queries"
      exports: ["getMemberOverview", "getCohortRetention"]
    - path: "src/analytics/engagement-analytics.ts"
      provides: "Engagement trend aggregation queries"
      exports: ["getEngagementTrend", "getEngagementComparison"]
    - path: "src/analytics/benchmark-analytics.ts"
      provides: "Benchmark statistics by category and segment"
      exports: ["getBenchmarkStats", "getBenchmarkTrends", "getBenchmarkInsights"]
    - path: "src/analytics/resource-analytics.ts"
      provides: "Resource download analytics"
      exports: ["getResourceStats", "getPopularResources", "getTrendingResources"]
    - path: "src/analytics/churn-prediction.ts"
      provides: "Churn risk scoring algorithm"
      exports: ["calculateChurnRisk", "getAtRiskMembers"]
  key_links:
    - from: "src/analytics/member-analytics.ts"
      to: "prisma.member"
      via: "Prisma queries"
      pattern: "prisma\\.(member|\\$queryRaw)"
    - from: "src/analytics/engagement-analytics.ts"
      to: "prisma.pointTransaction"
      via: "Prisma raw SQL aggregation"
      pattern: "prisma\\.\\$queryRaw"
    - from: "src/analytics/churn-prediction.ts"
      to: "prisma.member"
      via: "Member activity queries"
      pattern: "prisma\\.member\\.find"
---

<objective>
Create the backend analytics service layer with aggregation functions for member overview, engagement metrics, benchmark statistics, resource analytics, and churn prediction scoring.

Purpose: Provides the data layer for admin analytics dashboard - all computationally expensive aggregations happen in PostgreSQL, not JavaScript.

Output: Analytics module (`src/analytics/`) with typed services for each analytics domain.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/33-admin-analytics/33-CONTEXT.md
@.planning/phases/33-admin-analytics/33-RESEARCH.md

Key patterns from existing codebase:
- src/benchmarks/service.ts: Raw SQL pattern for aggregations
- src/routes/admin/benchmarks.ts: Admin API pattern
- prisma/schema.prisma: Data models (Member, PointTransaction, BenchmarkSubmission, ResourceDownload, DiscordActivity)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Analytics Types</name>
  <files>src/analytics/types.ts</files>
  <action>
Create comprehensive type definitions for all analytics data structures:

```typescript
// Member Overview Types
interface MemberOverview {
  totalMembers: number;
  activeMembers: number;  // lastActiveAt within 30 days
  inactiveMembers: number;
  newMembers30d: number;  // Joined in last 30 days
  mrr: number;  // Estimate from subscription counts
}

// Engagement Trend Types
interface DailyEngagement {
  date: string;  // ISO date
  benchmarks: number;
  downloads: number;
  discordActivity: number;
  total: number;
}

interface EngagementTrend {
  data: DailyEngagement[];
  periodStart: string;
  periodEnd: string;
}

interface EngagementComparison {
  current: EngagementTrend;
  previous: EngagementTrend;
  change: {
    benchmarks: number;  // Percentage
    downloads: number;
    discordActivity: number;
    total: number;
  };
}

// Benchmark Statistics Types
interface CategoryStats {
  category: string;
  submissionCount: number;
  validCount: number;
  flaggedCount: number;
  uniqueMembers: number;
}

interface BenchmarkStats {
  byCategory: CategoryStats[];
  total: {
    submissions: number;
    validSubmissions: number;
    flaggedSubmissions: number;
    uniqueMembers: number;
  };
}

interface BenchmarkTrend {
  date: string;
  category: string;
  count: number;
}

// Benchmark Insights Types (ANALYTICS-05)
interface BenchmarkInsight {
  metric: string;
  sampleSize: number;
  median: number | null;
  p25: number | null;
  p75: number | null;
  avg: number | null;
}

interface BenchmarkInsightsResult {
  filters: SegmentFilters;
  insights: BenchmarkInsight[];
  sampleSize: number;
}

// Resource Statistics Types
interface ResourceStats {
  totalResources: number;
  totalDownloads: number;
  uniqueDownloaders: number;
  downloadsThisPeriod: number;
}

interface PopularResource {
  id: string;
  title: string;
  type: string;
  downloadCount: number;
  uniqueDownloaders: number;
}

interface TrendingResource {
  id: string;
  title: string;
  type: string;
  recentDownloads: number;  // Last 7 days
  previousDownloads: number;  // 7-14 days ago
  growthPercent: number;
}

// Churn Risk Types
interface ChurnRiskFactor {
  factor: string;
  points: number;
  description: string;
}

interface ChurnRiskScore {
  memberId: string;
  email: string;
  discordUsername: string | null;
  score: number;  // 0-100
  riskLevel: 'low' | 'medium' | 'high';
  factors: ChurnRiskFactor[];
  lastActiveAt: Date | null;
  subscriptionStatus: string;
}

// Cohort Retention Types
interface CohortRow {
  cohort: string;  // YYYY-MM format
  month0: number;
  month1: number;
  month2: number;
  month3: number;
  month4: number;
  month5: number;
  // Percentages
  month0Pct: number;
  month1Pct: number;
  month2Pct: number;
  month3Pct: number;
  month4Pct: number;
  month5Pct: number;
}

// Date range params (common across services)
interface DateRange {
  startDate: Date;
  endDate: Date;
}

// Segment filters (for benchmark insights)
interface SegmentFilters {
  companySize?: string;
  industry?: string;
  role?: string;
}
```

Export all types and interfaces for use across analytics services.
  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit`</verify>
  <done>All analytics types defined and exported from src/analytics/types.ts</done>
</task>

<task type="auto">
  <name>Task 2: Create Member and Engagement Analytics</name>
  <files>src/analytics/member-analytics.ts, src/analytics/engagement-analytics.ts</files>
  <action>
**member-analytics.ts**: Create functions for member overview and cohort retention.

```typescript
import { prisma } from '../lib/prisma.js';
import type { MemberOverview, CohortRow, DateRange } from './types.js';

// ANALYTICS-01: Member overview counts
export async function getMemberOverview(): Promise<MemberOverview> {
  const thirtyDaysAgo = new Date();
  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

  const [total, active, newMembers] = await Promise.all([
    prisma.member.count({
      where: { subscriptionStatus: { in: ['ACTIVE', 'TRIALING', 'PAST_DUE'] } },
    }),
    prisma.member.count({
      where: {
        subscriptionStatus: { in: ['ACTIVE', 'TRIALING'] },
        lastActiveAt: { gte: thirtyDaysAgo },
      },
    }),
    prisma.member.count({
      where: {
        subscriptionStatus: { in: ['ACTIVE', 'TRIALING'] },
        createdAt: { gte: thirtyDaysAgo },
      },
    }),
  ]);

  // MRR estimate: count individual * $XX + count team * $YY
  // For now, simple count * estimated average ($50/mo placeholder)
  const mrr = total * 50;

  return {
    totalMembers: total,
    activeMembers: active,
    inactiveMembers: total - active,
    newMembers30d: newMembers,
    mrr,
  };
}

// ANALYTICS-06: Cohort retention analysis
export async function getCohortRetention(): Promise<CohortRow[]> {
  // Use raw SQL for efficient cohort analysis
  const rows = await prisma.$queryRaw<Array<{
    cohort: string;
    month0: bigint;
    month1: bigint;
    month2: bigint;
    month3: bigint;
    month4: bigint;
    month5: bigint;
  }>>`
    WITH cohorts AS (
      SELECT
        id,
        DATE_TRUNC('month', "createdAt") as cohort_month
      FROM "Member"
      WHERE "subscriptionStatus" != 'NONE'
    ),
    activity AS (
      SELECT
        "memberId",
        DATE_TRUNC('month', "createdAt") as activity_month
      FROM "PointTransaction"
      WHERE points > 0
      GROUP BY "memberId", DATE_TRUNC('month', "createdAt")
    )
    SELECT
      TO_CHAR(c.cohort_month, 'YYYY-MM') as cohort,
      COUNT(DISTINCT c.id)::bigint as month0,
      COUNT(DISTINCT CASE WHEN a.activity_month = c.cohort_month + INTERVAL '1 month' THEN c.id END)::bigint as month1,
      COUNT(DISTINCT CASE WHEN a.activity_month = c.cohort_month + INTERVAL '2 months' THEN c.id END)::bigint as month2,
      COUNT(DISTINCT CASE WHEN a.activity_month = c.cohort_month + INTERVAL '3 months' THEN c.id END)::bigint as month3,
      COUNT(DISTINCT CASE WHEN a.activity_month = c.cohort_month + INTERVAL '4 months' THEN c.id END)::bigint as month4,
      COUNT(DISTINCT CASE WHEN a.activity_month = c.cohort_month + INTERVAL '5 months' THEN c.id END)::bigint as month5
    FROM cohorts c
    LEFT JOIN activity a ON c.id = a."memberId"
    GROUP BY c.cohort_month
    ORDER BY c.cohort_month DESC
    LIMIT 12
  `;

  // Convert bigints and calculate percentages
  return rows.map((row) => {
    const m0 = Number(row.month0);
    return {
      cohort: row.cohort,
      month0: m0,
      month1: Number(row.month1),
      month2: Number(row.month2),
      month3: Number(row.month3),
      month4: Number(row.month4),
      month5: Number(row.month5),
      month0Pct: 100,
      month1Pct: m0 > 0 ? Math.round((Number(row.month1) / m0) * 100) : 0,
      month2Pct: m0 > 0 ? Math.round((Number(row.month2) / m0) * 100) : 0,
      month3Pct: m0 > 0 ? Math.round((Number(row.month3) / m0) * 100) : 0,
      month4Pct: m0 > 0 ? Math.round((Number(row.month4) / m0) * 100) : 0,
      month5Pct: m0 > 0 ? Math.round((Number(row.month5) / m0) * 100) : 0,
    };
  });
}
```

**engagement-analytics.ts**: Create functions for engagement trends.

```typescript
import { prisma } from '../lib/prisma.js';
import type { EngagementTrend, EngagementComparison, DailyEngagement, DateRange } from './types.js';

// ANALYTICS-02: Engagement metrics with time-series
export async function getEngagementTrend(range: DateRange): Promise<EngagementTrend> {
  const rows = await prisma.$queryRaw<Array<{
    date: Date;
    benchmarks: bigint;
    downloads: bigint;
    discord: bigint;
  }>>`
    SELECT
      DATE_TRUNC('day', "createdAt") as date,
      COUNT(*) FILTER (WHERE action = 'benchmark_submission')::bigint as benchmarks,
      COUNT(*) FILTER (WHERE action = 'resource_download')::bigint as downloads,
      COUNT(*) FILTER (WHERE action = 'discord_activity')::bigint as discord
    FROM "PointTransaction"
    WHERE "createdAt" >= ${range.startDate}
      AND "createdAt" < ${range.endDate}
      AND points > 0
    GROUP BY DATE_TRUNC('day', "createdAt")
    ORDER BY date
  `;

  const data: DailyEngagement[] = rows.map((row) => ({
    date: row.date.toISOString().split('T')[0],
    benchmarks: Number(row.benchmarks),
    downloads: Number(row.downloads),
    discordActivity: Number(row.discord),
    total: Number(row.benchmarks) + Number(row.downloads) + Number(row.discord),
  }));

  return {
    data,
    periodStart: range.startDate.toISOString(),
    periodEnd: range.endDate.toISOString(),
  };
}

// ANALYTICS-09: Month-over-month comparison
export async function getEngagementComparison(
  currentRange: DateRange,
  previousRange: DateRange
): Promise<EngagementComparison> {
  const [current, previous] = await Promise.all([
    getEngagementTrend(currentRange),
    getEngagementTrend(previousRange),
  ]);

  // Calculate totals for change percentage
  const sumTrend = (trend: EngagementTrend) => {
    return trend.data.reduce(
      (acc, d) => ({
        benchmarks: acc.benchmarks + d.benchmarks,
        downloads: acc.downloads + d.downloads,
        discord: acc.discord + d.discordActivity,
        total: acc.total + d.total,
      }),
      { benchmarks: 0, downloads: 0, discord: 0, total: 0 }
    );
  };

  const currentSum = sumTrend(current);
  const previousSum = sumTrend(previous);

  const calcChange = (curr: number, prev: number) => {
    if (prev === 0) return curr > 0 ? 100 : 0;
    return Math.round(((curr - prev) / prev) * 100);
  };

  return {
    current,
    previous,
    change: {
      benchmarks: calcChange(currentSum.benchmarks, previousSum.benchmarks),
      downloads: calcChange(currentSum.downloads, previousSum.downloads),
      discordActivity: calcChange(currentSum.discord, previousSum.discord),
      total: calcChange(currentSum.total, previousSum.total),
    },
  };
}
```

Both files should import types from './types.js' and prisma from '../lib/prisma.js'.
  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit`</verify>
  <done>Member analytics and engagement analytics services created with typed functions</done>
</task>

<task type="auto">
  <name>Task 3: Create Benchmark, Resource Analytics, and Churn Prediction</name>
  <files>src/analytics/benchmark-analytics.ts, src/analytics/resource-analytics.ts, src/analytics/churn-prediction.ts</files>
  <action>
**benchmark-analytics.ts**: Benchmark statistics by category and trends.

```typescript
import { prisma } from '../lib/prisma.js';
import { BenchmarkCategory } from '@prisma/client';
import type { BenchmarkStats, CategoryStats, BenchmarkTrend, DateRange, SegmentFilters, BenchmarkInsightsResult, BenchmarkInsight } from './types.js';

// ANALYTICS-03: Benchmark submission rate by category
export async function getBenchmarkStats(): Promise<BenchmarkStats> {
  const categories: BenchmarkCategory[] = ['COMPENSATION', 'INFRASTRUCTURE', 'BUSINESS', 'OPERATIONAL'];

  const byCategory = await Promise.all(
    categories.map(async (category) => {
      const [total, valid, flagged, uniqueMembers] = await Promise.all([
        prisma.benchmarkSubmission.count({ where: { category } }),
        prisma.benchmarkSubmission.count({ where: { category, isValid: true } }),
        prisma.benchmarkSubmission.count({ where: { category, isValid: false } }),
        prisma.benchmarkSubmission.groupBy({
          by: ['memberId'],
          where: { category },
        }).then((g) => g.length),
      ]);
      return {
        category,
        submissionCount: total,
        validCount: valid,
        flaggedCount: flagged,
        uniqueMembers,
      } as CategoryStats;
    })
  );

  return {
    byCategory,
    total: {
      submissions: byCategory.reduce((s, c) => s + c.submissionCount, 0),
      validSubmissions: byCategory.reduce((s, c) => s + c.validCount, 0),
      flaggedSubmissions: byCategory.reduce((s, c) => s + c.flaggedCount, 0),
      uniqueMembers: await prisma.benchmarkSubmission
        .groupBy({ by: ['memberId'] })
        .then((g) => g.length),
    },
  };
}

// ANALYTICS-03: Benchmark trends over time
export async function getBenchmarkTrends(range: DateRange): Promise<BenchmarkTrend[]> {
  const rows = await prisma.$queryRaw<Array<{
    date: Date;
    category: string;
    count: bigint;
  }>>`
    SELECT
      DATE_TRUNC('day', "submittedAt") as date,
      category::text,
      COUNT(*)::bigint as count
    FROM "BenchmarkSubmission"
    WHERE "submittedAt" >= ${range.startDate}
      AND "submittedAt" < ${range.endDate}
    GROUP BY DATE_TRUNC('day', "submittedAt"), category
    ORDER BY date, category
  `;

  return rows.map((row) => ({
    date: row.date.toISOString().split('T')[0],
    category: row.category,
    count: Number(row.count),
  }));
}

// ANALYTICS-05: Industry insights by segment with JSONB aggregation
// Aggregates BUSINESS category submissions to compute percentiles and medians
// for key revenue metrics filtered by optional segment criteria.
export async function getBenchmarkInsights(filters: SegmentFilters): Promise<BenchmarkInsightsResult> {
  // Build WHERE clause for JSONB filtering
  // Filters apply to member profile data stored in JSONB
  const whereConditions: string[] = ["category = 'BUSINESS'", '"isValid" = true'];

  // Note: companySize, industry, role are stored in submission data->>'field' format
  // This is a simplified implementation. Full implementation would join with Member
  // table for profile-based filtering or use JSONB path queries.

  const filterParams: unknown[] = [];
  let paramIndex = 1;

  if (filters.companySize) {
    whereConditions.push(`data->>'companySize' = $${paramIndex}`);
    filterParams.push(filters.companySize);
    paramIndex++;
  }

  if (filters.industry) {
    whereConditions.push(`data->>'industry' = $${paramIndex}`);
    filterParams.push(filters.industry);
    paramIndex++;
  }

  // Key metrics to aggregate from BUSINESS category JSONB data
  const metrics = ['annualRevenue', 'arpu', 'ltv', 'churnRate', 'cac'];
  const insights: BenchmarkInsight[] = [];

  for (const metric of metrics) {
    // Use raw SQL for JSONB extraction and percentile calculations
    const query = `
      WITH extracted AS (
        SELECT (data->>'${metric}')::numeric as value
        FROM "BenchmarkSubmission"
        WHERE ${whereConditions.join(' AND ')}
          AND data->>'${metric}' IS NOT NULL
          AND (data->>'${metric}')::numeric IS NOT NULL
      )
      SELECT
        COUNT(*) as sample_size,
        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY value) as median,
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY value) as p25,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY value) as p75,
        AVG(value) as avg
      FROM extracted
      WHERE value IS NOT NULL
    `;

    try {
      const result = await prisma.$queryRawUnsafe<Array<{
        sample_size: bigint;
        median: number | null;
        p25: number | null;
        p75: number | null;
        avg: number | null;
      }>>(query, ...filterParams);

      if (result.length > 0 && Number(result[0].sample_size) > 0) {
        insights.push({
          metric,
          sampleSize: Number(result[0].sample_size),
          median: result[0].median ? Number(result[0].median) : null,
          p25: result[0].p25 ? Number(result[0].p25) : null,
          p75: result[0].p75 ? Number(result[0].p75) : null,
          avg: result[0].avg ? Number(result[0].avg) : null,
        });
      }
    } catch {
      // Skip metrics that fail (e.g., if field doesn't exist in data)
      continue;
    }
  }

  // Get total sample size for the filtered set
  const totalResult = await prisma.benchmarkSubmission.count({
    where: {
      category: 'BUSINESS',
      isValid: true,
    },
  });

  return {
    filters,
    insights,
    sampleSize: totalResult,
  };
}
```

**resource-analytics.ts**: Resource download analytics.

```typescript
import { prisma } from '../lib/prisma.js';
import type { ResourceStats, PopularResource, TrendingResource, DateRange } from './types.js';

// ANALYTICS-04: Resource download analytics
export async function getResourceStats(range?: DateRange): Promise<ResourceStats> {
  const whereClause = range
    ? { downloadedAt: { gte: range.startDate, lt: range.endDate } }
    : {};

  const [totalResources, totalDownloads, uniqueDownloaders, downloadsThisPeriod] = await Promise.all([
    prisma.resource.count({ where: { deletedAt: null, status: 'PUBLISHED' } }),
    prisma.resourceDownload.count(),
    prisma.resourceDownload.groupBy({ by: ['memberId'] }).then((g) => g.length),
    range
      ? prisma.resourceDownload.count({ where: whereClause })
      : prisma.resourceDownload.count(),
  ]);

  return {
    totalResources,
    totalDownloads,
    uniqueDownloaders,
    downloadsThisPeriod,
  };
}

// ANALYTICS-04: Most popular resources
export async function getPopularResources(limit = 10): Promise<PopularResource[]> {
  const resources = await prisma.resource.findMany({
    where: { deletedAt: null, status: 'PUBLISHED' },
    orderBy: { downloadCount: 'desc' },
    take: limit,
    select: {
      id: true,
      title: true,
      type: true,
      downloadCount: true,
      _count: { select: { downloads: true } },
    },
  });

  // Get unique downloader count per resource
  const uniqueCounts = await Promise.all(
    resources.map((r) =>
      prisma.resourceDownload.groupBy({
        by: ['memberId'],
        where: { resourceId: r.id },
      }).then((g) => g.length)
    )
  );

  return resources.map((r, i) => ({
    id: r.id,
    title: r.title,
    type: r.type,
    downloadCount: r.downloadCount,
    uniqueDownloaders: uniqueCounts[i],
  }));
}

// ANALYTICS-04: Trending resources (growth-based)
export async function getTrendingResources(limit = 10): Promise<TrendingResource[]> {
  const now = new Date();
  const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
  const fourteenDaysAgo = new Date(now.getTime() - 14 * 24 * 60 * 60 * 1000);

  // Get download counts for last 7 days and previous 7 days per resource
  const rows = await prisma.$queryRaw<Array<{
    resourceId: string;
    recentDownloads: bigint;
    previousDownloads: bigint;
  }>>`
    SELECT
      "resourceId",
      COUNT(*) FILTER (WHERE "downloadedAt" >= ${sevenDaysAgo})::bigint as "recentDownloads",
      COUNT(*) FILTER (WHERE "downloadedAt" >= ${fourteenDaysAgo} AND "downloadedAt" < ${sevenDaysAgo})::bigint as "previousDownloads"
    FROM "ResourceDownload"
    WHERE "downloadedAt" >= ${fourteenDaysAgo}
    GROUP BY "resourceId"
    HAVING COUNT(*) FILTER (WHERE "downloadedAt" >= ${sevenDaysAgo}) > 0
    ORDER BY COUNT(*) FILTER (WHERE "downloadedAt" >= ${sevenDaysAgo}) DESC
    LIMIT ${limit * 2}
  `;

  // Get resource details and calculate growth
  const resourceIds = rows.map((r) => r.resourceId);
  const resources = await prisma.resource.findMany({
    where: { id: { in: resourceIds }, deletedAt: null },
    select: { id: true, title: true, type: true },
  });

  const resourceMap = new Map(resources.map((r) => [r.id, r]));

  return rows
    .map((row) => {
      const resource = resourceMap.get(row.resourceId);
      if (!resource) return null;

      const recent = Number(row.recentDownloads);
      const previous = Number(row.previousDownloads);
      const growthPercent = previous === 0 ? 100 : Math.round(((recent - previous) / previous) * 100);

      return {
        id: resource.id,
        title: resource.title,
        type: resource.type,
        recentDownloads: recent,
        previousDownloads: previous,
        growthPercent,
      };
    })
    .filter((r): r is TrendingResource => r !== null)
    .sort((a, b) => b.growthPercent - a.growthPercent)
    .slice(0, limit);
}
```

**churn-prediction.ts**: Multi-factor churn risk scoring per CONTEXT.md.

```typescript
import { prisma } from '../lib/prisma.js';
import type { ChurnRiskScore, ChurnRiskFactor } from './types.js';

// ANALYTICS-07: Churn prediction with multi-factor scoring
// Factors: inactivity duration, declining engagement trend, payment issues
export async function calculateChurnRisk(memberId: string): Promise<ChurnRiskScore | null> {
  const member = await prisma.member.findUnique({
    where: { id: memberId },
    include: {
      pointTransactions: {
        take: 60,
        orderBy: { createdAt: 'desc' },
        where: { points: { gt: 0 } },
      },
    },
  });

  if (!member) return null;

  let score = 0;
  const factors: ChurnRiskFactor[] = [];

  // Factor 1: Inactivity duration (0-40 points)
  const daysSinceActive = member.lastActiveAt
    ? Math.floor((Date.now() - member.lastActiveAt.getTime()) / (1000 * 60 * 60 * 24))
    : 999;

  if (daysSinceActive > 30) {
    score += 40;
    factors.push({
      factor: 'inactivity',
      points: 40,
      description: `Inactive for ${daysSinceActive} days`,
    });
  } else if (daysSinceActive > 14) {
    score += 20;
    factors.push({
      factor: 'inactivity',
      points: 20,
      description: `Inactive for ${daysSinceActive} days`,
    });
  } else if (daysSinceActive > 7) {
    score += 10;
    factors.push({
      factor: 'inactivity',
      points: 10,
      description: `Inactive for ${daysSinceActive} days`,
    });
  }

  // Factor 2: Declining engagement trend (0-30 points)
  const now = Date.now();
  const fourteenDaysAgo = now - 14 * 24 * 60 * 60 * 1000;
  const twentyEightDaysAgo = now - 28 * 24 * 60 * 60 * 1000;

  const recentActivity = member.pointTransactions.filter(
    (t) => t.createdAt.getTime() > fourteenDaysAgo
  ).length;
  const olderActivity = member.pointTransactions.filter(
    (t) => t.createdAt.getTime() > twentyEightDaysAgo && t.createdAt.getTime() <= fourteenDaysAgo
  ).length;

  if (olderActivity > 0 && recentActivity < olderActivity * 0.5) {
    score += 30;
    factors.push({
      factor: 'declining_engagement',
      points: 30,
      description: 'Engagement declined by 50%+',
    });
  } else if (olderActivity > 0 && recentActivity < olderActivity * 0.75) {
    score += 15;
    factors.push({
      factor: 'declining_engagement',
      points: 15,
      description: 'Engagement declining',
    });
  }

  // Factor 3: Payment issues (0-30 points)
  if (member.subscriptionStatus === 'PAST_DUE') {
    score += 30;
    factors.push({
      factor: 'payment_issues',
      points: 30,
      description: 'Payment past due',
    });
  } else if (member.paymentFailedAt && !member.gracePeriodEndsAt) {
    score += 15;
    factors.push({
      factor: 'payment_issues',
      points: 15,
      description: 'Recent payment failure',
    });
  }

  const finalScore = Math.min(score, 100);
  const riskLevel = finalScore >= 60 ? 'high' : finalScore >= 30 ? 'medium' : 'low';

  return {
    memberId,
    email: member.email || '',
    discordUsername: member.discordUsername,
    score: finalScore,
    riskLevel,
    factors,
    lastActiveAt: member.lastActiveAt,
    subscriptionStatus: member.subscriptionStatus,
  };
}

// ANALYTICS-07: Get all at-risk members (score >= 30)
export async function getAtRiskMembers(minScore = 30, limit = 50): Promise<ChurnRiskScore[]> {
  // Get active subscription members
  const members = await prisma.member.findMany({
    where: {
      subscriptionStatus: { in: ['ACTIVE', 'TRIALING', 'PAST_DUE'] },
    },
    select: { id: true },
    take: 500,  // Process in batches to avoid memory issues
  });

  const scores: ChurnRiskScore[] = [];

  for (const member of members) {
    const risk = await calculateChurnRisk(member.id);
    if (risk && risk.score >= minScore) {
      scores.push(risk);
    }
    // Stop once we have enough
    if (scores.length >= limit) break;
  }

  // Sort by score descending
  return scores.sort((a, b) => b.score - a.score).slice(0, limit);
}
```

All three files should have proper imports and follow existing codebase patterns.
  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit`</verify>
  <done>Benchmark analytics, resource analytics, and churn prediction services created</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. All files exist in `src/analytics/` directory
2. `npx tsc --noEmit` passes without errors
3. All types are properly exported from types.ts
4. All service functions are exported from their respective files
5. Import paths use `.js` extension per ESM convention
</verification>

<success_criteria>
- [ ] src/analytics/types.ts exists with all analytics interfaces including BenchmarkInsight types
- [ ] src/analytics/member-analytics.ts exports getMemberOverview, getCohortRetention
- [ ] src/analytics/engagement-analytics.ts exports getEngagementTrend, getEngagementComparison
- [ ] src/analytics/benchmark-analytics.ts exports getBenchmarkStats, getBenchmarkTrends, getBenchmarkInsights
- [ ] src/analytics/resource-analytics.ts exports getResourceStats, getPopularResources, getTrendingResources
- [ ] src/analytics/churn-prediction.ts exports calculateChurnRisk, getAtRiskMembers
- [ ] getBenchmarkInsights implements JSONB percentile aggregation for ANALYTICS-05
- [ ] TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/33-admin-analytics/33-01-SUMMARY.md`
</output>
