---
phase: 33-admin-analytics
plan: 02
type: execute
wave: 2
depends_on: ["33-01"]
files_modified:
  - src/analytics/export.ts
  - src/routes/admin/analytics.ts
  - src/jobs/churn-digest.ts
  - src/jobs/index.ts
  - package.json

autonomous: true

must_haves:
  truths:
    - "Admin can access analytics API endpoints with Bearer token"
    - "Admin can export member data as CSV"
    - "Admin can export member data as JSON"
    - "Analytics endpoints return real-time data (no caching)"
    - "Churn digest job runs weekly and sends email to admins"
  artifacts:
    - path: "src/analytics/export.ts"
      provides: "CSV and JSON export functions"
      exports: ["exportMembersToCsv", "exportMembersToJson", "exportAnalyticsCsv"]
    - path: "src/routes/admin/analytics.ts"
      provides: "Admin analytics API endpoints"
      exports: ["adminAnalyticsRouter"]
    - path: "src/jobs/churn-digest.ts"
      provides: "Weekly churn digest email job"
      exports: ["sendChurnDigest"]
  key_links:
    - from: "src/routes/admin/analytics.ts"
      to: "src/analytics/*"
      via: "Service imports"
      pattern: "from.*analytics/"
    - from: "src/routes/admin/analytics.ts"
      to: "src/admin/middleware.ts"
      via: "requireAdmin middleware"
      pattern: "requireAdmin"
    - from: "src/jobs/index.ts"
      to: "src/jobs/churn-digest.ts"
      via: "Job scheduling"
      pattern: "sendChurnDigest"
---

<objective>
Create admin analytics API endpoints, export functionality, and churn digest background job.

Purpose: Exposes analytics services via REST API for frontend consumption, enables CRM sync via exports, and automates churn alerts via weekly email digest.

Output: Admin analytics router with all endpoints, export service, and churn digest job.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/33-admin-analytics/33-CONTEXT.md
@.planning/phases/33-admin-analytics/33-RESEARCH.md
@.planning/phases/33-admin-analytics/33-01-SUMMARY.md

Key patterns from existing codebase:
- src/routes/admin/benchmarks.ts: Admin route pattern with requireAdmin middleware
- src/jobs/index.ts: Job scheduler pattern with cron
- src/email/send.ts: Email sending pattern
- package.json: Dependencies list
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Export Service and Install Dependencies</name>
  <files>src/analytics/export.ts, package.json</files>
  <action>
First, install the required dependency:

```bash
npm install json2csv
npm install --save-dev @types/json2csv
```

Then create **src/analytics/export.ts**:

```typescript
/**
 * Analytics Export Service
 * ANALYTICS-08: Export data for CRM sync (CSV or JSON)
 */

import { Parser } from 'json2csv';
import { prisma } from '../lib/prisma.js';
import type { Response } from 'express';
import type { EngagementTrend, CohortRow, BenchmarkStats, ResourceStats } from './types.js';

// Export filters
interface ExportFilters {
  subscriptionStatus?: string[];
  minPoints?: number;
  maxPoints?: number;
  activeWithin?: number; // days
  createdAfter?: Date;
  createdBefore?: Date;
}

// Member export data shape
interface MemberExportRow {
  id: string;
  email: string | null;
  discordUsername: string | null;
  company: string | null;
  jobTitle: string | null;
  subscriptionStatus: string;
  totalPoints: number;
  currentStreak: number;
  lastActiveAt: string | null;
  createdAt: string;
}

/**
 * Get members for export with optional filters
 */
async function getMembersForExport(filters: ExportFilters = {}): Promise<MemberExportRow[]> {
  const where: Record<string, unknown> = {};

  if (filters.subscriptionStatus?.length) {
    where.subscriptionStatus = { in: filters.subscriptionStatus };
  }

  if (filters.minPoints !== undefined) {
    where.totalPoints = { ...(where.totalPoints as object || {}), gte: filters.minPoints };
  }

  if (filters.maxPoints !== undefined) {
    where.totalPoints = { ...(where.totalPoints as object || {}), lte: filters.maxPoints };
  }

  if (filters.activeWithin) {
    const cutoff = new Date();
    cutoff.setDate(cutoff.getDate() - filters.activeWithin);
    where.lastActiveAt = { gte: cutoff };
  }

  if (filters.createdAfter) {
    where.createdAt = { ...(where.createdAt as object || {}), gte: filters.createdAfter };
  }

  if (filters.createdBefore) {
    where.createdAt = { ...(where.createdAt as object || {}), lte: filters.createdBefore };
  }

  const members = await prisma.member.findMany({
    where,
    select: {
      id: true,
      email: true,
      discordUsername: true,
      company: true,
      jobTitle: true,
      subscriptionStatus: true,
      totalPoints: true,
      currentStreak: true,
      lastActiveAt: true,
      createdAt: true,
    },
    orderBy: { createdAt: 'desc' },
    take: 10000, // Limit to prevent memory issues
  });

  return members.map((m) => ({
    id: m.id,
    email: m.email,
    discordUsername: m.discordUsername,
    company: m.company,
    jobTitle: m.jobTitle,
    subscriptionStatus: m.subscriptionStatus,
    totalPoints: m.totalPoints,
    currentStreak: m.currentStreak,
    lastActiveAt: m.lastActiveAt?.toISOString() || null,
    createdAt: m.createdAt.toISOString(),
  }));
}

/**
 * Export members to CSV and send as response
 */
export async function exportMembersToCsv(
  res: Response,
  filters: ExportFilters = {}
): Promise<void> {
  const members = await getMembersForExport(filters);

  const fields = [
    { label: 'ID', value: 'id' },
    { label: 'Email', value: 'email' },
    { label: 'Discord Username', value: 'discordUsername' },
    { label: 'Company', value: 'company' },
    { label: 'Job Title', value: 'jobTitle' },
    { label: 'Subscription Status', value: 'subscriptionStatus' },
    { label: 'Total Points', value: 'totalPoints' },
    { label: 'Current Streak', value: 'currentStreak' },
    { label: 'Last Active', value: 'lastActiveAt' },
    { label: 'Created At', value: 'createdAt' },
  ];

  const parser = new Parser({ fields });
  const csv = parser.parse(members);

  const filename = `members-export-${new Date().toISOString().split('T')[0]}.csv`;

  res.setHeader('Content-Type', 'text/csv');
  res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
  res.send(csv);
}

/**
 * Export members to JSON and send as response
 */
export async function exportMembersToJson(
  res: Response,
  filters: ExportFilters = {}
): Promise<void> {
  const members = await getMembersForExport(filters);

  const filename = `members-export-${new Date().toISOString().split('T')[0]}.json`;

  res.setHeader('Content-Type', 'application/json');
  res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
  res.json({
    exportedAt: new Date().toISOString(),
    count: members.length,
    members,
  });
}

/**
 * Export any analytics data to CSV
 * Generic function for exporting arrays of objects
 */
export async function exportAnalyticsCsv<T extends Record<string, unknown>>(
  res: Response,
  data: T[],
  filename: string,
  fields?: { label: string; value: string }[]
): Promise<void> {
  // Auto-detect fields if not provided
  const exportFields = fields || (data.length > 0
    ? Object.keys(data[0]).map((key) => ({ label: key, value: key }))
    : []);

  const parser = new Parser({ fields: exportFields });
  const csv = parser.parse(data);

  res.setHeader('Content-Type', 'text/csv');
  res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
  res.send(csv);
}

// Export types for use in routes
export type { ExportFilters };
```

Verify json2csv is installed and types are available.
  </action>
  <verify>`npm list json2csv` shows the package installed. TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>Export service created with CSV and JSON export functions, json2csv dependency installed</done>
</task>

<task type="auto">
  <name>Task 2: Create Admin Analytics API Router</name>
  <files>src/routes/admin/analytics.ts, src/index.ts</files>
  <action>
Create **src/routes/admin/analytics.ts**:

```typescript
/**
 * Admin Analytics API Routes
 * Endpoints for admin analytics dashboard
 *
 * All endpoints require admin authentication via Bearer token.
 * ANALYTICS-10: No caching - data updates in real-time.
 */

import { Router } from 'express';
import { z } from 'zod';
import { requireAdmin } from '../../admin/middleware.js';

// Analytics services (from Plan 33-01)
import { getMemberOverview, getCohortRetention } from '../../analytics/member-analytics.js';
import { getEngagementTrend, getEngagementComparison } from '../../analytics/engagement-analytics.js';
import { getBenchmarkStats, getBenchmarkTrends } from '../../analytics/benchmark-analytics.js';
import { getResourceStats, getPopularResources, getTrendingResources } from '../../analytics/resource-analytics.js';
import { getAtRiskMembers, calculateChurnRisk } from '../../analytics/churn-prediction.js';
import { exportMembersToCsv, exportMembersToJson } from '../../analytics/export.js';

export const adminAnalyticsRouter = Router();

// Apply admin auth to all routes
adminAnalyticsRouter.use(requireAdmin);

// Date range schema for query params
const dateRangeSchema = z.object({
  startDate: z.string().optional().transform((s) => s ? new Date(s) : undefined),
  endDate: z.string().optional().transform((s) => s ? new Date(s) : undefined),
});

// Helper to get default 30-day range
function getDefaultRange() {
  const endDate = new Date();
  const startDate = new Date();
  startDate.setDate(startDate.getDate() - 30);
  return { startDate, endDate };
}

/**
 * GET /api/admin/analytics/overview
 * ANALYTICS-01: Member overview (total, active, inactive, MRR)
 */
adminAnalyticsRouter.get('/overview', async (req, res) => {
  const overview = await getMemberOverview();
  res.json(overview);
});

/**
 * GET /api/admin/analytics/engagement
 * ANALYTICS-02: Engagement metrics with time-series
 * Query params: startDate, endDate (defaults to last 30 days)
 */
adminAnalyticsRouter.get('/engagement', async (req, res) => {
  const query = dateRangeSchema.parse(req.query);
  const range = query.startDate && query.endDate
    ? { startDate: query.startDate, endDate: query.endDate }
    : getDefaultRange();

  const trend = await getEngagementTrend(range);
  res.json(trend);
});

/**
 * GET /api/admin/analytics/engagement/compare
 * ANALYTICS-09: Month-over-month comparison
 * Query params: startDate, endDate for current period (previous period auto-calculated)
 */
adminAnalyticsRouter.get('/engagement/compare', async (req, res) => {
  const query = dateRangeSchema.parse(req.query);

  // Current period
  const currentRange = query.startDate && query.endDate
    ? { startDate: query.startDate, endDate: query.endDate }
    : getDefaultRange();

  // Calculate previous period (same duration, immediately before)
  const duration = currentRange.endDate.getTime() - currentRange.startDate.getTime();
  const previousRange = {
    startDate: new Date(currentRange.startDate.getTime() - duration),
    endDate: new Date(currentRange.endDate.getTime() - duration),
  };

  const comparison = await getEngagementComparison(currentRange, previousRange);
  res.json(comparison);
});

/**
 * GET /api/admin/analytics/benchmarks
 * ANALYTICS-03: Benchmark submission stats by category
 */
adminAnalyticsRouter.get('/benchmarks', async (req, res) => {
  const stats = await getBenchmarkStats();
  res.json(stats);
});

/**
 * GET /api/admin/analytics/benchmarks/trends
 * ANALYTICS-03: Benchmark submission trends over time
 */
adminAnalyticsRouter.get('/benchmarks/trends', async (req, res) => {
  const query = dateRangeSchema.parse(req.query);
  const range = query.startDate && query.endDate
    ? { startDate: query.startDate, endDate: query.endDate }
    : getDefaultRange();

  const trends = await getBenchmarkTrends(range);
  res.json({ trends });
});

/**
 * GET /api/admin/analytics/resources
 * ANALYTICS-04: Resource download stats
 */
adminAnalyticsRouter.get('/resources', async (req, res) => {
  const query = dateRangeSchema.parse(req.query);
  const range = query.startDate && query.endDate
    ? { startDate: query.startDate, endDate: query.endDate }
    : undefined;

  const stats = await getResourceStats(range);
  res.json(stats);
});

/**
 * GET /api/admin/analytics/resources/popular
 * ANALYTICS-04: Most popular resources
 */
adminAnalyticsRouter.get('/resources/popular', async (req, res) => {
  const limit = z.coerce.number().min(1).max(50).default(10).parse(req.query.limit);
  const resources = await getPopularResources(limit);
  res.json({ resources });
});

/**
 * GET /api/admin/analytics/resources/trending
 * ANALYTICS-04: Trending resources (growth-based)
 */
adminAnalyticsRouter.get('/resources/trending', async (req, res) => {
  const limit = z.coerce.number().min(1).max(50).default(10).parse(req.query.limit);
  const resources = await getTrendingResources(limit);
  res.json({ resources });
});

/**
 * GET /api/admin/analytics/cohorts
 * ANALYTICS-06: Cohort retention analysis
 */
adminAnalyticsRouter.get('/cohorts', async (req, res) => {
  const cohorts = await getCohortRetention();
  res.json({ cohorts });
});

/**
 * GET /api/admin/analytics/at-risk
 * ANALYTICS-07: At-risk members (churn prediction)
 */
adminAnalyticsRouter.get('/at-risk', async (req, res) => {
  const query = z.object({
    minScore: z.coerce.number().min(0).max(100).default(30),
    limit: z.coerce.number().min(1).max(100).default(50),
  }).parse(req.query);

  const members = await getAtRiskMembers(query.minScore, query.limit);
  res.json({ members, count: members.length });
});

/**
 * GET /api/admin/analytics/at-risk/:memberId
 * ANALYTICS-07: Individual member churn risk details
 */
adminAnalyticsRouter.get('/at-risk/:memberId', async (req, res) => {
  const { memberId } = z.object({ memberId: z.string() }).parse(req.params);
  const risk = await calculateChurnRisk(memberId);

  if (!risk) {
    res.status(404).json({ error: 'Member not found' });
    return;
  }

  res.json(risk);
});

// Export filters schema
const exportFiltersSchema = z.object({
  subscriptionStatus: z.string().optional().transform((s) => s?.split(',').filter(Boolean)),
  minPoints: z.coerce.number().optional(),
  maxPoints: z.coerce.number().optional(),
  activeWithin: z.coerce.number().optional(),
  createdAfter: z.string().optional().transform((s) => s ? new Date(s) : undefined),
  createdBefore: z.string().optional().transform((s) => s ? new Date(s) : undefined),
});

/**
 * GET /api/admin/analytics/export/csv
 * ANALYTICS-08: Export members to CSV
 */
adminAnalyticsRouter.get('/export/csv', async (req, res) => {
  const filters = exportFiltersSchema.parse(req.query);
  await exportMembersToCsv(res, filters);
});

/**
 * GET /api/admin/analytics/export/json
 * ANALYTICS-08: Export members to JSON
 */
adminAnalyticsRouter.get('/export/json', async (req, res) => {
  const filters = exportFiltersSchema.parse(req.query);
  await exportMembersToJson(res, filters);
});
```

Then register the router in **src/index.ts**. Find the admin routes section and add:

```typescript
import { adminAnalyticsRouter } from './routes/admin/analytics.js';

// In the routes setup section:
app.use('/api/admin/analytics', adminAnalyticsRouter);
```
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`. Server starts without errors.</verify>
  <done>Admin analytics API router created with all endpoints, registered in main app</done>
</task>

<task type="auto">
  <name>Task 3: Create Churn Digest Job and Update Scheduler</name>
  <files>src/jobs/churn-digest.ts, src/jobs/index.ts</files>
  <action>
Create **src/jobs/churn-digest.ts**:

```typescript
/**
 * Churn Digest Email Job
 * ANALYTICS-07: Weekly email digest of at-risk members
 *
 * Runs weekly on Monday at 09:00 UTC
 * Sends email to configured admin addresses with at-risk member summary
 */

import { getAtRiskMembers } from '../analytics/churn-prediction.js';
import { emailProvider } from '../email/send.js';
import { prisma } from '../lib/prisma.js';
import { logger } from '../index.js';

// Threshold for high-risk (included prominently in digest)
const HIGH_RISK_THRESHOLD = 60;
const MEDIUM_RISK_THRESHOLD = 30;

interface DigestStats {
  totalAtRisk: number;
  highRisk: number;
  mediumRisk: number;
  emailsSent: number;
  errors: number;
}

/**
 * Get admin email addresses to receive digest
 * Uses admins with SUPER_ADMIN role
 */
async function getDigestRecipients(): Promise<string[]> {
  const admins = await prisma.admin.findMany({
    where: { role: 'SUPER_ADMIN' },
    select: { email: true },
  });
  return admins.map((a) => a.email);
}

/**
 * Build email content for churn digest
 */
function buildDigestEmail(atRiskMembers: Awaited<ReturnType<typeof getAtRiskMembers>>): { subject: string; text: string } {
  const highRisk = atRiskMembers.filter((m) => m.score >= HIGH_RISK_THRESHOLD);
  const mediumRisk = atRiskMembers.filter((m) => m.score >= MEDIUM_RISK_THRESHOLD && m.score < HIGH_RISK_THRESHOLD);

  const subject = `[TRC] Weekly Churn Alert: ${highRisk.length} high-risk, ${mediumRisk.length} medium-risk members`;

  let text = `Weekly Churn Risk Digest\n`;
  text += `========================\n\n`;
  text += `Summary:\n`;
  text += `- High Risk (60+): ${highRisk.length} members\n`;
  text += `- Medium Risk (30-59): ${mediumRisk.length} members\n`;
  text += `- Total At-Risk: ${atRiskMembers.length} members\n\n`;

  if (highRisk.length > 0) {
    text += `HIGH RISK MEMBERS\n`;
    text += `-----------------\n`;
    for (const member of highRisk.slice(0, 10)) {
      text += `\n${member.email || member.discordUsername || member.memberId}\n`;
      text += `  Score: ${member.score}/100\n`;
      text += `  Status: ${member.subscriptionStatus}\n`;
      text += `  Last Active: ${member.lastActiveAt ? member.lastActiveAt.toISOString().split('T')[0] : 'Never'}\n`;
      text += `  Factors:\n`;
      for (const factor of member.factors) {
        text += `    - ${factor.description} (+${factor.points})\n`;
      }
    }
    if (highRisk.length > 10) {
      text += `\n... and ${highRisk.length - 10} more high-risk members\n`;
    }
  }

  if (mediumRisk.length > 0) {
    text += `\nMEDIUM RISK MEMBERS\n`;
    text += `-------------------\n`;
    for (const member of mediumRisk.slice(0, 5)) {
      text += `\n${member.email || member.discordUsername || member.memberId}\n`;
      text += `  Score: ${member.score}/100 | Last Active: ${member.lastActiveAt ? member.lastActiveAt.toISOString().split('T')[0] : 'Never'}\n`;
    }
    if (mediumRisk.length > 5) {
      text += `\n... and ${mediumRisk.length - 5} more medium-risk members\n`;
    }
  }

  text += `\n\nView full details in the Admin Analytics Dashboard:\n`;
  text += `${process.env.APP_URL || 'https://app.therevcouncil.com'}/admin/analytics\n`;

  return { subject, text };
}

/**
 * Send weekly churn digest to all admin recipients
 */
export async function sendChurnDigest(): Promise<DigestStats> {
  const stats: DigestStats = {
    totalAtRisk: 0,
    highRisk: 0,
    mediumRisk: 0,
    emailsSent: 0,
    errors: 0,
  };

  try {
    // Get at-risk members
    const atRiskMembers = await getAtRiskMembers(MEDIUM_RISK_THRESHOLD, 100);
    stats.totalAtRisk = atRiskMembers.length;
    stats.highRisk = atRiskMembers.filter((m) => m.score >= HIGH_RISK_THRESHOLD).length;
    stats.mediumRisk = atRiskMembers.filter((m) => m.score >= MEDIUM_RISK_THRESHOLD && m.score < HIGH_RISK_THRESHOLD).length;

    // Skip if no at-risk members
    if (atRiskMembers.length === 0) {
      logger.info('Churn digest: No at-risk members, skipping email');
      return stats;
    }

    // Get recipients
    const recipients = await getDigestRecipients();
    if (recipients.length === 0) {
      logger.warn('Churn digest: No admin recipients configured');
      return stats;
    }

    // Build and send email
    const { subject, text } = buildDigestEmail(atRiskMembers);

    for (const email of recipients) {
      try {
        await emailProvider.send({ to: email, subject, text });
        stats.emailsSent++;
        logger.info({ email }, 'Churn digest email sent');
      } catch (error) {
        stats.errors++;
        logger.error({ email, error }, 'Failed to send churn digest email');
      }
    }
  } catch (error) {
    stats.errors++;
    logger.error({ error }, 'Churn digest job failed');
    throw error;
  }

  return stats;
}
```

Update **src/jobs/index.ts** to add the churn digest job:

Add import at top:
```typescript
import { sendChurnDigest } from './churn-digest.js';
```

Add the job in `startJobScheduler()` function after the streak job:

```typescript
  // Churn digest job - weekly on Monday at 09:00 UTC
  // Cron: 0 9 * * 1 (at 09:00 on Monday)
  const churnDigestJob = cron.schedule(
    '0 9 * * 1',
    async () => {
      try {
        const stats = await sendChurnDigest();
        logger.info(
          {
            totalAtRisk: stats.totalAtRisk,
            highRisk: stats.highRisk,
            mediumRisk: stats.mediumRisk,
            emailsSent: stats.emailsSent,
            errors: stats.errors,
          },
          'Churn digest completed'
        );
      } catch (error) {
        logger.error(
          { error: error instanceof Error ? { message: error.message, stack: error.stack } : error },
          'Churn digest job failed'
        );
      }
    },
    { timezone: 'UTC' }
  );
  scheduledTasks.push(churnDigestJob);
  logger.info({ cron: '0 9 * * 1', timezone: 'UTC' }, 'Churn digest job scheduled');
```

Add to exports at bottom:
```typescript
export { sendChurnDigest } from './churn-digest.js';
```

Update the types export if DigestStats needs to be exposed.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`. Server starts and logs show job scheduled.</verify>
  <done>Churn digest job created and integrated into job scheduler, runs weekly on Mondays</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm list json2csv` shows package installed
2. `npx tsc --noEmit` passes without errors
3. Server starts successfully with all analytics routes registered
4. `curl -H "Authorization: Bearer $TOKEN" http://localhost:4000/api/admin/analytics/overview` returns member overview
5. Export endpoints return CSV/JSON with correct headers
6. Job scheduler logs show churn digest job scheduled
</verification>

<success_criteria>
- [ ] json2csv dependency installed
- [ ] src/analytics/export.ts exports CSV and JSON functions
- [ ] src/routes/admin/analytics.ts registered at /api/admin/analytics
- [ ] All analytics endpoints protected by requireAdmin
- [ ] Export endpoints set proper Content-Type and Content-Disposition headers
- [ ] src/jobs/churn-digest.ts sends weekly digest to admins
- [ ] Churn digest job registered in scheduler (Monday 09:00 UTC)
- [ ] TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/33-admin-analytics/33-02-SUMMARY.md`
</output>
