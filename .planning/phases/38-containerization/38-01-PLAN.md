---
phase: 38-containerization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Dockerfile
  - .dockerignore
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Express backend builds successfully as Docker image"
    - "Container runs with non-root user"
    - "Health endpoint returns JSON with service status"
    - "Container handles SIGTERM for graceful shutdown"
  artifacts:
    - path: "Dockerfile"
      provides: "Multi-stage Alpine build for Express backend"
      contains: "FROM node:20-alpine"
    - path: ".dockerignore"
      provides: "Build context exclusions"
      contains: "node_modules"
    - path: "src/index.ts"
      provides: "Enhanced health check with degraded mode"
      contains: "checks.database"
  key_links:
    - from: "Dockerfile"
      to: "dist/index.js"
      via: "CMD directive"
      pattern: "CMD.*node.*dist/index.js"
    - from: "src/index.ts"
      to: "prisma.$queryRaw"
      via: "database health check"
      pattern: "await prisma.*SELECT 1"
---

<objective>
Create Express backend Dockerfile and enhance health endpoint for container deployment.

Purpose: Enable the Express backend to run in a production Docker container with proper health monitoring for orchestration tools.

Output:
- Dockerfile with multi-stage Alpine build
- .dockerignore for efficient build context
- Enhanced /health endpoint with service-by-service status
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/38-containerization/38-CONTEXT.md
@.planning/phases/38-containerization/38-RESEARCH.md
@src/index.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create .dockerignore for Express build</name>
  <files>.dockerignore</files>
  <action>
Create .dockerignore at project root to exclude unnecessary files from Docker build context:

```
node_modules
npm-debug.log
.git
.gitignore
.env
.env.*
*.md
dist
dashboard
.planning
.claude
```

Key exclusions:
- node_modules: Dependencies installed inside container
- dashboard: Frontend has its own Dockerfile
- .planning/.claude: Development artifacts
- dist: Built fresh in container
  </action>
  <verify>File exists and contains node_modules exclusion</verify>
  <done>.dockerignore excludes build artifacts and dashboard directory</done>
</task>

<task type="auto">
  <name>Task 2: Create multi-stage Express Dockerfile</name>
  <files>Dockerfile</files>
  <action>
Create Dockerfile at project root with three stages:

**Stage 1 - deps:** Install dependencies with native build tools for argon2
- Base: node:20-alpine
- Install: python3, make, g++ (for argon2 native compilation)
- Copy package*.json and prisma directory
- Run npm ci

**Stage 2 - builder:** Build TypeScript and generate Prisma client
- Base: node:20-alpine
- Copy node_modules from deps
- Copy all source files
- Run npx prisma generate (generates Alpine-compatible client)
- Run npm run build

**Stage 3 - runner:** Production image
- Base: node:20-alpine
- Create nodejs group (gid 1001) and expressuser user (uid 1001)
- Set WORKDIR /app
- Set NODE_ENV=production
- Copy from builder with --chown=expressuser:nodejs:
  - dist/
  - node_modules/
  - package.json
  - prisma/
  - public/
- Switch to expressuser (non-root)
- EXPOSE 80
- CMD ["node", "dist/index.js"]

Do NOT use:
- npm start (doesn't forward SIGTERM)
- libc6-compat (breaks Prisma musl engine)
- PM2 (container orchestration handles process management)
  </action>
  <verify>docker build -t trc-backend . completes without errors</verify>
  <done>Dockerfile builds Express backend as ~200MB Alpine image with non-root user</done>
</task>

<task type="auto">
  <name>Task 3: Enhance health endpoint with degraded mode</name>
  <files>src/index.ts</files>
  <action>
Update the /health endpoint (around line 229) to check service status and return degraded mode:

Replace the simple health check with:

```typescript
app.get('/health', async (req, res) => {
  const checks: Record<string, boolean> = {
    database: false,
    discord: false,
  };

  // Check database connectivity
  try {
    await prisma.$queryRaw`SELECT 1`;
    checks.database = true;
  } catch {
    checks.database = false;
  }

  // Check Discord bot status
  checks.discord = discordClient.isReady();

  // Degraded mode: Return 200 with status JSON
  // App stays available even if non-critical dependencies are down
  const allHealthy = Object.values(checks).every(Boolean);

  res.status(200).json({
    status: allHealthy ? 'healthy' : 'degraded',
    timestamp: new Date().toISOString(),
    environment: env.NODE_ENV,
    checks,
  });
});
```

Key design decisions from CONTEXT.md:
- Always return HTTP 200 (container stays "healthy" for orchestration)
- status field indicates overall health: "healthy" or "degraded"
- checks object shows individual service status
- Allows app to serve traffic even if Discord bot is down
  </action>
  <verify>curl http://localhost:4000/health returns JSON with status, timestamp, environment, and checks fields</verify>
  <done>Health endpoint returns degraded mode JSON with database and discord status</done>
</task>

</tasks>

<verification>
1. Build Docker image: `docker build -t trc-backend .`
2. Verify image size is under 300MB: `docker images trc-backend`
3. Verify non-root user: `docker run --rm trc-backend whoami` should output "expressuser"
4. Start locally and test health: `npm run dev`, then `curl http://localhost:4000/health`
5. Health response includes: status, timestamp, environment, checks.database, checks.discord
</verification>

<success_criteria>
1. Dockerfile builds successfully with multi-stage Alpine
2. Final image runs as non-root user (expressuser)
3. /health returns 200 with JSON containing service status
4. argon2 compiles correctly (no node-gyp errors)
5. Prisma client generates for Alpine platform
</success_criteria>

<output>
After completion, create `.planning/phases/38-containerization/38-01-SUMMARY.md`
</output>
