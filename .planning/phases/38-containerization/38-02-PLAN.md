---
phase: 38-containerization
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - dashboard/Dockerfile
  - dashboard/.dockerignore
  - dashboard/src/app/api/health/route.ts
autonomous: true

must_haves:
  truths:
    - "Next.js frontend builds successfully as Docker image"
    - "Container runs with non-root user"
    - "Health endpoint returns 200 with JSON"
    - "Standalone output mode produces minimal image"
  artifacts:
    - path: "dashboard/Dockerfile"
      provides: "Multi-stage Alpine build for Next.js frontend"
      contains: "FROM node:20-alpine"
    - path: "dashboard/.dockerignore"
      provides: "Build context exclusions for dashboard"
      contains: "node_modules"
    - path: "dashboard/src/app/api/health/route.ts"
      provides: "Health check API route"
      exports: ["GET"]
  key_links:
    - from: "dashboard/Dockerfile"
      to: "server.js"
      via: "CMD directive"
      pattern: "CMD.*node.*server.js"
    - from: "dashboard/next.config.ts"
      to: "standalone"
      via: "output configuration"
      pattern: "output.*standalone"
---

<objective>
Create Next.js frontend Dockerfile with standalone output for minimal container size.

Purpose: Enable the Next.js dashboard to run in a production Docker container with efficient standalone output mode.

Output:
- dashboard/Dockerfile with multi-stage Alpine build
- dashboard/.dockerignore for efficient build context
- /api/health endpoint for container health checks
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/38-containerization/38-CONTEXT.md
@.planning/phases/38-containerization/38-RESEARCH.md
@dashboard/package.json
@dashboard/next.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create .dockerignore for Next.js build</name>
  <files>dashboard/.dockerignore</files>
  <action>
Create .dockerignore in dashboard directory to exclude unnecessary files:

```
node_modules
.next
.git
.gitignore
*.md
.env*.local
```

Key exclusions:
- node_modules: Dependencies installed inside container
- .next: Build output created fresh in container
- .env*.local: Local environment files
  </action>
  <verify>File exists at dashboard/.dockerignore</verify>
  <done>.dockerignore excludes node_modules and .next directories</done>
</task>

<task type="auto">
  <name>Task 2: Create health check API route</name>
  <files>dashboard/src/app/api/health/route.ts</files>
  <action>
Create Next.js App Router health endpoint:

```typescript
import { NextResponse } from 'next/server';

export async function GET() {
  return NextResponse.json({
    status: 'healthy',
    timestamp: new Date().toISOString(),
  });
}
```

This simple health check is sufficient for Next.js because:
- Next.js doesn't have direct database access (proxied through Express)
- Just needs to confirm the Node.js process is responding
- Traefik/Coolify uses this to verify container is ready
  </action>
  <verify>After Next.js is running: curl http://localhost:3000/api/health returns 200 with JSON</verify>
  <done>Health endpoint exists at /api/health and returns 200 with status JSON</done>
</task>

<task type="auto">
  <name>Task 3: Create multi-stage Next.js Dockerfile</name>
  <files>dashboard/Dockerfile</files>
  <action>
Create Dockerfile in dashboard directory with four stages:

**Stage 1 - base:** Common base with telemetry disabled
- Base: node:20-alpine
- ENV NEXT_TELEMETRY_DISABLED=1

**Stage 2 - deps:** Install dependencies
- FROM base AS deps
- RUN apk add --no-cache libc6-compat (for Alpine compatibility)
- WORKDIR /app
- Copy package*.json
- RUN npm ci

**Stage 3 - builder:** Build Next.js with standalone output
- FROM base AS builder
- WORKDIR /app
- Copy node_modules from deps
- Copy all source files
- RUN npm run build

**Stage 4 - runner:** Production image
- FROM base AS runner
- Create nodejs group (gid 1001) and nextjs user (uid 1001)
- WORKDIR /app
- Set NODE_ENV=production
- Copy public/ directory
- Copy --chown=nextjs:nodejs .next/standalone from builder
- Copy --chown=nextjs:nodejs .next/static to .next/static from builder
- Switch to nextjs user (non-root)
- EXPOSE 3000
- Set HOSTNAME=0.0.0.0 (critical: allows listening on all interfaces)
- CMD ["node", "server.js"]

IMPORTANT: HOSTNAME=0.0.0.0 is required for Docker networking. Without it, Next.js only listens on localhost and other containers cannot reach it.

Do NOT use:
- npm start (doesn't forward SIGTERM)
- node_modules in runner (standalone includes everything needed)
  </action>
  <verify>cd dashboard && docker build -t trc-dashboard . completes without errors</verify>
  <done>Dockerfile builds Next.js dashboard as ~150MB Alpine image with standalone output</done>
</task>

</tasks>

<verification>
1. Build Docker image: `cd dashboard && docker build -t trc-dashboard .`
2. Verify image size is under 200MB: `docker images trc-dashboard`
3. Verify non-root user: `docker run --rm trc-dashboard whoami` should output "nextjs"
4. Start container and test health: `docker run -p 3001:3000 trc-dashboard`, then `curl http://localhost:3001/api/health`
5. Health response includes: status, timestamp
</verification>

<success_criteria>
1. Dockerfile builds successfully with multi-stage Alpine
2. Final image under 200MB (standalone mode reduces size significantly)
3. Container runs as non-root user (nextjs)
4. /api/health returns 200 with JSON status
5. Container listens on all interfaces (HOSTNAME=0.0.0.0)
</success_criteria>

<output>
After completion, create `.planning/phases/38-containerization/38-02-SUMMARY.md`
</output>
