---
phase: 38-containerization
plan: 03
type: execute
wave: 2
depends_on: ["38-01", "38-02"]
files_modified:
  - docker-compose.yml
  - .env.example
autonomous: true

must_haves:
  truths:
    - "Both containers build successfully"
    - "Express can reach Next.js via http://nextjs:3000"
    - "Health checks pass for both services"
    - "Express proxies requests to Next.js correctly"
  artifacts:
    - path: "docker-compose.yml"
      provides: "Service orchestration for local testing"
      contains: "services:"
    - path: ".env.example"
      provides: "Documentation of required environment variables"
      contains: "DATABASE_URL"
  key_links:
    - from: "docker-compose.yml"
      to: "nextjs:3000"
      via: "NEXT_APP_URL environment"
      pattern: "NEXT_APP_URL.*nextjs"
    - from: "express service"
      to: "nextjs service"
      via: "depends_on with service_healthy"
      pattern: "depends_on.*condition.*service_healthy"
---

<objective>
Create docker-compose.yml and verify complete local stack works together.

Purpose: Enable local testing of the full containerized application before Coolify deployment, validating service discovery and health checks.

Output:
- docker-compose.yml with both services configured
- Updated .env.example documenting required variables
- Verified Express-to-Next.js connectivity
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/38-containerization/38-CONTEXT.md
@.planning/phases/38-containerization/38-RESEARCH.md
@.planning/phases/38-containerization/38-01-SUMMARY.md
@.planning/phases/38-containerization/38-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create docker-compose.yml</name>
  <files>docker-compose.yml</files>
  <action>
Create docker-compose.yml at project root:

```yaml
version: "3.8"

services:
  express:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "4000:80"
    environment:
      - NODE_ENV=production
      - PORT=80
      - NEXT_APP_URL=http://nextjs:3000
    env_file:
      - .env
    healthcheck:
      test: ["CMD", "node", "-e", "fetch('http://localhost:80/health').then(r => r.ok ? process.exit(0) : process.exit(1)).catch(() => process.exit(1))"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    depends_on:
      nextjs:
        condition: service_healthy

  nextjs:
    build:
      context: ./dashboard
      dockerfile: Dockerfile
    ports:
      - "3001:3000"
    environment:
      - NODE_ENV=production
      - HOSTNAME=0.0.0.0
    healthcheck:
      test: ["CMD", "node", "-e", "fetch('http://localhost:3000/api/health').then(r => r.ok ? process.exit(0) : process.exit(1)).catch(() => process.exit(1))"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

networks:
  default:
    name: trc-network
```

Key configuration decisions:
- Express on port 4000 externally, 80 internally (matches production pattern)
- Next.js on port 3001 externally for debug access, 3000 internally
- NEXT_APP_URL=http://nextjs:3000 enables service discovery
- Express depends_on nextjs with service_healthy condition
- Health checks use Node fetch (no curl/wget needed in Alpine)
- start_period allows services time to initialize before health checks fail
  </action>
  <verify>docker compose config validates without errors</verify>
  <done>docker-compose.yml defines both services with health checks and networking</done>
</task>

<task type="auto">
  <name>Task 2: Update .env.example with container variables</name>
  <files>.env.example</files>
  <action>
Read existing .env.example and add Docker-specific variables if not present.

Add these variables with CHANGEME placeholders:

```env
# ===========================================
# Docker/Container Configuration
# ===========================================
# Used when running with docker-compose

# Internal port for Express in container (default: 80)
PORT=80

# Next.js URL for proxy (container internal network)
NEXT_APP_URL=http://nextjs:3000
```

Keep all existing variables. The goal is to document what's needed for container deployment without breaking existing local dev setup.

Ensure these existing variables are documented (add if missing):
- DATABASE_URL
- STRIPE_SECRET_KEY
- STRIPE_WEBHOOK_SECRET
- DISCORD_TOKEN
- DISCORD_CLIENT_ID
- DISCORD_CLIENT_SECRET
- DISCORD_GUILD_ID
- JWT_SECRET
- APP_URL
- RESEND_API_KEY
  </action>
  <verify>cat .env.example shows Docker configuration section</verify>
  <done>.env.example documents all required variables including container-specific ones</done>
</task>

<task type="auto">
  <name>Task 3: Build and verify local stack</name>
  <files></files>
  <action>
Verify the complete containerized stack works:

1. Build both images:
   ```bash
   docker compose build
   ```

2. Start the stack:
   ```bash
   docker compose up -d
   ```

3. Wait for health checks to pass:
   ```bash
   docker compose ps
   ```
   Both services should show "healthy" status.

4. Test Next.js health directly:
   ```bash
   curl http://localhost:3001/api/health
   ```
   Expected: {"status":"healthy","timestamp":"..."}

5. Test Express health:
   ```bash
   curl http://localhost:4000/health
   ```
   Expected: {"status":"healthy" or "degraded","timestamp":"...","environment":"production","checks":{...}}

6. Test Express-to-Next.js proxy by accessing dashboard route through Express:
   ```bash
   curl -I http://localhost:4000/dashboard
   ```
   Expected: 200 or 302 (redirect to login) - NOT 502 Bad Gateway

7. Cleanup:
   ```bash
   docker compose down
   ```

Note: The stack requires valid .env with DATABASE_URL etc. If database is not available, Express health will show "degraded" with checks.database=false, but the container should still be "healthy" from Docker's perspective.
  </action>
  <verify>docker compose ps shows both services healthy; curl tests return expected responses</verify>
  <done>Local Docker stack runs with both services communicating successfully</done>
</task>

</tasks>

<verification>
1. docker compose build completes without errors
2. docker compose up -d starts both containers
3. docker compose ps shows: express (healthy), nextjs (healthy)
4. curl http://localhost:3001/api/health returns 200 with JSON
5. curl http://localhost:4000/health returns 200 with JSON (status may be degraded if no DB)
6. curl -I http://localhost:4000/dashboard does NOT return 502 Bad Gateway
7. docker compose down cleans up successfully
</verification>

<success_criteria>
1. docker-compose.yml validates and builds both services
2. Both containers reach healthy status
3. Express can proxy to Next.js (no ECONNREFUSED)
4. Health endpoints accessible from host machine
5. Stack cleans up properly with docker compose down
</success_criteria>

<output>
After completion, create `.planning/phases/38-containerization/38-03-SUMMARY.md`
</output>
