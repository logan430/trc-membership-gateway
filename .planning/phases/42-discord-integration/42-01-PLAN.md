---
phase: 42-discord-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/routes/auth.ts
autonomous: true

must_haves:
  truths:
    - "OAuth callback handler dispatches claim-flow users to claim callback logic instead of rejecting with invalid_state"
    - "OAuth callback handler dispatches team-claim-flow users to team-claim callback logic"
    - "DISCORD_REDIRECT_URI is either unset (relying on APP_URL fallback) or set to production URL in Coolify"
    - "DISCORD_INVITE_URL is set in Coolify to a permanent Discord server invite link"
  artifacts:
    - path: "src/routes/auth.ts"
      provides: "Unified OAuth callback that detects flow type from cookies"
      contains: "claim_state"
    - path: "Coolify env vars"
      provides: "Production Discord configuration"
      contains: "DISCORD_REDIRECT_URI or APP_URL fallback, DISCORD_INVITE_URL"
  key_links:
    - from: "/claim/discord route"
      to: "/auth/callback handler"
      via: "claim_state cookie detection"
      pattern: "cookies\\[.claim_state.\\]"
    - from: "/team/claim route"
      to: "/auth/callback handler"
      via: "team_claim_state cookie detection"
      pattern: "cookies\\[.team_claim_state.\\]"
---

<objective>
Fix the OAuth callback routing bug and configure Discord environment variables for production.

Purpose: The /auth/callback handler currently only checks for oauth_state cookie, causing /claim/discord and /team/claim flows to fail with invalid_state errors. All three OAuth flows share the same redirect_uri (generateAuthUrl always returns /auth/callback), so Discord always sends users back to /auth/callback regardless of which flow initiated the OAuth. The callback must detect which flow the user came from and route them accordingly. Additionally, Discord env vars need production values in Coolify.

Output: Fixed auth callback that handles all three OAuth flows, production Discord env vars configured in Coolify.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/42-discord-integration/42-RESEARCH.md

Key source files:
@src/auth/discord-oauth.ts
@src/routes/auth.ts
@src/routes/claim.ts
@src/routes/team-claim.ts
@src/config/env.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix /auth/callback to handle claim and team-claim OAuth flows</name>
  <files>src/routes/auth.ts</files>
  <action>
The /auth/callback handler (line ~384 in auth.ts) currently only checks for `oauth_state` cookie. When users arrive from /claim/discord or /team/claim flows, they have `claim_state` or `team_claim_state` cookies instead, causing CSRF validation to fail.

Fix the /auth/callback handler to detect which flow the user came from and route accordingly:

1. At the top of the callback handler, parse cookies and check for ALL three state cookies:
   - `oauth_state` (from /auth/discord flow)
   - `claim_state` (from /claim/discord flow)
   - `team_claim_state` (from /team/claim flow)

2. If `claim_state` is present (and matches the `state` query param), redirect the user to `/claim/callback?code=${code}&state=${state}` -- this lets the claim router's own callback handler process the claim. Clear the oauth cookies we don't need.

3. If `team_claim_state` is present (and matches the `state` query param), redirect the user to `/team/claim/callback?code=${code}&state=${state}` -- this lets the team-claim router's own callback handler process it.

4. If `oauth_state` is present (and matches), continue with the existing /auth/callback logic (the current code path).

5. If NONE of the state cookies match, redirect to `/auth/error?reason=invalid_state` (existing behavior).

Implementation approach -- add this BEFORE the existing state validation block:

```typescript
// Detect which OAuth flow this callback belongs to
const claimState = cookies[`claim_state`];
const teamClaimState = cookies['team_claim_state'];

// Route claim flow to claim callback
if (claimState && state === claimState) {
  res.redirect(`/claim/callback?code=${encodeURIComponent(code as string)}&state=${encodeURIComponent(state as string)}`);
  return;
}

// Route team claim flow to team claim callback
if (teamClaimState && state === teamClaimState) {
  res.redirect(`/team/claim/callback?code=${encodeURIComponent(code as string)}&state=${encodeURIComponent(state as string)}`);
  return;
}

// Continue with standard auth flow (existing code)
```

This approach is minimal and safe because:
- Claim and team-claim routes already have their own callback handlers with full logic
- We are just redirecting to the correct handler, not duplicating business logic
- The existing /auth/callback logic remains untouched for the standard flow
- Each flow's callback handler validates its own state cookie independently

Do NOT modify claim.ts or team-claim.ts -- they already have correct callback handlers. Only modify auth.ts.
  </action>
  <verify>
Run TypeScript compilation to verify no type errors:
```bash
npx tsc --noEmit
```

Verify the new routing logic is in place:
```bash
grep -n "claim_state\|team_claim_state" src/routes/auth.ts
```
Expected: Multiple lines showing the new cookie checks in the callback handler.
  </verify>
  <done>The /auth/callback handler detects claim_state and team_claim_state cookies and redirects to the appropriate callback handler (/claim/callback or /team/claim/callback) while preserving the code and state query parameters. Standard auth flow (oauth_state) continues to work as before.</done>
</task>

<task type="auto">
  <name>Task 2: Configure Discord environment variables in Coolify</name>
  <files></files>
  <action>
Use the Coolify API to check and configure Discord env vars. Follow the established pattern from Phase 41.

Step 1: Check existing Discord env vars in Coolify:
```bash
curl -s http://82.180.160.120:8000/api/v1/applications/wcssogsgc00o8ocwcg4c0c00/envs \
  -H "Authorization: Bearer $COOLIFY_TOKEN" | jq '.[] | select(.key | startswith("DISCORD"))'
```

Step 2: Handle DISCORD_REDIRECT_URI based on what is found:
- If set to `http://localhost:3000/auth/callback` -> DELETE it (the APP_URL fallback produces the correct production URL since APP_URL=https://app.therevenuecouncil.com)
- If set to the correct production URL -> Leave it
- If not set -> Leave it (APP_URL fallback works)

To delete, find the env UUID from the GET response and use:
```bash
curl -X DELETE http://82.180.160.120:8000/api/v1/applications/wcssogsgc00o8ocwcg4c0c00/envs/{uuid} \
  -H "Authorization: Bearer $COOLIFY_TOKEN"
```

If DELETE is not supported by the Coolify API, update the value instead:
```bash
curl -X PATCH http://82.180.160.120:8000/api/v1/applications/wcssogsgc00o8ocwcg4c0c00/envs \
  -H "Authorization: Bearer $COOLIFY_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"key": "DISCORD_REDIRECT_URI", "value": "https://app.therevenuecouncil.com/auth/callback", "is_build_time": false, "is_preview": false}'
```

IMPORTANT: Never set DISCORD_REDIRECT_URI to an empty string -- Zod validates it as `.string().url().optional()` and empty string will crash the app.

Step 3: Set DISCORD_INVITE_URL if not already set. Ask the user for their Discord server permanent invite link (e.g., https://discord.gg/XXXXX). Then set it:
```bash
curl -X PATCH http://82.180.160.120:8000/api/v1/applications/wcssogsgc00o8ocwcg4c0c00/envs \
  -H "Authorization: Bearer $COOLIFY_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"key": "DISCORD_INVITE_URL", "value": "https://discord.gg/USER_PROVIDED_VALUE", "is_build_time": false, "is_preview": false}'
```

If the user does not have an invite URL ready, skip this -- the claim flow will redirect to /dashboard as fallback, which is acceptable for now.

Step 4: Verify the COOLIFY_TOKEN is available. If not, check local .env:
```bash
grep COOLIFY .env
```

Step 5: After any env changes, trigger a Coolify rebuild to apply the new auth.ts code AND env vars:
```bash
curl -X POST http://82.180.160.120:8000/api/v1/applications/wcssogsgc00o8ocwcg4c0c00/restart \
  -H "Authorization: Bearer $COOLIFY_TOKEN"
```

Step 6: Wait for rebuild, then verify health:
```bash
curl -s https://app.therevenuecouncil.com/health | jq .
```
Expected: `{"status":"healthy","checks":{"database":true,"discord":true}}`
  </action>
  <verify>
```bash
# Verify env vars are correct
curl -s http://82.180.160.120:8000/api/v1/applications/wcssogsgc00o8ocwcg4c0c00/envs \
  -H "Authorization: Bearer $COOLIFY_TOKEN" | jq '.[] | select(.key | startswith("DISCORD")) | {key: .key, value: .value}'

# Verify app is healthy after restart
curl -s https://app.therevenuecouncil.com/health | jq .
```
  </verify>
  <done>DISCORD_REDIRECT_URI is either removed (relying on APP_URL fallback) or set to production URL. DISCORD_INVITE_URL is set if user provided invite link. App is rebuilt and healthy with discord=true.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `grep -n "claim_state" src/routes/auth.ts` shows the new routing logic in the callback handler
3. Health check at https://app.therevenuecouncil.com/health returns `{"status":"healthy","checks":{"database":true,"discord":true}}`
4. DISCORD_REDIRECT_URI is not set to localhost in Coolify
</verification>

<success_criteria>
- /auth/callback handler dispatches claim and team-claim flows to their respective callback handlers
- Production app is rebuilt with the callback fix deployed
- Discord env vars are correctly configured in Coolify
- Health check confirms discord=true
</success_criteria>

<output>
After completion, create `.planning/phases/42-discord-integration/42-01-SUMMARY.md`
</output>
